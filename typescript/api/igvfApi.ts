/**
 * IGVF Project API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import localVarRequest from 'request';
import http from 'http';

/* tslint:disable:no-unused-locals */
import { AccessKeyResults } from '../model/accessKeyResults';
import { AlignmentFileResults } from '../model/alignmentFileResults';
import { AnalysisSetResults } from '../model/analysisSetResults';
import { AnalysisStepResults } from '../model/analysisStepResults';
import { AnalysisStepVersionResults } from '../model/analysisStepVersionResults';
import { AssayTermResults } from '../model/assayTermResults';
import { AuxiliarySetResults } from '../model/auxiliarySetResults';
import { AwardResults } from '../model/awardResults';
import { BiomarkerResults } from '../model/biomarkerResults';
import { ConfigurationFileResults } from '../model/configurationFileResults';
import { ConstructLibrarySetResults } from '../model/constructLibrarySetResults';
import { CrisprModificationResults } from '../model/crisprModificationResults';
import { CuratedSetResults } from '../model/curatedSetResults';
import { DegronModificationResults } from '../model/degronModificationResults';
import { DocumentResults } from '../model/documentResults';
import { GeneLocation } from '../model/geneLocation';
import { GeneResults } from '../model/geneResults';
import { GenomeBrowserAnnotationFileResults } from '../model/genomeBrowserAnnotationFileResults';
import { HumanDonorResults } from '../model/humanDonorResults';
import { ImageFileResults } from '../model/imageFileResults';
import { ImageResults } from '../model/imageResults';
import { InVitroSystemResults } from '../model/inVitroSystemResults';
import { InstitutionalCertificateResults } from '../model/institutionalCertificateResults';
import { Item } from '../model/item';
import { ItemType } from '../model/itemType';
import { LabResults } from '../model/labResults';
import { Limit } from '../model/limit';
import { Locus } from '../model/locus';
import { MatrixFileResults } from '../model/matrixFileResults';
import { MeasurementSetResults } from '../model/measurementSetResults';
import { ModelFileResults } from '../model/modelFileResults';
import { ModelSetResults } from '../model/modelSetResults';
import { MultiplexedSampleResults } from '../model/multiplexedSampleResults';
import { NoResultsResponse } from '../model/noResultsResponse';
import { OpenReadingFrameResults } from '../model/openReadingFrameResults';
import { PageResults } from '../model/pageResults';
import { PhenotypeTermResults } from '../model/phenotypeTermResults';
import { PhenotypicFeatureResults } from '../model/phenotypicFeatureResults';
import { PlatformTermResults } from '../model/platformTermResults';
import { PredictionSetResults } from '../model/predictionSetResults';
import { PrimaryCellResults } from '../model/primaryCellResults';
import { PublicationResults } from '../model/publicationResults';
import { ReferenceFileResults } from '../model/referenceFileResults';
import { RodentDonorResults } from '../model/rodentDonorResults';
import { SampleTermResults } from '../model/sampleTermResults';
import { SearchResults } from '../model/searchResults';
import { SequenceFileResults } from '../model/sequenceFileResults';
import { SignalFileResults } from '../model/signalFileResults';
import { SoftwareResults } from '../model/softwareResults';
import { SoftwareVersionResults } from '../model/softwareVersionResults';
import { SourceResults } from '../model/sourceResults';
import { TabularFileResults } from '../model/tabularFileResults';
import { TechnicalSampleResults } from '../model/technicalSampleResults';
import { TissueResults } from '../model/tissueResults';
import { TreatmentResults } from '../model/treatmentResults';
import { UserResults } from '../model/userResults';
import { WholeOrganismResults } from '../model/wholeOrganismResults';
import { WorkflowResults } from '../model/workflowResults';

import { ObjectSerializer, Authentication, VoidAuth, Interceptor } from '../model/models';
import { HttpBasicAuth, HttpBearerAuth, ApiKeyAuth, OAuth } from '../model/models';

import { HttpError, RequestFile } from './apis';

let defaultBasePath = 'https://api.data.igvf.org';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export enum IgvfApiApiKeys {
}

export class IgvfApi {
    protected _basePath = defaultBasePath;
    protected _defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'basicAuth': new HttpBasicAuth(),
    }

    protected interceptors: Interceptor[] = [];

    constructor(basePath?: string);
    constructor(username: string, password: string, basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            this.username = basePathOrUsername;
            this.password = password
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    set defaultHeaders(defaultHeaders: any) {
        this._defaultHeaders = defaultHeaders;
    }

    get defaultHeaders() {
        return this._defaultHeaders;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
        this.authentications.default = auth;
    }

    public setApiKey(key: IgvfApiApiKeys, value: string) {
        (this.authentications as any)[IgvfApiApiKeys[key]].apiKey = value;
    }

    set username(username: string) {
        this.authentications.basicAuth.username = username;
    }

    set password(password: string) {
        this.authentications.basicAuth.password = password;
    }

    public addInterceptor(interceptor: Interceptor) {
        this.interceptors.push(interceptor);
    }

    /**
     * Collection endpoint that accepts various query parameters to filter, sort, and paginate AccessKey items. Supports filtering on fields within AccessKey items.
     * @summary List items in the AccessKey collection.
     * @param frame Constant value. Do not set.
     * @param query Query string for searching.
     * @param limit Maximum number of results to return. Default is 25. Use \&#39;all\&#39; for all results.
     * @param sort Fields to sort results by. Prefix with \&#39;-\&#39; for descending order. Can be repeated for multiple sort fields. Does not work with limit&#x3D;all.
     * @param id Filter by @id
     * @param accessKeyId Filter by access_key_id
     * @param aliases Filter by aliases
     * @param creationTimestamp Filter by creation_timestamp
     * @param description Filter by description
     * @param notes Filter by notes
     * @param secretAccessKeyHash Filter by secret_access_key_hash
     * @param status Filter by status
     * @param submittedById Filter by submitted_by.@id
     * @param submittedByTitle Filter by submitted_by.title
     * @param submitterComment Filter by submitter_comment
     * @param summary Filter by summary
     * @param user Filter by user
     * @param uuid Filter by uuid
     */
    public async accessKeys (frame: 'object', query?: string, limit?: Limit, sort?: Array<string>, id?: Array<string>, accessKeyId?: Array<string>, aliases?: Array<string>, creationTimestamp?: Array<string>, description?: Array<string>, notes?: Array<string>, secretAccessKeyHash?: Array<string>, status?: Array<'current' | 'deleted'>, submittedById?: Array<string>, submittedByTitle?: Array<string>, submitterComment?: Array<string>, summary?: Array<string>, user?: Array<string>, uuid?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: AccessKeyResults;  }> {
        const localVarPath = this.basePath + '/access-keys/@@listing';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'frame' is not null or undefined
        if (frame === null || frame === undefined) {
            throw new Error('Required parameter frame was null or undefined when calling accessKeys.');
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (frame !== undefined) {
            localVarQueryParameters['frame'] = ObjectSerializer.serialize(frame, "'object'");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "Limit");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "Array<string>");
        }

        if (id !== undefined) {
            localVarQueryParameters['@id'] = ObjectSerializer.serialize(id, "Array<string>");
        }

        if (accessKeyId !== undefined) {
            localVarQueryParameters['access_key_id'] = ObjectSerializer.serialize(accessKeyId, "Array<string>");
        }

        if (aliases !== undefined) {
            localVarQueryParameters['aliases'] = ObjectSerializer.serialize(aliases, "Array<string>");
        }

        if (creationTimestamp !== undefined) {
            localVarQueryParameters['creation_timestamp'] = ObjectSerializer.serialize(creationTimestamp, "Array<string>");
        }

        if (description !== undefined) {
            localVarQueryParameters['description'] = ObjectSerializer.serialize(description, "Array<string>");
        }

        if (notes !== undefined) {
            localVarQueryParameters['notes'] = ObjectSerializer.serialize(notes, "Array<string>");
        }

        if (secretAccessKeyHash !== undefined) {
            localVarQueryParameters['secret_access_key_hash'] = ObjectSerializer.serialize(secretAccessKeyHash, "Array<string>");
        }

        if (status !== undefined) {
            localVarQueryParameters['status'] = ObjectSerializer.serialize(status, "Array<'current' | 'deleted'>");
        }

        if (submittedById !== undefined) {
            localVarQueryParameters['submitted_by.@id'] = ObjectSerializer.serialize(submittedById, "Array<string>");
        }

        if (submittedByTitle !== undefined) {
            localVarQueryParameters['submitted_by.title'] = ObjectSerializer.serialize(submittedByTitle, "Array<string>");
        }

        if (submitterComment !== undefined) {
            localVarQueryParameters['submitter_comment'] = ObjectSerializer.serialize(submitterComment, "Array<string>");
        }

        if (summary !== undefined) {
            localVarQueryParameters['summary'] = ObjectSerializer.serialize(summary, "Array<string>");
        }

        if (user !== undefined) {
            localVarQueryParameters['user'] = ObjectSerializer.serialize(user, "Array<string>");
        }

        if (uuid !== undefined) {
            localVarQueryParameters['uuid'] = ObjectSerializer.serialize(uuid, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: AccessKeyResults;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "AccessKeyResults");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Collection endpoint that accepts various query parameters to filter, sort, and paginate AlignmentFile items. Supports filtering on fields within AlignmentFile items.
     * @summary List items in the AlignmentFile collection.
     * @param frame Constant value. Do not set.
     * @param query Query string for searching.
     * @param limit Maximum number of results to return. Default is 25. Use \&#39;all\&#39; for all results.
     * @param sort Fields to sort results by. Prefix with \&#39;-\&#39; for descending order. Can be repeated for multiple sort fields. Does not work with limit&#x3D;all.
     * @param id Filter by @id
     * @param accession Filter by accession
     * @param aliases Filter by aliases
     * @param alternateAccessions Filter by alternate_accessions
     * @param analysisStepVersion Filter by analysis_step_version
     * @param anvilUrl Filter by anvil_url
     * @param assembly Filter by assembly
     * @param awardId Filter by award.@id
     * @param awardComponent Filter by award.component
     * @param collections Filter by collections
     * @param contentMd5sum Filter by content_md5sum
     * @param contentSummary Filter by content_summary
     * @param contentType Filter by content_type
     * @param controlledAccess Filter by controlled_access
     * @param creationTimestamp Filter by creation_timestamp
     * @param dbxrefs Filter by dbxrefs
     * @param derivedFrom Filter by derived_from
     * @param description Filter by description
     * @param documents Filter by documents
     * @param fileFormat Filter by file_format
     * @param fileFormatSpecifications Filter by file_format_specifications
     * @param fileSet Filter by file_set
     * @param fileSize Filter by file_size
     * @param filtered Filter by filtered
     * @param geneListFor Filter by gene_list_for
     * @param href Filter by href
     * @param inputFileFor Filter by input_file_for
     * @param integratedIn Filter by integrated_in
     * @param labId Filter by lab.@id
     * @param labTitle Filter by lab.title
     * @param lociListFor Filter by loci_list_for
     * @param md5sum Filter by md5sum
     * @param notes Filter by notes
     * @param redacted Filter by redacted
     * @param referenceFiles Filter by reference_files
     * @param releaseTimestamp Filter by release_timestamp
     * @param revokeDetail Filter by revoke_detail
     * @param s3Uri Filter by s3_uri
     * @param status Filter by status
     * @param submittedById Filter by submitted_by.@id
     * @param submittedByTitle Filter by submitted_by.title
     * @param submittedFileName Filter by submitted_file_name
     * @param submitterComment Filter by submitter_comment
     * @param summary Filter by summary
     * @param transcriptomeAnnotation Filter by transcriptome_annotation
     * @param uploadStatus Filter by upload_status
     * @param uuid Filter by uuid
     * @param validationErrorDetail Filter by validation_error_detail
     */
    public async alignmentFiles (frame: 'object', query?: string, limit?: Limit, sort?: Array<string>, id?: Array<string>, accession?: Array<string>, aliases?: Array<string>, alternateAccessions?: Array<string>, analysisStepVersion?: Array<string>, anvilUrl?: Array<string>, assembly?: Array<'GRCh38' | 'GRCm39'>, awardId?: Array<string>, awardComponent?: Array<'affiliate' | 'data analysis' | 'data coordination' | 'functional characterization' | 'mapping' | 'networks' | 'predictive modeling'>, collections?: Array<'ClinGen' | 'ENCODE' | 'GREGoR' | 'IGVF_catalog_beta_v0.1' | 'IGVF_catalog_beta_v0.2' | 'IGVF_catalog_beta_v0.3' | 'IGVF_catalog_beta_v0.4' | 'MaveDB' | 'MPRAbase' | 'Vista'>, contentMd5sum?: Array<string>, contentSummary?: Array<string>, contentType?: Array<string>, controlledAccess?: Array<boolean>, creationTimestamp?: Array<string>, dbxrefs?: Array<string>, derivedFrom?: Array<string>, description?: Array<string>, documents?: Array<string>, fileFormat?: Array<'bam'>, fileFormatSpecifications?: Array<string>, fileSet?: Array<string>, fileSize?: Array<number>, filtered?: Array<boolean>, geneListFor?: Array<string>, href?: Array<string>, inputFileFor?: Array<string>, integratedIn?: Array<string>, labId?: Array<string>, labTitle?: Array<string>, lociListFor?: Array<string>, md5sum?: Array<string>, notes?: Array<string>, redacted?: Array<boolean>, referenceFiles?: Array<string>, releaseTimestamp?: Array<string>, revokeDetail?: Array<string>, s3Uri?: Array<string>, status?: Array<'in progress' | 'released' | 'deleted' | 'replaced' | 'revoked' | 'archived'>, submittedById?: Array<string>, submittedByTitle?: Array<string>, submittedFileName?: Array<string>, submitterComment?: Array<string>, summary?: Array<string>, transcriptomeAnnotation?: Array<'GENCODE 40' | 'GENCODE 41' | 'GENCODE 42' | 'GENCODE 43' | 'GENCODE 44' | 'GENCODE 45' | 'GENCODE M30' | 'GENCODE M31' | 'GENCODE M32' | 'GENCODE M33' | 'GENCODE M34'>, uploadStatus?: Array<'pending' | 'file not found' | 'invalidated' | 'validated'>, uuid?: Array<string>, validationErrorDetail?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: AlignmentFileResults;  }> {
        const localVarPath = this.basePath + '/alignment-files/@@listing';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'frame' is not null or undefined
        if (frame === null || frame === undefined) {
            throw new Error('Required parameter frame was null or undefined when calling alignmentFiles.');
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (frame !== undefined) {
            localVarQueryParameters['frame'] = ObjectSerializer.serialize(frame, "'object'");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "Limit");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "Array<string>");
        }

        if (id !== undefined) {
            localVarQueryParameters['@id'] = ObjectSerializer.serialize(id, "Array<string>");
        }

        if (accession !== undefined) {
            localVarQueryParameters['accession'] = ObjectSerializer.serialize(accession, "Array<string>");
        }

        if (aliases !== undefined) {
            localVarQueryParameters['aliases'] = ObjectSerializer.serialize(aliases, "Array<string>");
        }

        if (alternateAccessions !== undefined) {
            localVarQueryParameters['alternate_accessions'] = ObjectSerializer.serialize(alternateAccessions, "Array<string>");
        }

        if (analysisStepVersion !== undefined) {
            localVarQueryParameters['analysis_step_version'] = ObjectSerializer.serialize(analysisStepVersion, "Array<string>");
        }

        if (anvilUrl !== undefined) {
            localVarQueryParameters['anvil_url'] = ObjectSerializer.serialize(anvilUrl, "Array<string>");
        }

        if (assembly !== undefined) {
            localVarQueryParameters['assembly'] = ObjectSerializer.serialize(assembly, "Array<'GRCh38' | 'GRCm39'>");
        }

        if (awardId !== undefined) {
            localVarQueryParameters['award.@id'] = ObjectSerializer.serialize(awardId, "Array<string>");
        }

        if (awardComponent !== undefined) {
            localVarQueryParameters['award.component'] = ObjectSerializer.serialize(awardComponent, "Array<'affiliate' | 'data analysis' | 'data coordination' | 'functional characterization' | 'mapping' | 'networks' | 'predictive modeling'>");
        }

        if (collections !== undefined) {
            localVarQueryParameters['collections'] = ObjectSerializer.serialize(collections, "Array<'ClinGen' | 'ENCODE' | 'GREGoR' | 'IGVF_catalog_beta_v0.1' | 'IGVF_catalog_beta_v0.2' | 'IGVF_catalog_beta_v0.3' | 'IGVF_catalog_beta_v0.4' | 'MaveDB' | 'MPRAbase' | 'Vista'>");
        }

        if (contentMd5sum !== undefined) {
            localVarQueryParameters['content_md5sum'] = ObjectSerializer.serialize(contentMd5sum, "Array<string>");
        }

        if (contentSummary !== undefined) {
            localVarQueryParameters['content_summary'] = ObjectSerializer.serialize(contentSummary, "Array<string>");
        }

        if (contentType !== undefined) {
            localVarQueryParameters['content_type'] = ObjectSerializer.serialize(contentType, "Array<string>");
        }

        if (controlledAccess !== undefined) {
            localVarQueryParameters['controlled_access'] = ObjectSerializer.serialize(controlledAccess, "Array<boolean>");
        }

        if (creationTimestamp !== undefined) {
            localVarQueryParameters['creation_timestamp'] = ObjectSerializer.serialize(creationTimestamp, "Array<string>");
        }

        if (dbxrefs !== undefined) {
            localVarQueryParameters['dbxrefs'] = ObjectSerializer.serialize(dbxrefs, "Array<string>");
        }

        if (derivedFrom !== undefined) {
            localVarQueryParameters['derived_from'] = ObjectSerializer.serialize(derivedFrom, "Array<string>");
        }

        if (description !== undefined) {
            localVarQueryParameters['description'] = ObjectSerializer.serialize(description, "Array<string>");
        }

        if (documents !== undefined) {
            localVarQueryParameters['documents'] = ObjectSerializer.serialize(documents, "Array<string>");
        }

        if (fileFormat !== undefined) {
            localVarQueryParameters['file_format'] = ObjectSerializer.serialize(fileFormat, "Array<'bam'>");
        }

        if (fileFormatSpecifications !== undefined) {
            localVarQueryParameters['file_format_specifications'] = ObjectSerializer.serialize(fileFormatSpecifications, "Array<string>");
        }

        if (fileSet !== undefined) {
            localVarQueryParameters['file_set'] = ObjectSerializer.serialize(fileSet, "Array<string>");
        }

        if (fileSize !== undefined) {
            localVarQueryParameters['file_size'] = ObjectSerializer.serialize(fileSize, "Array<number>");
        }

        if (filtered !== undefined) {
            localVarQueryParameters['filtered'] = ObjectSerializer.serialize(filtered, "Array<boolean>");
        }

        if (geneListFor !== undefined) {
            localVarQueryParameters['gene_list_for'] = ObjectSerializer.serialize(geneListFor, "Array<string>");
        }

        if (href !== undefined) {
            localVarQueryParameters['href'] = ObjectSerializer.serialize(href, "Array<string>");
        }

        if (inputFileFor !== undefined) {
            localVarQueryParameters['input_file_for'] = ObjectSerializer.serialize(inputFileFor, "Array<string>");
        }

        if (integratedIn !== undefined) {
            localVarQueryParameters['integrated_in'] = ObjectSerializer.serialize(integratedIn, "Array<string>");
        }

        if (labId !== undefined) {
            localVarQueryParameters['lab.@id'] = ObjectSerializer.serialize(labId, "Array<string>");
        }

        if (labTitle !== undefined) {
            localVarQueryParameters['lab.title'] = ObjectSerializer.serialize(labTitle, "Array<string>");
        }

        if (lociListFor !== undefined) {
            localVarQueryParameters['loci_list_for'] = ObjectSerializer.serialize(lociListFor, "Array<string>");
        }

        if (md5sum !== undefined) {
            localVarQueryParameters['md5sum'] = ObjectSerializer.serialize(md5sum, "Array<string>");
        }

        if (notes !== undefined) {
            localVarQueryParameters['notes'] = ObjectSerializer.serialize(notes, "Array<string>");
        }

        if (redacted !== undefined) {
            localVarQueryParameters['redacted'] = ObjectSerializer.serialize(redacted, "Array<boolean>");
        }

        if (referenceFiles !== undefined) {
            localVarQueryParameters['reference_files'] = ObjectSerializer.serialize(referenceFiles, "Array<string>");
        }

        if (releaseTimestamp !== undefined) {
            localVarQueryParameters['release_timestamp'] = ObjectSerializer.serialize(releaseTimestamp, "Array<string>");
        }

        if (revokeDetail !== undefined) {
            localVarQueryParameters['revoke_detail'] = ObjectSerializer.serialize(revokeDetail, "Array<string>");
        }

        if (s3Uri !== undefined) {
            localVarQueryParameters['s3_uri'] = ObjectSerializer.serialize(s3Uri, "Array<string>");
        }

        if (status !== undefined) {
            localVarQueryParameters['status'] = ObjectSerializer.serialize(status, "Array<'in progress' | 'released' | 'deleted' | 'replaced' | 'revoked' | 'archived'>");
        }

        if (submittedById !== undefined) {
            localVarQueryParameters['submitted_by.@id'] = ObjectSerializer.serialize(submittedById, "Array<string>");
        }

        if (submittedByTitle !== undefined) {
            localVarQueryParameters['submitted_by.title'] = ObjectSerializer.serialize(submittedByTitle, "Array<string>");
        }

        if (submittedFileName !== undefined) {
            localVarQueryParameters['submitted_file_name'] = ObjectSerializer.serialize(submittedFileName, "Array<string>");
        }

        if (submitterComment !== undefined) {
            localVarQueryParameters['submitter_comment'] = ObjectSerializer.serialize(submitterComment, "Array<string>");
        }

        if (summary !== undefined) {
            localVarQueryParameters['summary'] = ObjectSerializer.serialize(summary, "Array<string>");
        }

        if (transcriptomeAnnotation !== undefined) {
            localVarQueryParameters['transcriptome_annotation'] = ObjectSerializer.serialize(transcriptomeAnnotation, "Array<'GENCODE 40' | 'GENCODE 41' | 'GENCODE 42' | 'GENCODE 43' | 'GENCODE 44' | 'GENCODE 45' | 'GENCODE M30' | 'GENCODE M31' | 'GENCODE M32' | 'GENCODE M33' | 'GENCODE M34'>");
        }

        if (uploadStatus !== undefined) {
            localVarQueryParameters['upload_status'] = ObjectSerializer.serialize(uploadStatus, "Array<'pending' | 'file not found' | 'invalidated' | 'validated'>");
        }

        if (uuid !== undefined) {
            localVarQueryParameters['uuid'] = ObjectSerializer.serialize(uuid, "Array<string>");
        }

        if (validationErrorDetail !== undefined) {
            localVarQueryParameters['validation_error_detail'] = ObjectSerializer.serialize(validationErrorDetail, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: AlignmentFileResults;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "AlignmentFileResults");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Collection endpoint that accepts various query parameters to filter, sort, and paginate AnalysisSet items. Supports filtering on fields within AnalysisSet items.
     * @summary List items in the AnalysisSet collection.
     * @param frame Constant value. Do not set.
     * @param query Query string for searching.
     * @param limit Maximum number of results to return. Default is 25. Use \&#39;all\&#39; for all results.
     * @param sort Fields to sort results by. Prefix with \&#39;-\&#39; for descending order. Can be repeated for multiple sort fields. Does not work with limit&#x3D;all.
     * @param id Filter by @id
     * @param accession Filter by accession
     * @param aliases Filter by aliases
     * @param alternateAccessions Filter by alternate_accessions
     * @param assayTitles Filter by assay_titles
     * @param awardId Filter by award.@id
     * @param awardComponent Filter by award.component
     * @param awardContactPiId Filter by award.contact_pi.@id
     * @param awardContactPiTitle Filter by award.contact_pi.title
     * @param awardTitle Filter by award.title
     * @param collections Filter by collections
     * @param controlForId Filter by control_for.@id
     * @param controlForAccession Filter by control_for.accession
     * @param controlForAliases Filter by control_for.aliases
     * @param creationTimestamp Filter by creation_timestamp
     * @param dbxrefs Filter by dbxrefs
     * @param description Filter by description
     * @param documents Filter by documents
     * @param donorsId Filter by donors.@id
     * @param donorsAccession Filter by donors.accession
     * @param donorsAliases Filter by donors.aliases
     * @param donorsSex Filter by donors.sex
     * @param donorsStatus Filter by donors.status
     * @param donorsTaxa Filter by donors.taxa
     * @param fileSetType Filter by file_set_type
     * @param filesId Filter by files.@id
     * @param filesAccession Filter by files.accession
     * @param filesAliases Filter by files.aliases
     * @param filesContentType Filter by files.content_type
     * @param filesCreationTimestamp Filter by files.creation_timestamp
     * @param filesFileFormat Filter by files.file_format
     * @param filesFileSize Filter by files.file_size
     * @param filesHref Filter by files.href
     * @param filesS3Uri Filter by files.s3_uri
     * @param filesSequencingPlatform Filter by files.sequencing_platform
     * @param filesSubmittedFileName Filter by files.submitted_file_name
     * @param filesUploadStatus Filter by files.upload_status
     * @param inputFileSetFor Filter by input_file_set_for
     * @param inputFileSetsId Filter by input_file_sets.@id
     * @param inputFileSetsAccession Filter by input_file_sets.accession
     * @param inputFileSetsAliases Filter by input_file_sets.aliases
     * @param inputFileSetsFileSetType Filter by input_file_sets.file_set_type
     * @param labId Filter by lab.@id
     * @param labTitle Filter by lab.title
     * @param notes Filter by notes
     * @param publicationIdentifiers Filter by publication_identifiers
     * @param publications Filter by publications
     * @param releaseTimestamp Filter by release_timestamp
     * @param revokeDetail Filter by revoke_detail
     * @param samplesId Filter by samples.@id
     * @param samplesAccession Filter by samples.accession
     * @param samplesAliases Filter by samples.aliases
     * @param samplesCellFateChangeTreatments Filter by samples.cell_fate_change_treatments
     * @param samplesClassifications Filter by samples.classifications
     * @param samplesConstructLibrarySets Filter by samples.construct_library_sets
     * @param samplesDiseaseTermsId Filter by samples.disease_terms.@id
     * @param samplesDiseaseTermsTermName Filter by samples.disease_terms.term_name
     * @param samplesModifications Filter by samples.modifications
     * @param samplesSampleTermsId Filter by samples.sample_terms.@id
     * @param samplesSampleTermsAliases Filter by samples.sample_terms.aliases
     * @param samplesSampleTermsStatus Filter by samples.sample_terms.status
     * @param samplesSampleTermsSummary Filter by samples.sample_terms.summary
     * @param samplesSampleTermsTermName Filter by samples.sample_terms.term_name
     * @param samplesStatus Filter by samples.status
     * @param samplesSummary Filter by samples.summary
     * @param samplesTargetedSampleTermId Filter by samples.targeted_sample_term.@id
     * @param samplesTargetedSampleTermTermName Filter by samples.targeted_sample_term.term_name
     * @param samplesTaxa Filter by samples.taxa
     * @param samplesTreatments Filter by samples.treatments
     * @param status Filter by status
     * @param submittedById Filter by submitted_by.@id
     * @param submittedByTitle Filter by submitted_by.title
     * @param submittedFilesTimestamp Filter by submitted_files_timestamp
     * @param submitterComment Filter by submitter_comment
     * @param summary Filter by summary
     * @param uuid Filter by uuid
     */
    public async analysisSets (frame: 'object', query?: string, limit?: Limit, sort?: Array<string>, id?: Array<string>, accession?: Array<string>, aliases?: Array<string>, alternateAccessions?: Array<string>, assayTitles?: Array<string>, awardId?: Array<string>, awardComponent?: Array<'affiliate' | 'data analysis' | 'data coordination' | 'functional characterization' | 'mapping' | 'networks' | 'predictive modeling'>, awardContactPiId?: Array<string>, awardContactPiTitle?: Array<string>, awardTitle?: Array<string>, collections?: Array<'ClinGen' | 'ENCODE' | 'GREGoR' | 'IGVF_catalog_beta_v0.1' | 'IGVF_catalog_beta_v0.2' | 'IGVF_catalog_beta_v0.3' | 'IGVF_catalog_beta_v0.4' | 'MaveDB' | 'MPRAbase' | 'Vista'>, controlForId?: Array<string>, controlForAccession?: Array<string>, controlForAliases?: Array<string>, creationTimestamp?: Array<string>, dbxrefs?: Array<string>, description?: Array<string>, documents?: Array<string>, donorsId?: Array<string>, donorsAccession?: Array<string>, donorsAliases?: Array<string>, donorsSex?: Array<'male' | 'female' | 'unspecified'>, donorsStatus?: Array<'in progress' | 'released' | 'deleted' | 'replaced' | 'revoked' | 'archived'>, donorsTaxa?: Array<string>, fileSetType?: Array<'intermediate analysis' | 'principal analysis'>, filesId?: Array<string>, filesAccession?: Array<string>, filesAliases?: Array<string>, filesContentType?: Array<string>, filesCreationTimestamp?: Array<string>, filesFileFormat?: Array<string>, filesFileSize?: Array<number>, filesHref?: Array<string>, filesS3Uri?: Array<string>, filesSequencingPlatform?: Array<string>, filesSubmittedFileName?: Array<string>, filesUploadStatus?: Array<'pending' | 'file not found' | 'invalidated' | 'validated'>, inputFileSetFor?: Array<string>, inputFileSetsId?: Array<string>, inputFileSetsAccession?: Array<string>, inputFileSetsAliases?: Array<string>, inputFileSetsFileSetType?: Array<'pathogenicity' | 'functional effect' | 'protein stability' | 'activity level' | 'binding effect'>, labId?: Array<string>, labTitle?: Array<string>, notes?: Array<string>, publicationIdentifiers?: Array<string>, publications?: Array<string>, releaseTimestamp?: Array<string>, revokeDetail?: Array<string>, samplesId?: Array<string>, samplesAccession?: Array<string>, samplesAliases?: Array<string>, samplesCellFateChangeTreatments?: Array<string>, samplesClassifications?: Array<'organoid' | 'gastruloid' | 'embryoid' | 'cell line' | 'differentiated cell specimen' | 'reprogrammed cell specimen' | 'pooled cell specimen'>, samplesConstructLibrarySets?: Array<string>, samplesDiseaseTermsId?: Array<string>, samplesDiseaseTermsTermName?: Array<string>, samplesModifications?: Array<string>, samplesSampleTermsId?: Array<string>, samplesSampleTermsAliases?: Array<string>, samplesSampleTermsStatus?: Array<'archived' | 'deleted' | 'in progress' | 'released'>, samplesSampleTermsSummary?: Array<string>, samplesSampleTermsTermName?: Array<string>, samplesStatus?: Array<'in progress' | 'released' | 'deleted' | 'replaced' | 'revoked' | 'archived'>, samplesSummary?: Array<string>, samplesTargetedSampleTermId?: Array<string>, samplesTargetedSampleTermTermName?: Array<string>, samplesTaxa?: Array<'Homo sapiens' | 'Mus musculus'>, samplesTreatments?: Array<string>, status?: Array<'in progress' | 'released' | 'deleted' | 'replaced' | 'revoked' | 'archived'>, submittedById?: Array<string>, submittedByTitle?: Array<string>, submittedFilesTimestamp?: Array<string>, submitterComment?: Array<string>, summary?: Array<string>, uuid?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: AnalysisSetResults;  }> {
        const localVarPath = this.basePath + '/analysis-sets/@@listing';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'frame' is not null or undefined
        if (frame === null || frame === undefined) {
            throw new Error('Required parameter frame was null or undefined when calling analysisSets.');
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (frame !== undefined) {
            localVarQueryParameters['frame'] = ObjectSerializer.serialize(frame, "'object'");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "Limit");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "Array<string>");
        }

        if (id !== undefined) {
            localVarQueryParameters['@id'] = ObjectSerializer.serialize(id, "Array<string>");
        }

        if (accession !== undefined) {
            localVarQueryParameters['accession'] = ObjectSerializer.serialize(accession, "Array<string>");
        }

        if (aliases !== undefined) {
            localVarQueryParameters['aliases'] = ObjectSerializer.serialize(aliases, "Array<string>");
        }

        if (alternateAccessions !== undefined) {
            localVarQueryParameters['alternate_accessions'] = ObjectSerializer.serialize(alternateAccessions, "Array<string>");
        }

        if (assayTitles !== undefined) {
            localVarQueryParameters['assay_titles'] = ObjectSerializer.serialize(assayTitles, "Array<string>");
        }

        if (awardId !== undefined) {
            localVarQueryParameters['award.@id'] = ObjectSerializer.serialize(awardId, "Array<string>");
        }

        if (awardComponent !== undefined) {
            localVarQueryParameters['award.component'] = ObjectSerializer.serialize(awardComponent, "Array<'affiliate' | 'data analysis' | 'data coordination' | 'functional characterization' | 'mapping' | 'networks' | 'predictive modeling'>");
        }

        if (awardContactPiId !== undefined) {
            localVarQueryParameters['award.contact_pi.@id'] = ObjectSerializer.serialize(awardContactPiId, "Array<string>");
        }

        if (awardContactPiTitle !== undefined) {
            localVarQueryParameters['award.contact_pi.title'] = ObjectSerializer.serialize(awardContactPiTitle, "Array<string>");
        }

        if (awardTitle !== undefined) {
            localVarQueryParameters['award.title'] = ObjectSerializer.serialize(awardTitle, "Array<string>");
        }

        if (collections !== undefined) {
            localVarQueryParameters['collections'] = ObjectSerializer.serialize(collections, "Array<'ClinGen' | 'ENCODE' | 'GREGoR' | 'IGVF_catalog_beta_v0.1' | 'IGVF_catalog_beta_v0.2' | 'IGVF_catalog_beta_v0.3' | 'IGVF_catalog_beta_v0.4' | 'MaveDB' | 'MPRAbase' | 'Vista'>");
        }

        if (controlForId !== undefined) {
            localVarQueryParameters['control_for.@id'] = ObjectSerializer.serialize(controlForId, "Array<string>");
        }

        if (controlForAccession !== undefined) {
            localVarQueryParameters['control_for.accession'] = ObjectSerializer.serialize(controlForAccession, "Array<string>");
        }

        if (controlForAliases !== undefined) {
            localVarQueryParameters['control_for.aliases'] = ObjectSerializer.serialize(controlForAliases, "Array<string>");
        }

        if (creationTimestamp !== undefined) {
            localVarQueryParameters['creation_timestamp'] = ObjectSerializer.serialize(creationTimestamp, "Array<string>");
        }

        if (dbxrefs !== undefined) {
            localVarQueryParameters['dbxrefs'] = ObjectSerializer.serialize(dbxrefs, "Array<string>");
        }

        if (description !== undefined) {
            localVarQueryParameters['description'] = ObjectSerializer.serialize(description, "Array<string>");
        }

        if (documents !== undefined) {
            localVarQueryParameters['documents'] = ObjectSerializer.serialize(documents, "Array<string>");
        }

        if (donorsId !== undefined) {
            localVarQueryParameters['donors.@id'] = ObjectSerializer.serialize(donorsId, "Array<string>");
        }

        if (donorsAccession !== undefined) {
            localVarQueryParameters['donors.accession'] = ObjectSerializer.serialize(donorsAccession, "Array<string>");
        }

        if (donorsAliases !== undefined) {
            localVarQueryParameters['donors.aliases'] = ObjectSerializer.serialize(donorsAliases, "Array<string>");
        }

        if (donorsSex !== undefined) {
            localVarQueryParameters['donors.sex'] = ObjectSerializer.serialize(donorsSex, "Array<'male' | 'female' | 'unspecified'>");
        }

        if (donorsStatus !== undefined) {
            localVarQueryParameters['donors.status'] = ObjectSerializer.serialize(donorsStatus, "Array<'in progress' | 'released' | 'deleted' | 'replaced' | 'revoked' | 'archived'>");
        }

        if (donorsTaxa !== undefined) {
            localVarQueryParameters['donors.taxa'] = ObjectSerializer.serialize(donorsTaxa, "Array<string>");
        }

        if (fileSetType !== undefined) {
            localVarQueryParameters['file_set_type'] = ObjectSerializer.serialize(fileSetType, "Array<'intermediate analysis' | 'principal analysis'>");
        }

        if (filesId !== undefined) {
            localVarQueryParameters['files.@id'] = ObjectSerializer.serialize(filesId, "Array<string>");
        }

        if (filesAccession !== undefined) {
            localVarQueryParameters['files.accession'] = ObjectSerializer.serialize(filesAccession, "Array<string>");
        }

        if (filesAliases !== undefined) {
            localVarQueryParameters['files.aliases'] = ObjectSerializer.serialize(filesAliases, "Array<string>");
        }

        if (filesContentType !== undefined) {
            localVarQueryParameters['files.content_type'] = ObjectSerializer.serialize(filesContentType, "Array<string>");
        }

        if (filesCreationTimestamp !== undefined) {
            localVarQueryParameters['files.creation_timestamp'] = ObjectSerializer.serialize(filesCreationTimestamp, "Array<string>");
        }

        if (filesFileFormat !== undefined) {
            localVarQueryParameters['files.file_format'] = ObjectSerializer.serialize(filesFileFormat, "Array<string>");
        }

        if (filesFileSize !== undefined) {
            localVarQueryParameters['files.file_size'] = ObjectSerializer.serialize(filesFileSize, "Array<number>");
        }

        if (filesHref !== undefined) {
            localVarQueryParameters['files.href'] = ObjectSerializer.serialize(filesHref, "Array<string>");
        }

        if (filesS3Uri !== undefined) {
            localVarQueryParameters['files.s3_uri'] = ObjectSerializer.serialize(filesS3Uri, "Array<string>");
        }

        if (filesSequencingPlatform !== undefined) {
            localVarQueryParameters['files.sequencing_platform'] = ObjectSerializer.serialize(filesSequencingPlatform, "Array<string>");
        }

        if (filesSubmittedFileName !== undefined) {
            localVarQueryParameters['files.submitted_file_name'] = ObjectSerializer.serialize(filesSubmittedFileName, "Array<string>");
        }

        if (filesUploadStatus !== undefined) {
            localVarQueryParameters['files.upload_status'] = ObjectSerializer.serialize(filesUploadStatus, "Array<'pending' | 'file not found' | 'invalidated' | 'validated'>");
        }

        if (inputFileSetFor !== undefined) {
            localVarQueryParameters['input_file_set_for'] = ObjectSerializer.serialize(inputFileSetFor, "Array<string>");
        }

        if (inputFileSetsId !== undefined) {
            localVarQueryParameters['input_file_sets.@id'] = ObjectSerializer.serialize(inputFileSetsId, "Array<string>");
        }

        if (inputFileSetsAccession !== undefined) {
            localVarQueryParameters['input_file_sets.accession'] = ObjectSerializer.serialize(inputFileSetsAccession, "Array<string>");
        }

        if (inputFileSetsAliases !== undefined) {
            localVarQueryParameters['input_file_sets.aliases'] = ObjectSerializer.serialize(inputFileSetsAliases, "Array<string>");
        }

        if (inputFileSetsFileSetType !== undefined) {
            localVarQueryParameters['input_file_sets.file_set_type'] = ObjectSerializer.serialize(inputFileSetsFileSetType, "Array<'pathogenicity' | 'functional effect' | 'protein stability' | 'activity level' | 'binding effect'>");
        }

        if (labId !== undefined) {
            localVarQueryParameters['lab.@id'] = ObjectSerializer.serialize(labId, "Array<string>");
        }

        if (labTitle !== undefined) {
            localVarQueryParameters['lab.title'] = ObjectSerializer.serialize(labTitle, "Array<string>");
        }

        if (notes !== undefined) {
            localVarQueryParameters['notes'] = ObjectSerializer.serialize(notes, "Array<string>");
        }

        if (publicationIdentifiers !== undefined) {
            localVarQueryParameters['publication_identifiers'] = ObjectSerializer.serialize(publicationIdentifiers, "Array<string>");
        }

        if (publications !== undefined) {
            localVarQueryParameters['publications'] = ObjectSerializer.serialize(publications, "Array<string>");
        }

        if (releaseTimestamp !== undefined) {
            localVarQueryParameters['release_timestamp'] = ObjectSerializer.serialize(releaseTimestamp, "Array<string>");
        }

        if (revokeDetail !== undefined) {
            localVarQueryParameters['revoke_detail'] = ObjectSerializer.serialize(revokeDetail, "Array<string>");
        }

        if (samplesId !== undefined) {
            localVarQueryParameters['samples.@id'] = ObjectSerializer.serialize(samplesId, "Array<string>");
        }

        if (samplesAccession !== undefined) {
            localVarQueryParameters['samples.accession'] = ObjectSerializer.serialize(samplesAccession, "Array<string>");
        }

        if (samplesAliases !== undefined) {
            localVarQueryParameters['samples.aliases'] = ObjectSerializer.serialize(samplesAliases, "Array<string>");
        }

        if (samplesCellFateChangeTreatments !== undefined) {
            localVarQueryParameters['samples.cell_fate_change_treatments'] = ObjectSerializer.serialize(samplesCellFateChangeTreatments, "Array<string>");
        }

        if (samplesClassifications !== undefined) {
            localVarQueryParameters['samples.classifications'] = ObjectSerializer.serialize(samplesClassifications, "Array<'organoid' | 'gastruloid' | 'embryoid' | 'cell line' | 'differentiated cell specimen' | 'reprogrammed cell specimen' | 'pooled cell specimen'>");
        }

        if (samplesConstructLibrarySets !== undefined) {
            localVarQueryParameters['samples.construct_library_sets'] = ObjectSerializer.serialize(samplesConstructLibrarySets, "Array<string>");
        }

        if (samplesDiseaseTermsId !== undefined) {
            localVarQueryParameters['samples.disease_terms.@id'] = ObjectSerializer.serialize(samplesDiseaseTermsId, "Array<string>");
        }

        if (samplesDiseaseTermsTermName !== undefined) {
            localVarQueryParameters['samples.disease_terms.term_name'] = ObjectSerializer.serialize(samplesDiseaseTermsTermName, "Array<string>");
        }

        if (samplesModifications !== undefined) {
            localVarQueryParameters['samples.modifications'] = ObjectSerializer.serialize(samplesModifications, "Array<string>");
        }

        if (samplesSampleTermsId !== undefined) {
            localVarQueryParameters['samples.sample_terms.@id'] = ObjectSerializer.serialize(samplesSampleTermsId, "Array<string>");
        }

        if (samplesSampleTermsAliases !== undefined) {
            localVarQueryParameters['samples.sample_terms.aliases'] = ObjectSerializer.serialize(samplesSampleTermsAliases, "Array<string>");
        }

        if (samplesSampleTermsStatus !== undefined) {
            localVarQueryParameters['samples.sample_terms.status'] = ObjectSerializer.serialize(samplesSampleTermsStatus, "Array<'archived' | 'deleted' | 'in progress' | 'released'>");
        }

        if (samplesSampleTermsSummary !== undefined) {
            localVarQueryParameters['samples.sample_terms.summary'] = ObjectSerializer.serialize(samplesSampleTermsSummary, "Array<string>");
        }

        if (samplesSampleTermsTermName !== undefined) {
            localVarQueryParameters['samples.sample_terms.term_name'] = ObjectSerializer.serialize(samplesSampleTermsTermName, "Array<string>");
        }

        if (samplesStatus !== undefined) {
            localVarQueryParameters['samples.status'] = ObjectSerializer.serialize(samplesStatus, "Array<'in progress' | 'released' | 'deleted' | 'replaced' | 'revoked' | 'archived'>");
        }

        if (samplesSummary !== undefined) {
            localVarQueryParameters['samples.summary'] = ObjectSerializer.serialize(samplesSummary, "Array<string>");
        }

        if (samplesTargetedSampleTermId !== undefined) {
            localVarQueryParameters['samples.targeted_sample_term.@id'] = ObjectSerializer.serialize(samplesTargetedSampleTermId, "Array<string>");
        }

        if (samplesTargetedSampleTermTermName !== undefined) {
            localVarQueryParameters['samples.targeted_sample_term.term_name'] = ObjectSerializer.serialize(samplesTargetedSampleTermTermName, "Array<string>");
        }

        if (samplesTaxa !== undefined) {
            localVarQueryParameters['samples.taxa'] = ObjectSerializer.serialize(samplesTaxa, "Array<'Homo sapiens' | 'Mus musculus'>");
        }

        if (samplesTreatments !== undefined) {
            localVarQueryParameters['samples.treatments'] = ObjectSerializer.serialize(samplesTreatments, "Array<string>");
        }

        if (status !== undefined) {
            localVarQueryParameters['status'] = ObjectSerializer.serialize(status, "Array<'in progress' | 'released' | 'deleted' | 'replaced' | 'revoked' | 'archived'>");
        }

        if (submittedById !== undefined) {
            localVarQueryParameters['submitted_by.@id'] = ObjectSerializer.serialize(submittedById, "Array<string>");
        }

        if (submittedByTitle !== undefined) {
            localVarQueryParameters['submitted_by.title'] = ObjectSerializer.serialize(submittedByTitle, "Array<string>");
        }

        if (submittedFilesTimestamp !== undefined) {
            localVarQueryParameters['submitted_files_timestamp'] = ObjectSerializer.serialize(submittedFilesTimestamp, "Array<string>");
        }

        if (submitterComment !== undefined) {
            localVarQueryParameters['submitter_comment'] = ObjectSerializer.serialize(submitterComment, "Array<string>");
        }

        if (summary !== undefined) {
            localVarQueryParameters['summary'] = ObjectSerializer.serialize(summary, "Array<string>");
        }

        if (uuid !== undefined) {
            localVarQueryParameters['uuid'] = ObjectSerializer.serialize(uuid, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: AnalysisSetResults;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "AnalysisSetResults");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Collection endpoint that accepts various query parameters to filter, sort, and paginate AnalysisStepVersion items. Supports filtering on fields within AnalysisStepVersion items.
     * @summary List items in the AnalysisStepVersion collection.
     * @param frame Constant value. Do not set.
     * @param query Query string for searching.
     * @param limit Maximum number of results to return. Default is 25. Use \&#39;all\&#39; for all results.
     * @param sort Fields to sort results by. Prefix with \&#39;-\&#39; for descending order. Can be repeated for multiple sort fields. Does not work with limit&#x3D;all.
     * @param id Filter by @id
     * @param aliases Filter by aliases
     * @param analysisStepId Filter by analysis_step.@id
     * @param analysisStepName Filter by analysis_step.name
     * @param awardId Filter by award.@id
     * @param awardComponent Filter by award.component
     * @param creationTimestamp Filter by creation_timestamp
     * @param description Filter by description
     * @param labId Filter by lab.@id
     * @param labTitle Filter by lab.title
     * @param notes Filter by notes
     * @param releaseTimestamp Filter by release_timestamp
     * @param softwareVersionsId Filter by software_versions.@id
     * @param softwareVersionsName Filter by software_versions.name
     * @param status Filter by status
     * @param submittedById Filter by submitted_by.@id
     * @param submittedByTitle Filter by submitted_by.title
     * @param submitterComment Filter by submitter_comment
     * @param summary Filter by summary
     * @param uuid Filter by uuid
     */
    public async analysisStepVersions (frame: 'object', query?: string, limit?: Limit, sort?: Array<string>, id?: Array<string>, aliases?: Array<string>, analysisStepId?: Array<string>, analysisStepName?: Array<string>, awardId?: Array<string>, awardComponent?: Array<'affiliate' | 'data analysis' | 'data coordination' | 'functional characterization' | 'mapping' | 'networks' | 'predictive modeling'>, creationTimestamp?: Array<string>, description?: Array<string>, labId?: Array<string>, labTitle?: Array<string>, notes?: Array<string>, releaseTimestamp?: Array<string>, softwareVersionsId?: Array<string>, softwareVersionsName?: Array<string>, status?: Array<'archived' | 'deleted' | 'in progress' | 'released'>, submittedById?: Array<string>, submittedByTitle?: Array<string>, submitterComment?: Array<string>, summary?: Array<string>, uuid?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: AnalysisStepVersionResults;  }> {
        const localVarPath = this.basePath + '/analysis-step-versions/@@listing';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'frame' is not null or undefined
        if (frame === null || frame === undefined) {
            throw new Error('Required parameter frame was null or undefined when calling analysisStepVersions.');
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (frame !== undefined) {
            localVarQueryParameters['frame'] = ObjectSerializer.serialize(frame, "'object'");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "Limit");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "Array<string>");
        }

        if (id !== undefined) {
            localVarQueryParameters['@id'] = ObjectSerializer.serialize(id, "Array<string>");
        }

        if (aliases !== undefined) {
            localVarQueryParameters['aliases'] = ObjectSerializer.serialize(aliases, "Array<string>");
        }

        if (analysisStepId !== undefined) {
            localVarQueryParameters['analysis_step.@id'] = ObjectSerializer.serialize(analysisStepId, "Array<string>");
        }

        if (analysisStepName !== undefined) {
            localVarQueryParameters['analysis_step.name'] = ObjectSerializer.serialize(analysisStepName, "Array<string>");
        }

        if (awardId !== undefined) {
            localVarQueryParameters['award.@id'] = ObjectSerializer.serialize(awardId, "Array<string>");
        }

        if (awardComponent !== undefined) {
            localVarQueryParameters['award.component'] = ObjectSerializer.serialize(awardComponent, "Array<'affiliate' | 'data analysis' | 'data coordination' | 'functional characterization' | 'mapping' | 'networks' | 'predictive modeling'>");
        }

        if (creationTimestamp !== undefined) {
            localVarQueryParameters['creation_timestamp'] = ObjectSerializer.serialize(creationTimestamp, "Array<string>");
        }

        if (description !== undefined) {
            localVarQueryParameters['description'] = ObjectSerializer.serialize(description, "Array<string>");
        }

        if (labId !== undefined) {
            localVarQueryParameters['lab.@id'] = ObjectSerializer.serialize(labId, "Array<string>");
        }

        if (labTitle !== undefined) {
            localVarQueryParameters['lab.title'] = ObjectSerializer.serialize(labTitle, "Array<string>");
        }

        if (notes !== undefined) {
            localVarQueryParameters['notes'] = ObjectSerializer.serialize(notes, "Array<string>");
        }

        if (releaseTimestamp !== undefined) {
            localVarQueryParameters['release_timestamp'] = ObjectSerializer.serialize(releaseTimestamp, "Array<string>");
        }

        if (softwareVersionsId !== undefined) {
            localVarQueryParameters['software_versions.@id'] = ObjectSerializer.serialize(softwareVersionsId, "Array<string>");
        }

        if (softwareVersionsName !== undefined) {
            localVarQueryParameters['software_versions.name'] = ObjectSerializer.serialize(softwareVersionsName, "Array<string>");
        }

        if (status !== undefined) {
            localVarQueryParameters['status'] = ObjectSerializer.serialize(status, "Array<'archived' | 'deleted' | 'in progress' | 'released'>");
        }

        if (submittedById !== undefined) {
            localVarQueryParameters['submitted_by.@id'] = ObjectSerializer.serialize(submittedById, "Array<string>");
        }

        if (submittedByTitle !== undefined) {
            localVarQueryParameters['submitted_by.title'] = ObjectSerializer.serialize(submittedByTitle, "Array<string>");
        }

        if (submitterComment !== undefined) {
            localVarQueryParameters['submitter_comment'] = ObjectSerializer.serialize(submitterComment, "Array<string>");
        }

        if (summary !== undefined) {
            localVarQueryParameters['summary'] = ObjectSerializer.serialize(summary, "Array<string>");
        }

        if (uuid !== undefined) {
            localVarQueryParameters['uuid'] = ObjectSerializer.serialize(uuid, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: AnalysisStepVersionResults;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "AnalysisStepVersionResults");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Collection endpoint that accepts various query parameters to filter, sort, and paginate AnalysisStep items. Supports filtering on fields within AnalysisStep items.
     * @summary List items in the AnalysisStep collection.
     * @param frame Constant value. Do not set.
     * @param query Query string for searching.
     * @param limit Maximum number of results to return. Default is 25. Use \&#39;all\&#39; for all results.
     * @param sort Fields to sort results by. Prefix with \&#39;-\&#39; for descending order. Can be repeated for multiple sort fields. Does not work with limit&#x3D;all.
     * @param id Filter by @id
     * @param aliases Filter by aliases
     * @param analysisStepTypes Filter by analysis_step_types
     * @param awardId Filter by award.@id
     * @param awardComponent Filter by award.component
     * @param creationTimestamp Filter by creation_timestamp
     * @param description Filter by description
     * @param inputContentTypes Filter by input_content_types
     * @param labId Filter by lab.@id
     * @param labTitle Filter by lab.title
     * @param name Filter by name
     * @param notes Filter by notes
     * @param outputContentTypes Filter by output_content_types
     * @param parentsId Filter by parents.@id
     * @param parentsTitle Filter by parents.title
     * @param releaseTimestamp Filter by release_timestamp
     * @param status Filter by status
     * @param stepLabel Filter by step_label
     * @param submittedById Filter by submitted_by.@id
     * @param submittedByTitle Filter by submitted_by.title
     * @param submitterComment Filter by submitter_comment
     * @param summary Filter by summary
     * @param title Filter by title
     * @param uuid Filter by uuid
     * @param workflowId Filter by workflow.@id
     * @param workflowAccession Filter by workflow.accession
     */
    public async analysisSteps (frame: 'object', query?: string, limit?: Limit, sort?: Array<string>, id?: Array<string>, aliases?: Array<string>, analysisStepTypes?: Array<'alignment' | 'file format conversion' | 'signal generation'>, awardId?: Array<string>, awardComponent?: Array<'affiliate' | 'data analysis' | 'data coordination' | 'functional characterization' | 'mapping' | 'networks' | 'predictive modeling'>, creationTimestamp?: Array<string>, description?: Array<string>, inputContentTypes?: Array<string>, labId?: Array<string>, labTitle?: Array<string>, name?: Array<string>, notes?: Array<string>, outputContentTypes?: Array<string>, parentsId?: Array<string>, parentsTitle?: Array<string>, releaseTimestamp?: Array<string>, status?: Array<'archived' | 'deleted' | 'in progress' | 'released'>, stepLabel?: Array<string>, submittedById?: Array<string>, submittedByTitle?: Array<string>, submitterComment?: Array<string>, summary?: Array<string>, title?: Array<string>, uuid?: Array<string>, workflowId?: Array<string>, workflowAccession?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: AnalysisStepResults;  }> {
        const localVarPath = this.basePath + '/analysis-steps/@@listing';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'frame' is not null or undefined
        if (frame === null || frame === undefined) {
            throw new Error('Required parameter frame was null or undefined when calling analysisSteps.');
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (frame !== undefined) {
            localVarQueryParameters['frame'] = ObjectSerializer.serialize(frame, "'object'");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "Limit");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "Array<string>");
        }

        if (id !== undefined) {
            localVarQueryParameters['@id'] = ObjectSerializer.serialize(id, "Array<string>");
        }

        if (aliases !== undefined) {
            localVarQueryParameters['aliases'] = ObjectSerializer.serialize(aliases, "Array<string>");
        }

        if (analysisStepTypes !== undefined) {
            localVarQueryParameters['analysis_step_types'] = ObjectSerializer.serialize(analysisStepTypes, "Array<'alignment' | 'file format conversion' | 'signal generation'>");
        }

        if (awardId !== undefined) {
            localVarQueryParameters['award.@id'] = ObjectSerializer.serialize(awardId, "Array<string>");
        }

        if (awardComponent !== undefined) {
            localVarQueryParameters['award.component'] = ObjectSerializer.serialize(awardComponent, "Array<'affiliate' | 'data analysis' | 'data coordination' | 'functional characterization' | 'mapping' | 'networks' | 'predictive modeling'>");
        }

        if (creationTimestamp !== undefined) {
            localVarQueryParameters['creation_timestamp'] = ObjectSerializer.serialize(creationTimestamp, "Array<string>");
        }

        if (description !== undefined) {
            localVarQueryParameters['description'] = ObjectSerializer.serialize(description, "Array<string>");
        }

        if (inputContentTypes !== undefined) {
            localVarQueryParameters['input_content_types'] = ObjectSerializer.serialize(inputContentTypes, "Array<string>");
        }

        if (labId !== undefined) {
            localVarQueryParameters['lab.@id'] = ObjectSerializer.serialize(labId, "Array<string>");
        }

        if (labTitle !== undefined) {
            localVarQueryParameters['lab.title'] = ObjectSerializer.serialize(labTitle, "Array<string>");
        }

        if (name !== undefined) {
            localVarQueryParameters['name'] = ObjectSerializer.serialize(name, "Array<string>");
        }

        if (notes !== undefined) {
            localVarQueryParameters['notes'] = ObjectSerializer.serialize(notes, "Array<string>");
        }

        if (outputContentTypes !== undefined) {
            localVarQueryParameters['output_content_types'] = ObjectSerializer.serialize(outputContentTypes, "Array<string>");
        }

        if (parentsId !== undefined) {
            localVarQueryParameters['parents.@id'] = ObjectSerializer.serialize(parentsId, "Array<string>");
        }

        if (parentsTitle !== undefined) {
            localVarQueryParameters['parents.title'] = ObjectSerializer.serialize(parentsTitle, "Array<string>");
        }

        if (releaseTimestamp !== undefined) {
            localVarQueryParameters['release_timestamp'] = ObjectSerializer.serialize(releaseTimestamp, "Array<string>");
        }

        if (status !== undefined) {
            localVarQueryParameters['status'] = ObjectSerializer.serialize(status, "Array<'archived' | 'deleted' | 'in progress' | 'released'>");
        }

        if (stepLabel !== undefined) {
            localVarQueryParameters['step_label'] = ObjectSerializer.serialize(stepLabel, "Array<string>");
        }

        if (submittedById !== undefined) {
            localVarQueryParameters['submitted_by.@id'] = ObjectSerializer.serialize(submittedById, "Array<string>");
        }

        if (submittedByTitle !== undefined) {
            localVarQueryParameters['submitted_by.title'] = ObjectSerializer.serialize(submittedByTitle, "Array<string>");
        }

        if (submitterComment !== undefined) {
            localVarQueryParameters['submitter_comment'] = ObjectSerializer.serialize(submitterComment, "Array<string>");
        }

        if (summary !== undefined) {
            localVarQueryParameters['summary'] = ObjectSerializer.serialize(summary, "Array<string>");
        }

        if (title !== undefined) {
            localVarQueryParameters['title'] = ObjectSerializer.serialize(title, "Array<string>");
        }

        if (uuid !== undefined) {
            localVarQueryParameters['uuid'] = ObjectSerializer.serialize(uuid, "Array<string>");
        }

        if (workflowId !== undefined) {
            localVarQueryParameters['workflow.@id'] = ObjectSerializer.serialize(workflowId, "Array<string>");
        }

        if (workflowAccession !== undefined) {
            localVarQueryParameters['workflow.accession'] = ObjectSerializer.serialize(workflowAccession, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: AnalysisStepResults;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "AnalysisStepResults");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Collection endpoint that accepts various query parameters to filter, sort, and paginate AssayTerm items. Supports filtering on fields within AssayTerm items.
     * @summary List items in the AssayTerm collection.
     * @param frame Constant value. Do not set.
     * @param query Query string for searching.
     * @param limit Maximum number of results to return. Default is 25. Use \&#39;all\&#39; for all results.
     * @param sort Fields to sort results by. Prefix with \&#39;-\&#39; for descending order. Can be repeated for multiple sort fields. Does not work with limit&#x3D;all.
     * @param id Filter by @id
     * @param aliases Filter by aliases
     * @param ancestors Filter by ancestors
     * @param assaySlims Filter by assay_slims
     * @param categorySlims Filter by category_slims
     * @param creationTimestamp Filter by creation_timestamp
     * @param deprecatedNtrTerms Filter by deprecated_ntr_terms
     * @param description Filter by description
     * @param isA Filter by is_a
     * @param name Filter by name
     * @param notes Filter by notes
     * @param objectiveSlims Filter by objective_slims
     * @param ontology Filter by ontology
     * @param preferredAssayTitles Filter by preferred_assay_titles
     * @param releaseTimestamp Filter by release_timestamp
     * @param status Filter by status
     * @param submittedById Filter by submitted_by.@id
     * @param submittedByTitle Filter by submitted_by.title
     * @param submitterComment Filter by submitter_comment
     * @param summary Filter by summary
     * @param synonyms Filter by synonyms
     * @param termId Filter by term_id
     * @param termName Filter by term_name
     * @param uuid Filter by uuid
     */
    public async assayTerms (frame: 'object', query?: string, limit?: Limit, sort?: Array<string>, id?: Array<string>, aliases?: Array<string>, ancestors?: Array<string>, assaySlims?: Array<string>, categorySlims?: Array<string>, creationTimestamp?: Array<string>, deprecatedNtrTerms?: Array<string>, description?: Array<string>, isA?: Array<string>, name?: Array<string>, notes?: Array<string>, objectiveSlims?: Array<string>, ontology?: Array<string>, preferredAssayTitles?: Array<'10x multiome' | '10x multiome with MULTI-seq' | 'AAV-MPRA' | 'ATAC-seq' | 'CERES-seq' | 'Cell painting' | 'CRISPR FlowFISH' | 'DOGMA-seq' | 'Histone ChIP-seq' | 'Hi-C' | 'lentiMPRA' | 'MERFISH' | 'MIAA' | 'mN2H' | 'MPRA' | 'MPRA (scQer)' | 'MULTI-seq' | 'Parse SPLiT-seq' | 'Perturb-seq' | 'RNA-seq' | 'SGE' | 'scATAC-seq' | 'scNT-seq' | 'scNT-seq2' | 'scRNA-seq' | 'semi-qY2H' | 'SHARE-seq' | 'smFISH' | 'snATAC-seq' | 'snmC-Seq2' | 'snMCT-seq' | 'snM3C-seq' | 'snRNA-seq' | 'SUPERSTARR' | 'TAP-seq' | 'TF ChIP-seq' | 'VAMP-seq' | 'Variant FlowFISH' | 'Variant painting' | 'Y2H' | 'yN2H'>, releaseTimestamp?: Array<string>, status?: Array<'archived' | 'deleted' | 'in progress' | 'released'>, submittedById?: Array<string>, submittedByTitle?: Array<string>, submitterComment?: Array<string>, summary?: Array<string>, synonyms?: Array<string>, termId?: Array<string>, termName?: Array<string>, uuid?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: AssayTermResults;  }> {
        const localVarPath = this.basePath + '/assay-terms/@@listing';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'frame' is not null or undefined
        if (frame === null || frame === undefined) {
            throw new Error('Required parameter frame was null or undefined when calling assayTerms.');
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (frame !== undefined) {
            localVarQueryParameters['frame'] = ObjectSerializer.serialize(frame, "'object'");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "Limit");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "Array<string>");
        }

        if (id !== undefined) {
            localVarQueryParameters['@id'] = ObjectSerializer.serialize(id, "Array<string>");
        }

        if (aliases !== undefined) {
            localVarQueryParameters['aliases'] = ObjectSerializer.serialize(aliases, "Array<string>");
        }

        if (ancestors !== undefined) {
            localVarQueryParameters['ancestors'] = ObjectSerializer.serialize(ancestors, "Array<string>");
        }

        if (assaySlims !== undefined) {
            localVarQueryParameters['assay_slims'] = ObjectSerializer.serialize(assaySlims, "Array<string>");
        }

        if (categorySlims !== undefined) {
            localVarQueryParameters['category_slims'] = ObjectSerializer.serialize(categorySlims, "Array<string>");
        }

        if (creationTimestamp !== undefined) {
            localVarQueryParameters['creation_timestamp'] = ObjectSerializer.serialize(creationTimestamp, "Array<string>");
        }

        if (deprecatedNtrTerms !== undefined) {
            localVarQueryParameters['deprecated_ntr_terms'] = ObjectSerializer.serialize(deprecatedNtrTerms, "Array<string>");
        }

        if (description !== undefined) {
            localVarQueryParameters['description'] = ObjectSerializer.serialize(description, "Array<string>");
        }

        if (isA !== undefined) {
            localVarQueryParameters['is_a'] = ObjectSerializer.serialize(isA, "Array<string>");
        }

        if (name !== undefined) {
            localVarQueryParameters['name'] = ObjectSerializer.serialize(name, "Array<string>");
        }

        if (notes !== undefined) {
            localVarQueryParameters['notes'] = ObjectSerializer.serialize(notes, "Array<string>");
        }

        if (objectiveSlims !== undefined) {
            localVarQueryParameters['objective_slims'] = ObjectSerializer.serialize(objectiveSlims, "Array<string>");
        }

        if (ontology !== undefined) {
            localVarQueryParameters['ontology'] = ObjectSerializer.serialize(ontology, "Array<string>");
        }

        if (preferredAssayTitles !== undefined) {
            localVarQueryParameters['preferred_assay_titles'] = ObjectSerializer.serialize(preferredAssayTitles, "Array<'10x multiome' | '10x multiome with MULTI-seq' | 'AAV-MPRA' | 'ATAC-seq' | 'CERES-seq' | 'Cell painting' | 'CRISPR FlowFISH' | 'DOGMA-seq' | 'Histone ChIP-seq' | 'Hi-C' | 'lentiMPRA' | 'MERFISH' | 'MIAA' | 'mN2H' | 'MPRA' | 'MPRA (scQer)' | 'MULTI-seq' | 'Parse SPLiT-seq' | 'Perturb-seq' | 'RNA-seq' | 'SGE' | 'scATAC-seq' | 'scNT-seq' | 'scNT-seq2' | 'scRNA-seq' | 'semi-qY2H' | 'SHARE-seq' | 'smFISH' | 'snATAC-seq' | 'snmC-Seq2' | 'snMCT-seq' | 'snM3C-seq' | 'snRNA-seq' | 'SUPERSTARR' | 'TAP-seq' | 'TF ChIP-seq' | 'VAMP-seq' | 'Variant FlowFISH' | 'Variant painting' | 'Y2H' | 'yN2H'>");
        }

        if (releaseTimestamp !== undefined) {
            localVarQueryParameters['release_timestamp'] = ObjectSerializer.serialize(releaseTimestamp, "Array<string>");
        }

        if (status !== undefined) {
            localVarQueryParameters['status'] = ObjectSerializer.serialize(status, "Array<'archived' | 'deleted' | 'in progress' | 'released'>");
        }

        if (submittedById !== undefined) {
            localVarQueryParameters['submitted_by.@id'] = ObjectSerializer.serialize(submittedById, "Array<string>");
        }

        if (submittedByTitle !== undefined) {
            localVarQueryParameters['submitted_by.title'] = ObjectSerializer.serialize(submittedByTitle, "Array<string>");
        }

        if (submitterComment !== undefined) {
            localVarQueryParameters['submitter_comment'] = ObjectSerializer.serialize(submitterComment, "Array<string>");
        }

        if (summary !== undefined) {
            localVarQueryParameters['summary'] = ObjectSerializer.serialize(summary, "Array<string>");
        }

        if (synonyms !== undefined) {
            localVarQueryParameters['synonyms'] = ObjectSerializer.serialize(synonyms, "Array<string>");
        }

        if (termId !== undefined) {
            localVarQueryParameters['term_id'] = ObjectSerializer.serialize(termId, "Array<string>");
        }

        if (termName !== undefined) {
            localVarQueryParameters['term_name'] = ObjectSerializer.serialize(termName, "Array<string>");
        }

        if (uuid !== undefined) {
            localVarQueryParameters['uuid'] = ObjectSerializer.serialize(uuid, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: AssayTermResults;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "AssayTermResults");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Collection endpoint that accepts various query parameters to filter, sort, and paginate AuxiliarySet items. Supports filtering on fields within AuxiliarySet items.
     * @summary List items in the AuxiliarySet collection.
     * @param frame Constant value. Do not set.
     * @param query Query string for searching.
     * @param limit Maximum number of results to return. Default is 25. Use \&#39;all\&#39; for all results.
     * @param sort Fields to sort results by. Prefix with \&#39;-\&#39; for descending order. Can be repeated for multiple sort fields. Does not work with limit&#x3D;all.
     * @param id Filter by @id
     * @param accession Filter by accession
     * @param aliases Filter by aliases
     * @param alternateAccessions Filter by alternate_accessions
     * @param awardId Filter by award.@id
     * @param awardComponent Filter by award.component
     * @param awardContactPiId Filter by award.contact_pi.@id
     * @param awardContactPiTitle Filter by award.contact_pi.title
     * @param awardTitle Filter by award.title
     * @param collections Filter by collections
     * @param controlForId Filter by control_for.@id
     * @param controlForAccession Filter by control_for.accession
     * @param controlForAliases Filter by control_for.aliases
     * @param creationTimestamp Filter by creation_timestamp
     * @param dbxrefs Filter by dbxrefs
     * @param description Filter by description
     * @param documents Filter by documents
     * @param donorsId Filter by donors.@id
     * @param donorsAccession Filter by donors.accession
     * @param donorsAliases Filter by donors.aliases
     * @param donorsSex Filter by donors.sex
     * @param donorsStatus Filter by donors.status
     * @param donorsTaxa Filter by donors.taxa
     * @param fileSetType Filter by file_set_type
     * @param filesId Filter by files.@id
     * @param filesAccession Filter by files.accession
     * @param filesAliases Filter by files.aliases
     * @param filesContentType Filter by files.content_type
     * @param filesCreationTimestamp Filter by files.creation_timestamp
     * @param filesFileFormat Filter by files.file_format
     * @param filesFileSize Filter by files.file_size
     * @param filesHref Filter by files.href
     * @param filesS3Uri Filter by files.s3_uri
     * @param filesSequencingPlatform Filter by files.sequencing_platform
     * @param filesSubmittedFileName Filter by files.submitted_file_name
     * @param filesUploadStatus Filter by files.upload_status
     * @param inputFileSetFor Filter by input_file_set_for
     * @param labId Filter by lab.@id
     * @param labTitle Filter by lab.title
     * @param libraryConstructionPlatform Filter by library_construction_platform
     * @param measurementSetsId Filter by measurement_sets.@id
     * @param measurementSetsAccession Filter by measurement_sets.accession
     * @param measurementSetsAliases Filter by measurement_sets.aliases
     * @param measurementSetsPreferredAssayTitle Filter by measurement_sets.preferred_assay_title
     * @param notes Filter by notes
     * @param publicationIdentifiers Filter by publication_identifiers
     * @param publications Filter by publications
     * @param releaseTimestamp Filter by release_timestamp
     * @param revokeDetail Filter by revoke_detail
     * @param samplesId Filter by samples.@id
     * @param samplesAccession Filter by samples.accession
     * @param samplesAliases Filter by samples.aliases
     * @param samplesCellFateChangeTreatments Filter by samples.cell_fate_change_treatments
     * @param samplesClassifications Filter by samples.classifications
     * @param samplesConstructLibrarySets Filter by samples.construct_library_sets
     * @param samplesDiseaseTermsId Filter by samples.disease_terms.@id
     * @param samplesDiseaseTermsTermName Filter by samples.disease_terms.term_name
     * @param samplesModifications Filter by samples.modifications
     * @param samplesSampleTermsId Filter by samples.sample_terms.@id
     * @param samplesSampleTermsAliases Filter by samples.sample_terms.aliases
     * @param samplesSampleTermsStatus Filter by samples.sample_terms.status
     * @param samplesSampleTermsSummary Filter by samples.sample_terms.summary
     * @param samplesSampleTermsTermName Filter by samples.sample_terms.term_name
     * @param samplesStatus Filter by samples.status
     * @param samplesSummary Filter by samples.summary
     * @param samplesTargetedSampleTermId Filter by samples.targeted_sample_term.@id
     * @param samplesTargetedSampleTermTermName Filter by samples.targeted_sample_term.term_name
     * @param samplesTaxa Filter by samples.taxa
     * @param samplesTreatments Filter by samples.treatments
     * @param status Filter by status
     * @param submittedById Filter by submitted_by.@id
     * @param submittedByTitle Filter by submitted_by.title
     * @param submittedFilesTimestamp Filter by submitted_files_timestamp
     * @param submitterComment Filter by submitter_comment
     * @param summary Filter by summary
     * @param url Filter by url
     * @param uuid Filter by uuid
     */
    public async auxiliarySets (frame: 'object', query?: string, limit?: Limit, sort?: Array<string>, id?: Array<string>, accession?: Array<string>, aliases?: Array<string>, alternateAccessions?: Array<string>, awardId?: Array<string>, awardComponent?: Array<'affiliate' | 'data analysis' | 'data coordination' | 'functional characterization' | 'mapping' | 'networks' | 'predictive modeling'>, awardContactPiId?: Array<string>, awardContactPiTitle?: Array<string>, awardTitle?: Array<string>, collections?: Array<'ClinGen' | 'ENCODE' | 'GREGoR' | 'IGVF_catalog_beta_v0.1' | 'IGVF_catalog_beta_v0.2' | 'IGVF_catalog_beta_v0.3' | 'IGVF_catalog_beta_v0.4' | 'MaveDB' | 'MPRAbase' | 'Vista'>, controlForId?: Array<string>, controlForAccession?: Array<string>, controlForAliases?: Array<string>, creationTimestamp?: Array<string>, dbxrefs?: Array<string>, description?: Array<string>, documents?: Array<string>, donorsId?: Array<string>, donorsAccession?: Array<string>, donorsAliases?: Array<string>, donorsSex?: Array<'male' | 'female' | 'unspecified'>, donorsStatus?: Array<'in progress' | 'released' | 'deleted' | 'replaced' | 'revoked' | 'archived'>, donorsTaxa?: Array<string>, fileSetType?: Array<'cell hashing' | 'cell sorting' | 'circularized RNA barcode detection' | 'gRNA sequencing' | 'oligo-conjugated lipids' | 'quantification DNA barcode sequencing' | 'variant sequencing'>, filesId?: Array<string>, filesAccession?: Array<string>, filesAliases?: Array<string>, filesContentType?: Array<string>, filesCreationTimestamp?: Array<string>, filesFileFormat?: Array<string>, filesFileSize?: Array<number>, filesHref?: Array<string>, filesS3Uri?: Array<string>, filesSequencingPlatform?: Array<string>, filesSubmittedFileName?: Array<string>, filesUploadStatus?: Array<'pending' | 'file not found' | 'invalidated' | 'validated'>, inputFileSetFor?: Array<string>, labId?: Array<string>, labTitle?: Array<string>, libraryConstructionPlatform?: Array<string>, measurementSetsId?: Array<string>, measurementSetsAccession?: Array<string>, measurementSetsAliases?: Array<string>, measurementSetsPreferredAssayTitle?: Array<'10x multiome' | '10x multiome with MULTI-seq' | 'AAV-MPRA' | 'ATAC-seq' | 'CERES-seq' | 'Cell painting' | 'CRISPR FlowFISH' | 'DOGMA-seq' | 'Histone ChIP-seq' | 'Hi-C' | 'lentiMPRA' | 'MERFISH' | 'MIAA' | 'mN2H' | 'MPRA' | 'MPRA (scQer)' | 'MULTI-seq' | 'Parse SPLiT-seq' | 'Perturb-seq' | 'RNA-seq' | 'SGE' | 'scATAC-seq' | 'scNT-seq' | 'scNT-seq2' | 'scRNA-seq' | 'semi-qY2H' | 'SHARE-seq' | 'smFISH' | 'snATAC-seq' | 'snmC-Seq2' | 'snMCT-seq' | 'snM3C-seq' | 'snRNA-seq' | 'SUPERSTARR' | 'TAP-seq' | 'TF ChIP-seq' | 'VAMP-seq' | 'Variant FlowFISH' | 'Variant painting' | 'Y2H' | 'yN2H'>, notes?: Array<string>, publicationIdentifiers?: Array<string>, publications?: Array<string>, releaseTimestamp?: Array<string>, revokeDetail?: Array<string>, samplesId?: Array<string>, samplesAccession?: Array<string>, samplesAliases?: Array<string>, samplesCellFateChangeTreatments?: Array<string>, samplesClassifications?: Array<'organoid' | 'gastruloid' | 'embryoid' | 'cell line' | 'differentiated cell specimen' | 'reprogrammed cell specimen' | 'pooled cell specimen'>, samplesConstructLibrarySets?: Array<string>, samplesDiseaseTermsId?: Array<string>, samplesDiseaseTermsTermName?: Array<string>, samplesModifications?: Array<string>, samplesSampleTermsId?: Array<string>, samplesSampleTermsAliases?: Array<string>, samplesSampleTermsStatus?: Array<'archived' | 'deleted' | 'in progress' | 'released'>, samplesSampleTermsSummary?: Array<string>, samplesSampleTermsTermName?: Array<string>, samplesStatus?: Array<'in progress' | 'released' | 'deleted' | 'replaced' | 'revoked' | 'archived'>, samplesSummary?: Array<string>, samplesTargetedSampleTermId?: Array<string>, samplesTargetedSampleTermTermName?: Array<string>, samplesTaxa?: Array<'Homo sapiens' | 'Mus musculus'>, samplesTreatments?: Array<string>, status?: Array<'in progress' | 'released' | 'deleted' | 'replaced' | 'revoked' | 'archived'>, submittedById?: Array<string>, submittedByTitle?: Array<string>, submittedFilesTimestamp?: Array<string>, submitterComment?: Array<string>, summary?: Array<string>, url?: Array<string>, uuid?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: AuxiliarySetResults;  }> {
        const localVarPath = this.basePath + '/auxiliary-sets/@@listing';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'frame' is not null or undefined
        if (frame === null || frame === undefined) {
            throw new Error('Required parameter frame was null or undefined when calling auxiliarySets.');
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (frame !== undefined) {
            localVarQueryParameters['frame'] = ObjectSerializer.serialize(frame, "'object'");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "Limit");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "Array<string>");
        }

        if (id !== undefined) {
            localVarQueryParameters['@id'] = ObjectSerializer.serialize(id, "Array<string>");
        }

        if (accession !== undefined) {
            localVarQueryParameters['accession'] = ObjectSerializer.serialize(accession, "Array<string>");
        }

        if (aliases !== undefined) {
            localVarQueryParameters['aliases'] = ObjectSerializer.serialize(aliases, "Array<string>");
        }

        if (alternateAccessions !== undefined) {
            localVarQueryParameters['alternate_accessions'] = ObjectSerializer.serialize(alternateAccessions, "Array<string>");
        }

        if (awardId !== undefined) {
            localVarQueryParameters['award.@id'] = ObjectSerializer.serialize(awardId, "Array<string>");
        }

        if (awardComponent !== undefined) {
            localVarQueryParameters['award.component'] = ObjectSerializer.serialize(awardComponent, "Array<'affiliate' | 'data analysis' | 'data coordination' | 'functional characterization' | 'mapping' | 'networks' | 'predictive modeling'>");
        }

        if (awardContactPiId !== undefined) {
            localVarQueryParameters['award.contact_pi.@id'] = ObjectSerializer.serialize(awardContactPiId, "Array<string>");
        }

        if (awardContactPiTitle !== undefined) {
            localVarQueryParameters['award.contact_pi.title'] = ObjectSerializer.serialize(awardContactPiTitle, "Array<string>");
        }

        if (awardTitle !== undefined) {
            localVarQueryParameters['award.title'] = ObjectSerializer.serialize(awardTitle, "Array<string>");
        }

        if (collections !== undefined) {
            localVarQueryParameters['collections'] = ObjectSerializer.serialize(collections, "Array<'ClinGen' | 'ENCODE' | 'GREGoR' | 'IGVF_catalog_beta_v0.1' | 'IGVF_catalog_beta_v0.2' | 'IGVF_catalog_beta_v0.3' | 'IGVF_catalog_beta_v0.4' | 'MaveDB' | 'MPRAbase' | 'Vista'>");
        }

        if (controlForId !== undefined) {
            localVarQueryParameters['control_for.@id'] = ObjectSerializer.serialize(controlForId, "Array<string>");
        }

        if (controlForAccession !== undefined) {
            localVarQueryParameters['control_for.accession'] = ObjectSerializer.serialize(controlForAccession, "Array<string>");
        }

        if (controlForAliases !== undefined) {
            localVarQueryParameters['control_for.aliases'] = ObjectSerializer.serialize(controlForAliases, "Array<string>");
        }

        if (creationTimestamp !== undefined) {
            localVarQueryParameters['creation_timestamp'] = ObjectSerializer.serialize(creationTimestamp, "Array<string>");
        }

        if (dbxrefs !== undefined) {
            localVarQueryParameters['dbxrefs'] = ObjectSerializer.serialize(dbxrefs, "Array<string>");
        }

        if (description !== undefined) {
            localVarQueryParameters['description'] = ObjectSerializer.serialize(description, "Array<string>");
        }

        if (documents !== undefined) {
            localVarQueryParameters['documents'] = ObjectSerializer.serialize(documents, "Array<string>");
        }

        if (donorsId !== undefined) {
            localVarQueryParameters['donors.@id'] = ObjectSerializer.serialize(donorsId, "Array<string>");
        }

        if (donorsAccession !== undefined) {
            localVarQueryParameters['donors.accession'] = ObjectSerializer.serialize(donorsAccession, "Array<string>");
        }

        if (donorsAliases !== undefined) {
            localVarQueryParameters['donors.aliases'] = ObjectSerializer.serialize(donorsAliases, "Array<string>");
        }

        if (donorsSex !== undefined) {
            localVarQueryParameters['donors.sex'] = ObjectSerializer.serialize(donorsSex, "Array<'male' | 'female' | 'unspecified'>");
        }

        if (donorsStatus !== undefined) {
            localVarQueryParameters['donors.status'] = ObjectSerializer.serialize(donorsStatus, "Array<'in progress' | 'released' | 'deleted' | 'replaced' | 'revoked' | 'archived'>");
        }

        if (donorsTaxa !== undefined) {
            localVarQueryParameters['donors.taxa'] = ObjectSerializer.serialize(donorsTaxa, "Array<string>");
        }

        if (fileSetType !== undefined) {
            localVarQueryParameters['file_set_type'] = ObjectSerializer.serialize(fileSetType, "Array<'cell hashing' | 'cell sorting' | 'circularized RNA barcode detection' | 'gRNA sequencing' | 'oligo-conjugated lipids' | 'quantification DNA barcode sequencing' | 'variant sequencing'>");
        }

        if (filesId !== undefined) {
            localVarQueryParameters['files.@id'] = ObjectSerializer.serialize(filesId, "Array<string>");
        }

        if (filesAccession !== undefined) {
            localVarQueryParameters['files.accession'] = ObjectSerializer.serialize(filesAccession, "Array<string>");
        }

        if (filesAliases !== undefined) {
            localVarQueryParameters['files.aliases'] = ObjectSerializer.serialize(filesAliases, "Array<string>");
        }

        if (filesContentType !== undefined) {
            localVarQueryParameters['files.content_type'] = ObjectSerializer.serialize(filesContentType, "Array<string>");
        }

        if (filesCreationTimestamp !== undefined) {
            localVarQueryParameters['files.creation_timestamp'] = ObjectSerializer.serialize(filesCreationTimestamp, "Array<string>");
        }

        if (filesFileFormat !== undefined) {
            localVarQueryParameters['files.file_format'] = ObjectSerializer.serialize(filesFileFormat, "Array<string>");
        }

        if (filesFileSize !== undefined) {
            localVarQueryParameters['files.file_size'] = ObjectSerializer.serialize(filesFileSize, "Array<number>");
        }

        if (filesHref !== undefined) {
            localVarQueryParameters['files.href'] = ObjectSerializer.serialize(filesHref, "Array<string>");
        }

        if (filesS3Uri !== undefined) {
            localVarQueryParameters['files.s3_uri'] = ObjectSerializer.serialize(filesS3Uri, "Array<string>");
        }

        if (filesSequencingPlatform !== undefined) {
            localVarQueryParameters['files.sequencing_platform'] = ObjectSerializer.serialize(filesSequencingPlatform, "Array<string>");
        }

        if (filesSubmittedFileName !== undefined) {
            localVarQueryParameters['files.submitted_file_name'] = ObjectSerializer.serialize(filesSubmittedFileName, "Array<string>");
        }

        if (filesUploadStatus !== undefined) {
            localVarQueryParameters['files.upload_status'] = ObjectSerializer.serialize(filesUploadStatus, "Array<'pending' | 'file not found' | 'invalidated' | 'validated'>");
        }

        if (inputFileSetFor !== undefined) {
            localVarQueryParameters['input_file_set_for'] = ObjectSerializer.serialize(inputFileSetFor, "Array<string>");
        }

        if (labId !== undefined) {
            localVarQueryParameters['lab.@id'] = ObjectSerializer.serialize(labId, "Array<string>");
        }

        if (labTitle !== undefined) {
            localVarQueryParameters['lab.title'] = ObjectSerializer.serialize(labTitle, "Array<string>");
        }

        if (libraryConstructionPlatform !== undefined) {
            localVarQueryParameters['library_construction_platform'] = ObjectSerializer.serialize(libraryConstructionPlatform, "Array<string>");
        }

        if (measurementSetsId !== undefined) {
            localVarQueryParameters['measurement_sets.@id'] = ObjectSerializer.serialize(measurementSetsId, "Array<string>");
        }

        if (measurementSetsAccession !== undefined) {
            localVarQueryParameters['measurement_sets.accession'] = ObjectSerializer.serialize(measurementSetsAccession, "Array<string>");
        }

        if (measurementSetsAliases !== undefined) {
            localVarQueryParameters['measurement_sets.aliases'] = ObjectSerializer.serialize(measurementSetsAliases, "Array<string>");
        }

        if (measurementSetsPreferredAssayTitle !== undefined) {
            localVarQueryParameters['measurement_sets.preferred_assay_title'] = ObjectSerializer.serialize(measurementSetsPreferredAssayTitle, "Array<'10x multiome' | '10x multiome with MULTI-seq' | 'AAV-MPRA' | 'ATAC-seq' | 'CERES-seq' | 'Cell painting' | 'CRISPR FlowFISH' | 'DOGMA-seq' | 'Histone ChIP-seq' | 'Hi-C' | 'lentiMPRA' | 'MERFISH' | 'MIAA' | 'mN2H' | 'MPRA' | 'MPRA (scQer)' | 'MULTI-seq' | 'Parse SPLiT-seq' | 'Perturb-seq' | 'RNA-seq' | 'SGE' | 'scATAC-seq' | 'scNT-seq' | 'scNT-seq2' | 'scRNA-seq' | 'semi-qY2H' | 'SHARE-seq' | 'smFISH' | 'snATAC-seq' | 'snmC-Seq2' | 'snMCT-seq' | 'snM3C-seq' | 'snRNA-seq' | 'SUPERSTARR' | 'TAP-seq' | 'TF ChIP-seq' | 'VAMP-seq' | 'Variant FlowFISH' | 'Variant painting' | 'Y2H' | 'yN2H'>");
        }

        if (notes !== undefined) {
            localVarQueryParameters['notes'] = ObjectSerializer.serialize(notes, "Array<string>");
        }

        if (publicationIdentifiers !== undefined) {
            localVarQueryParameters['publication_identifiers'] = ObjectSerializer.serialize(publicationIdentifiers, "Array<string>");
        }

        if (publications !== undefined) {
            localVarQueryParameters['publications'] = ObjectSerializer.serialize(publications, "Array<string>");
        }

        if (releaseTimestamp !== undefined) {
            localVarQueryParameters['release_timestamp'] = ObjectSerializer.serialize(releaseTimestamp, "Array<string>");
        }

        if (revokeDetail !== undefined) {
            localVarQueryParameters['revoke_detail'] = ObjectSerializer.serialize(revokeDetail, "Array<string>");
        }

        if (samplesId !== undefined) {
            localVarQueryParameters['samples.@id'] = ObjectSerializer.serialize(samplesId, "Array<string>");
        }

        if (samplesAccession !== undefined) {
            localVarQueryParameters['samples.accession'] = ObjectSerializer.serialize(samplesAccession, "Array<string>");
        }

        if (samplesAliases !== undefined) {
            localVarQueryParameters['samples.aliases'] = ObjectSerializer.serialize(samplesAliases, "Array<string>");
        }

        if (samplesCellFateChangeTreatments !== undefined) {
            localVarQueryParameters['samples.cell_fate_change_treatments'] = ObjectSerializer.serialize(samplesCellFateChangeTreatments, "Array<string>");
        }

        if (samplesClassifications !== undefined) {
            localVarQueryParameters['samples.classifications'] = ObjectSerializer.serialize(samplesClassifications, "Array<'organoid' | 'gastruloid' | 'embryoid' | 'cell line' | 'differentiated cell specimen' | 'reprogrammed cell specimen' | 'pooled cell specimen'>");
        }

        if (samplesConstructLibrarySets !== undefined) {
            localVarQueryParameters['samples.construct_library_sets'] = ObjectSerializer.serialize(samplesConstructLibrarySets, "Array<string>");
        }

        if (samplesDiseaseTermsId !== undefined) {
            localVarQueryParameters['samples.disease_terms.@id'] = ObjectSerializer.serialize(samplesDiseaseTermsId, "Array<string>");
        }

        if (samplesDiseaseTermsTermName !== undefined) {
            localVarQueryParameters['samples.disease_terms.term_name'] = ObjectSerializer.serialize(samplesDiseaseTermsTermName, "Array<string>");
        }

        if (samplesModifications !== undefined) {
            localVarQueryParameters['samples.modifications'] = ObjectSerializer.serialize(samplesModifications, "Array<string>");
        }

        if (samplesSampleTermsId !== undefined) {
            localVarQueryParameters['samples.sample_terms.@id'] = ObjectSerializer.serialize(samplesSampleTermsId, "Array<string>");
        }

        if (samplesSampleTermsAliases !== undefined) {
            localVarQueryParameters['samples.sample_terms.aliases'] = ObjectSerializer.serialize(samplesSampleTermsAliases, "Array<string>");
        }

        if (samplesSampleTermsStatus !== undefined) {
            localVarQueryParameters['samples.sample_terms.status'] = ObjectSerializer.serialize(samplesSampleTermsStatus, "Array<'archived' | 'deleted' | 'in progress' | 'released'>");
        }

        if (samplesSampleTermsSummary !== undefined) {
            localVarQueryParameters['samples.sample_terms.summary'] = ObjectSerializer.serialize(samplesSampleTermsSummary, "Array<string>");
        }

        if (samplesSampleTermsTermName !== undefined) {
            localVarQueryParameters['samples.sample_terms.term_name'] = ObjectSerializer.serialize(samplesSampleTermsTermName, "Array<string>");
        }

        if (samplesStatus !== undefined) {
            localVarQueryParameters['samples.status'] = ObjectSerializer.serialize(samplesStatus, "Array<'in progress' | 'released' | 'deleted' | 'replaced' | 'revoked' | 'archived'>");
        }

        if (samplesSummary !== undefined) {
            localVarQueryParameters['samples.summary'] = ObjectSerializer.serialize(samplesSummary, "Array<string>");
        }

        if (samplesTargetedSampleTermId !== undefined) {
            localVarQueryParameters['samples.targeted_sample_term.@id'] = ObjectSerializer.serialize(samplesTargetedSampleTermId, "Array<string>");
        }

        if (samplesTargetedSampleTermTermName !== undefined) {
            localVarQueryParameters['samples.targeted_sample_term.term_name'] = ObjectSerializer.serialize(samplesTargetedSampleTermTermName, "Array<string>");
        }

        if (samplesTaxa !== undefined) {
            localVarQueryParameters['samples.taxa'] = ObjectSerializer.serialize(samplesTaxa, "Array<'Homo sapiens' | 'Mus musculus'>");
        }

        if (samplesTreatments !== undefined) {
            localVarQueryParameters['samples.treatments'] = ObjectSerializer.serialize(samplesTreatments, "Array<string>");
        }

        if (status !== undefined) {
            localVarQueryParameters['status'] = ObjectSerializer.serialize(status, "Array<'in progress' | 'released' | 'deleted' | 'replaced' | 'revoked' | 'archived'>");
        }

        if (submittedById !== undefined) {
            localVarQueryParameters['submitted_by.@id'] = ObjectSerializer.serialize(submittedById, "Array<string>");
        }

        if (submittedByTitle !== undefined) {
            localVarQueryParameters['submitted_by.title'] = ObjectSerializer.serialize(submittedByTitle, "Array<string>");
        }

        if (submittedFilesTimestamp !== undefined) {
            localVarQueryParameters['submitted_files_timestamp'] = ObjectSerializer.serialize(submittedFilesTimestamp, "Array<string>");
        }

        if (submitterComment !== undefined) {
            localVarQueryParameters['submitter_comment'] = ObjectSerializer.serialize(submitterComment, "Array<string>");
        }

        if (summary !== undefined) {
            localVarQueryParameters['summary'] = ObjectSerializer.serialize(summary, "Array<string>");
        }

        if (url !== undefined) {
            localVarQueryParameters['url'] = ObjectSerializer.serialize(url, "Array<string>");
        }

        if (uuid !== undefined) {
            localVarQueryParameters['uuid'] = ObjectSerializer.serialize(uuid, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: AuxiliarySetResults;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "AuxiliarySetResults");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Collection endpoint that accepts various query parameters to filter, sort, and paginate Award items. Supports filtering on fields within Award items.
     * @summary List items in the Award collection.
     * @param frame Constant value. Do not set.
     * @param query Query string for searching.
     * @param limit Maximum number of results to return. Default is 25. Use \&#39;all\&#39; for all results.
     * @param sort Fields to sort results by. Prefix with \&#39;-\&#39; for descending order. Can be repeated for multiple sort fields. Does not work with limit&#x3D;all.
     * @param id Filter by @id
     * @param aliases Filter by aliases
     * @param component Filter by component
     * @param contactPi Filter by contact_pi
     * @param creationTimestamp Filter by creation_timestamp
     * @param description Filter by description
     * @param endDate Filter by end_date
     * @param name Filter by name
     * @param notes Filter by notes
     * @param pis Filter by pis
     * @param project Filter by project
     * @param startDate Filter by start_date
     * @param status Filter by status
     * @param submittedById Filter by submitted_by.@id
     * @param submittedByTitle Filter by submitted_by.title
     * @param submitterComment Filter by submitter_comment
     * @param summary Filter by summary
     * @param title Filter by title
     * @param url Filter by url
     * @param uuid Filter by uuid
     * @param viewingGroup Filter by viewing_group
     */
    public async awards (frame: 'object', query?: string, limit?: Limit, sort?: Array<string>, id?: Array<string>, aliases?: Array<string>, component?: Array<'affiliate' | 'data analysis' | 'data coordination' | 'functional characterization' | 'mapping' | 'networks' | 'predictive modeling'>, contactPi?: Array<string>, creationTimestamp?: Array<string>, description?: Array<string>, endDate?: Array<string>, name?: Array<string>, notes?: Array<string>, pis?: Array<string>, project?: Array<'community' | 'ENCODE' | 'IGVF'>, startDate?: Array<string>, status?: Array<'current' | 'deleted' | 'disabled'>, submittedById?: Array<string>, submittedByTitle?: Array<string>, submitterComment?: Array<string>, summary?: Array<string>, title?: Array<string>, url?: Array<string>, uuid?: Array<string>, viewingGroup?: Array<'community' | 'IGVF'>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: AwardResults;  }> {
        const localVarPath = this.basePath + '/awards/@@listing';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'frame' is not null or undefined
        if (frame === null || frame === undefined) {
            throw new Error('Required parameter frame was null or undefined when calling awards.');
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (frame !== undefined) {
            localVarQueryParameters['frame'] = ObjectSerializer.serialize(frame, "'object'");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "Limit");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "Array<string>");
        }

        if (id !== undefined) {
            localVarQueryParameters['@id'] = ObjectSerializer.serialize(id, "Array<string>");
        }

        if (aliases !== undefined) {
            localVarQueryParameters['aliases'] = ObjectSerializer.serialize(aliases, "Array<string>");
        }

        if (component !== undefined) {
            localVarQueryParameters['component'] = ObjectSerializer.serialize(component, "Array<'affiliate' | 'data analysis' | 'data coordination' | 'functional characterization' | 'mapping' | 'networks' | 'predictive modeling'>");
        }

        if (contactPi !== undefined) {
            localVarQueryParameters['contact_pi'] = ObjectSerializer.serialize(contactPi, "Array<string>");
        }

        if (creationTimestamp !== undefined) {
            localVarQueryParameters['creation_timestamp'] = ObjectSerializer.serialize(creationTimestamp, "Array<string>");
        }

        if (description !== undefined) {
            localVarQueryParameters['description'] = ObjectSerializer.serialize(description, "Array<string>");
        }

        if (endDate !== undefined) {
            localVarQueryParameters['end_date'] = ObjectSerializer.serialize(endDate, "Array<string>");
        }

        if (name !== undefined) {
            localVarQueryParameters['name'] = ObjectSerializer.serialize(name, "Array<string>");
        }

        if (notes !== undefined) {
            localVarQueryParameters['notes'] = ObjectSerializer.serialize(notes, "Array<string>");
        }

        if (pis !== undefined) {
            localVarQueryParameters['pis'] = ObjectSerializer.serialize(pis, "Array<string>");
        }

        if (project !== undefined) {
            localVarQueryParameters['project'] = ObjectSerializer.serialize(project, "Array<'community' | 'ENCODE' | 'IGVF'>");
        }

        if (startDate !== undefined) {
            localVarQueryParameters['start_date'] = ObjectSerializer.serialize(startDate, "Array<string>");
        }

        if (status !== undefined) {
            localVarQueryParameters['status'] = ObjectSerializer.serialize(status, "Array<'current' | 'deleted' | 'disabled'>");
        }

        if (submittedById !== undefined) {
            localVarQueryParameters['submitted_by.@id'] = ObjectSerializer.serialize(submittedById, "Array<string>");
        }

        if (submittedByTitle !== undefined) {
            localVarQueryParameters['submitted_by.title'] = ObjectSerializer.serialize(submittedByTitle, "Array<string>");
        }

        if (submitterComment !== undefined) {
            localVarQueryParameters['submitter_comment'] = ObjectSerializer.serialize(submitterComment, "Array<string>");
        }

        if (summary !== undefined) {
            localVarQueryParameters['summary'] = ObjectSerializer.serialize(summary, "Array<string>");
        }

        if (title !== undefined) {
            localVarQueryParameters['title'] = ObjectSerializer.serialize(title, "Array<string>");
        }

        if (url !== undefined) {
            localVarQueryParameters['url'] = ObjectSerializer.serialize(url, "Array<string>");
        }

        if (uuid !== undefined) {
            localVarQueryParameters['uuid'] = ObjectSerializer.serialize(uuid, "Array<string>");
        }

        if (viewingGroup !== undefined) {
            localVarQueryParameters['viewing_group'] = ObjectSerializer.serialize(viewingGroup, "Array<'community' | 'IGVF'>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: AwardResults;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "AwardResults");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Generates TSV of files contained in FileSets in search results.
     * @summary List files to download based on search query. All results are returned.
     * @param type Type of objects to return. Can be repeated for multiple types.
     * @param query Query string for searching.
     * @param fieldFilters Any field from any object type can be used as a filter. Use \&#39;!\&#39; for negation, \&#39;*\&#39; as a wildcard, and \&#39;lt:\&#39;, \&#39;lte:\&#39;, \&#39;gt:\&#39;, \&#39;gte:\&#39; for range queries on numeric fields.
     */
    public async batchDownload (type: Array<string>, query?: string, fieldFilters?: object, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: string;  }> {
        const localVarPath = this.basePath + '/batch-download';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['text/tab-separated-values', 'application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'type' is not null or undefined
        if (type === null || type === undefined) {
            throw new Error('Required parameter type was null or undefined when calling batchDownload.');
        }

        if (type !== undefined) {
            localVarQueryParameters['type'] = ObjectSerializer.serialize(type, "Array<string>");
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (fieldFilters !== undefined) {
            localVarQueryParameters['field_filters'] = ObjectSerializer.serialize(fieldFilters, "object");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: string;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "string");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Collection endpoint that accepts various query parameters to filter, sort, and paginate Biomarker items. Supports filtering on fields within Biomarker items.
     * @summary List items in the Biomarker collection.
     * @param frame Constant value. Do not set.
     * @param query Query string for searching.
     * @param limit Maximum number of results to return. Default is 25. Use \&#39;all\&#39; for all results.
     * @param sort Fields to sort results by. Prefix with \&#39;-\&#39; for descending order. Can be repeated for multiple sort fields. Does not work with limit&#x3D;all.
     * @param id Filter by @id
     * @param aliases Filter by aliases
     * @param awardId Filter by award.@id
     * @param awardComponent Filter by award.component
     * @param awardName Filter by award.name
     * @param biomarkerFor Filter by biomarker_for
     * @param classification Filter by classification
     * @param creationTimestamp Filter by creation_timestamp
     * @param description Filter by description
     * @param gene Filter by gene
     * @param labId Filter by lab.@id
     * @param labTitle Filter by lab.title
     * @param name Filter by name
     * @param nameQuantification Filter by name_quantification
     * @param notes Filter by notes
     * @param quantification Filter by quantification
     * @param releaseTimestamp Filter by release_timestamp
     * @param status Filter by status
     * @param submittedById Filter by submitted_by.@id
     * @param submittedByTitle Filter by submitted_by.title
     * @param submitterComment Filter by submitter_comment
     * @param summary Filter by summary
     * @param synonyms Filter by synonyms
     * @param uuid Filter by uuid
     */
    public async biomarkers (frame: 'object', query?: string, limit?: Limit, sort?: Array<string>, id?: Array<string>, aliases?: Array<string>, awardId?: Array<string>, awardComponent?: Array<'affiliate' | 'data analysis' | 'data coordination' | 'functional characterization' | 'mapping' | 'networks' | 'predictive modeling'>, awardName?: Array<string>, biomarkerFor?: Array<string>, classification?: Array<'cell surface protein' | 'marker gene'>, creationTimestamp?: Array<string>, description?: Array<string>, gene?: Array<string>, labId?: Array<string>, labTitle?: Array<string>, name?: Array<string>, nameQuantification?: Array<string>, notes?: Array<string>, quantification?: Array<'negative' | 'positive' | 'low' | 'intermediate' | 'high'>, releaseTimestamp?: Array<string>, status?: Array<'archived' | 'deleted' | 'in progress' | 'released'>, submittedById?: Array<string>, submittedByTitle?: Array<string>, submitterComment?: Array<string>, summary?: Array<string>, synonyms?: Array<string>, uuid?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: BiomarkerResults;  }> {
        const localVarPath = this.basePath + '/biomarkers/@@listing';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'frame' is not null or undefined
        if (frame === null || frame === undefined) {
            throw new Error('Required parameter frame was null or undefined when calling biomarkers.');
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (frame !== undefined) {
            localVarQueryParameters['frame'] = ObjectSerializer.serialize(frame, "'object'");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "Limit");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "Array<string>");
        }

        if (id !== undefined) {
            localVarQueryParameters['@id'] = ObjectSerializer.serialize(id, "Array<string>");
        }

        if (aliases !== undefined) {
            localVarQueryParameters['aliases'] = ObjectSerializer.serialize(aliases, "Array<string>");
        }

        if (awardId !== undefined) {
            localVarQueryParameters['award.@id'] = ObjectSerializer.serialize(awardId, "Array<string>");
        }

        if (awardComponent !== undefined) {
            localVarQueryParameters['award.component'] = ObjectSerializer.serialize(awardComponent, "Array<'affiliate' | 'data analysis' | 'data coordination' | 'functional characterization' | 'mapping' | 'networks' | 'predictive modeling'>");
        }

        if (awardName !== undefined) {
            localVarQueryParameters['award.name'] = ObjectSerializer.serialize(awardName, "Array<string>");
        }

        if (biomarkerFor !== undefined) {
            localVarQueryParameters['biomarker_for'] = ObjectSerializer.serialize(biomarkerFor, "Array<string>");
        }

        if (classification !== undefined) {
            localVarQueryParameters['classification'] = ObjectSerializer.serialize(classification, "Array<'cell surface protein' | 'marker gene'>");
        }

        if (creationTimestamp !== undefined) {
            localVarQueryParameters['creation_timestamp'] = ObjectSerializer.serialize(creationTimestamp, "Array<string>");
        }

        if (description !== undefined) {
            localVarQueryParameters['description'] = ObjectSerializer.serialize(description, "Array<string>");
        }

        if (gene !== undefined) {
            localVarQueryParameters['gene'] = ObjectSerializer.serialize(gene, "Array<string>");
        }

        if (labId !== undefined) {
            localVarQueryParameters['lab.@id'] = ObjectSerializer.serialize(labId, "Array<string>");
        }

        if (labTitle !== undefined) {
            localVarQueryParameters['lab.title'] = ObjectSerializer.serialize(labTitle, "Array<string>");
        }

        if (name !== undefined) {
            localVarQueryParameters['name'] = ObjectSerializer.serialize(name, "Array<string>");
        }

        if (nameQuantification !== undefined) {
            localVarQueryParameters['name_quantification'] = ObjectSerializer.serialize(nameQuantification, "Array<string>");
        }

        if (notes !== undefined) {
            localVarQueryParameters['notes'] = ObjectSerializer.serialize(notes, "Array<string>");
        }

        if (quantification !== undefined) {
            localVarQueryParameters['quantification'] = ObjectSerializer.serialize(quantification, "Array<'negative' | 'positive' | 'low' | 'intermediate' | 'high'>");
        }

        if (releaseTimestamp !== undefined) {
            localVarQueryParameters['release_timestamp'] = ObjectSerializer.serialize(releaseTimestamp, "Array<string>");
        }

        if (status !== undefined) {
            localVarQueryParameters['status'] = ObjectSerializer.serialize(status, "Array<'archived' | 'deleted' | 'in progress' | 'released'>");
        }

        if (submittedById !== undefined) {
            localVarQueryParameters['submitted_by.@id'] = ObjectSerializer.serialize(submittedById, "Array<string>");
        }

        if (submittedByTitle !== undefined) {
            localVarQueryParameters['submitted_by.title'] = ObjectSerializer.serialize(submittedByTitle, "Array<string>");
        }

        if (submitterComment !== undefined) {
            localVarQueryParameters['submitter_comment'] = ObjectSerializer.serialize(submitterComment, "Array<string>");
        }

        if (summary !== undefined) {
            localVarQueryParameters['summary'] = ObjectSerializer.serialize(summary, "Array<string>");
        }

        if (synonyms !== undefined) {
            localVarQueryParameters['synonyms'] = ObjectSerializer.serialize(synonyms, "Array<string>");
        }

        if (uuid !== undefined) {
            localVarQueryParameters['uuid'] = ObjectSerializer.serialize(uuid, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: BiomarkerResults;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "BiomarkerResults");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Collection endpoint that accepts various query parameters to filter, sort, and paginate ConfigurationFile items. Supports filtering on fields within ConfigurationFile items.
     * @summary List items in the ConfigurationFile collection.
     * @param frame Constant value. Do not set.
     * @param query Query string for searching.
     * @param limit Maximum number of results to return. Default is 25. Use \&#39;all\&#39; for all results.
     * @param sort Fields to sort results by. Prefix with \&#39;-\&#39; for descending order. Can be repeated for multiple sort fields. Does not work with limit&#x3D;all.
     * @param id Filter by @id
     * @param accession Filter by accession
     * @param aliases Filter by aliases
     * @param alternateAccessions Filter by alternate_accessions
     * @param analysisStepVersion Filter by analysis_step_version
     * @param awardId Filter by award.@id
     * @param awardComponent Filter by award.component
     * @param collections Filter by collections
     * @param contentMd5sum Filter by content_md5sum
     * @param contentType Filter by content_type
     * @param creationTimestamp Filter by creation_timestamp
     * @param dbxrefs Filter by dbxrefs
     * @param derivedFrom Filter by derived_from
     * @param description Filter by description
     * @param documents Filter by documents
     * @param fileFormat Filter by file_format
     * @param fileFormatSpecifications Filter by file_format_specifications
     * @param fileSet Filter by file_set
     * @param fileSize Filter by file_size
     * @param geneListFor Filter by gene_list_for
     * @param href Filter by href
     * @param inputFileFor Filter by input_file_for
     * @param integratedIn Filter by integrated_in
     * @param labId Filter by lab.@id
     * @param labTitle Filter by lab.title
     * @param lociListFor Filter by loci_list_for
     * @param md5sum Filter by md5sum
     * @param notes Filter by notes
     * @param releaseTimestamp Filter by release_timestamp
     * @param revokeDetail Filter by revoke_detail
     * @param s3Uri Filter by s3_uri
     * @param seqspecOf Filter by seqspec_of
     * @param status Filter by status
     * @param submittedById Filter by submitted_by.@id
     * @param submittedByTitle Filter by submitted_by.title
     * @param submittedFileName Filter by submitted_file_name
     * @param submitterComment Filter by submitter_comment
     * @param summary Filter by summary
     * @param uploadStatus Filter by upload_status
     * @param uuid Filter by uuid
     * @param validationErrorDetail Filter by validation_error_detail
     */
    public async configurationFiles (frame: 'object', query?: string, limit?: Limit, sort?: Array<string>, id?: Array<string>, accession?: Array<string>, aliases?: Array<string>, alternateAccessions?: Array<string>, analysisStepVersion?: Array<string>, awardId?: Array<string>, awardComponent?: Array<'affiliate' | 'data analysis' | 'data coordination' | 'functional characterization' | 'mapping' | 'networks' | 'predictive modeling'>, collections?: Array<'ClinGen' | 'ENCODE' | 'GREGoR' | 'IGVF_catalog_beta_v0.1' | 'IGVF_catalog_beta_v0.2' | 'IGVF_catalog_beta_v0.3' | 'IGVF_catalog_beta_v0.4' | 'MaveDB' | 'MPRAbase' | 'Vista'>, contentMd5sum?: Array<string>, contentType?: Array<string>, creationTimestamp?: Array<string>, dbxrefs?: Array<string>, derivedFrom?: Array<string>, description?: Array<string>, documents?: Array<string>, fileFormat?: Array<'yaml'>, fileFormatSpecifications?: Array<string>, fileSet?: Array<string>, fileSize?: Array<number>, geneListFor?: Array<string>, href?: Array<string>, inputFileFor?: Array<string>, integratedIn?: Array<string>, labId?: Array<string>, labTitle?: Array<string>, lociListFor?: Array<string>, md5sum?: Array<string>, notes?: Array<string>, releaseTimestamp?: Array<string>, revokeDetail?: Array<string>, s3Uri?: Array<string>, seqspecOf?: Array<string>, status?: Array<'in progress' | 'released' | 'deleted' | 'replaced' | 'revoked' | 'archived'>, submittedById?: Array<string>, submittedByTitle?: Array<string>, submittedFileName?: Array<string>, submitterComment?: Array<string>, summary?: Array<string>, uploadStatus?: Array<'pending' | 'file not found' | 'invalidated' | 'validated'>, uuid?: Array<string>, validationErrorDetail?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: ConfigurationFileResults;  }> {
        const localVarPath = this.basePath + '/configuration-files/@@listing';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'frame' is not null or undefined
        if (frame === null || frame === undefined) {
            throw new Error('Required parameter frame was null or undefined when calling configurationFiles.');
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (frame !== undefined) {
            localVarQueryParameters['frame'] = ObjectSerializer.serialize(frame, "'object'");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "Limit");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "Array<string>");
        }

        if (id !== undefined) {
            localVarQueryParameters['@id'] = ObjectSerializer.serialize(id, "Array<string>");
        }

        if (accession !== undefined) {
            localVarQueryParameters['accession'] = ObjectSerializer.serialize(accession, "Array<string>");
        }

        if (aliases !== undefined) {
            localVarQueryParameters['aliases'] = ObjectSerializer.serialize(aliases, "Array<string>");
        }

        if (alternateAccessions !== undefined) {
            localVarQueryParameters['alternate_accessions'] = ObjectSerializer.serialize(alternateAccessions, "Array<string>");
        }

        if (analysisStepVersion !== undefined) {
            localVarQueryParameters['analysis_step_version'] = ObjectSerializer.serialize(analysisStepVersion, "Array<string>");
        }

        if (awardId !== undefined) {
            localVarQueryParameters['award.@id'] = ObjectSerializer.serialize(awardId, "Array<string>");
        }

        if (awardComponent !== undefined) {
            localVarQueryParameters['award.component'] = ObjectSerializer.serialize(awardComponent, "Array<'affiliate' | 'data analysis' | 'data coordination' | 'functional characterization' | 'mapping' | 'networks' | 'predictive modeling'>");
        }

        if (collections !== undefined) {
            localVarQueryParameters['collections'] = ObjectSerializer.serialize(collections, "Array<'ClinGen' | 'ENCODE' | 'GREGoR' | 'IGVF_catalog_beta_v0.1' | 'IGVF_catalog_beta_v0.2' | 'IGVF_catalog_beta_v0.3' | 'IGVF_catalog_beta_v0.4' | 'MaveDB' | 'MPRAbase' | 'Vista'>");
        }

        if (contentMd5sum !== undefined) {
            localVarQueryParameters['content_md5sum'] = ObjectSerializer.serialize(contentMd5sum, "Array<string>");
        }

        if (contentType !== undefined) {
            localVarQueryParameters['content_type'] = ObjectSerializer.serialize(contentType, "Array<string>");
        }

        if (creationTimestamp !== undefined) {
            localVarQueryParameters['creation_timestamp'] = ObjectSerializer.serialize(creationTimestamp, "Array<string>");
        }

        if (dbxrefs !== undefined) {
            localVarQueryParameters['dbxrefs'] = ObjectSerializer.serialize(dbxrefs, "Array<string>");
        }

        if (derivedFrom !== undefined) {
            localVarQueryParameters['derived_from'] = ObjectSerializer.serialize(derivedFrom, "Array<string>");
        }

        if (description !== undefined) {
            localVarQueryParameters['description'] = ObjectSerializer.serialize(description, "Array<string>");
        }

        if (documents !== undefined) {
            localVarQueryParameters['documents'] = ObjectSerializer.serialize(documents, "Array<string>");
        }

        if (fileFormat !== undefined) {
            localVarQueryParameters['file_format'] = ObjectSerializer.serialize(fileFormat, "Array<'yaml'>");
        }

        if (fileFormatSpecifications !== undefined) {
            localVarQueryParameters['file_format_specifications'] = ObjectSerializer.serialize(fileFormatSpecifications, "Array<string>");
        }

        if (fileSet !== undefined) {
            localVarQueryParameters['file_set'] = ObjectSerializer.serialize(fileSet, "Array<string>");
        }

        if (fileSize !== undefined) {
            localVarQueryParameters['file_size'] = ObjectSerializer.serialize(fileSize, "Array<number>");
        }

        if (geneListFor !== undefined) {
            localVarQueryParameters['gene_list_for'] = ObjectSerializer.serialize(geneListFor, "Array<string>");
        }

        if (href !== undefined) {
            localVarQueryParameters['href'] = ObjectSerializer.serialize(href, "Array<string>");
        }

        if (inputFileFor !== undefined) {
            localVarQueryParameters['input_file_for'] = ObjectSerializer.serialize(inputFileFor, "Array<string>");
        }

        if (integratedIn !== undefined) {
            localVarQueryParameters['integrated_in'] = ObjectSerializer.serialize(integratedIn, "Array<string>");
        }

        if (labId !== undefined) {
            localVarQueryParameters['lab.@id'] = ObjectSerializer.serialize(labId, "Array<string>");
        }

        if (labTitle !== undefined) {
            localVarQueryParameters['lab.title'] = ObjectSerializer.serialize(labTitle, "Array<string>");
        }

        if (lociListFor !== undefined) {
            localVarQueryParameters['loci_list_for'] = ObjectSerializer.serialize(lociListFor, "Array<string>");
        }

        if (md5sum !== undefined) {
            localVarQueryParameters['md5sum'] = ObjectSerializer.serialize(md5sum, "Array<string>");
        }

        if (notes !== undefined) {
            localVarQueryParameters['notes'] = ObjectSerializer.serialize(notes, "Array<string>");
        }

        if (releaseTimestamp !== undefined) {
            localVarQueryParameters['release_timestamp'] = ObjectSerializer.serialize(releaseTimestamp, "Array<string>");
        }

        if (revokeDetail !== undefined) {
            localVarQueryParameters['revoke_detail'] = ObjectSerializer.serialize(revokeDetail, "Array<string>");
        }

        if (s3Uri !== undefined) {
            localVarQueryParameters['s3_uri'] = ObjectSerializer.serialize(s3Uri, "Array<string>");
        }

        if (seqspecOf !== undefined) {
            localVarQueryParameters['seqspec_of'] = ObjectSerializer.serialize(seqspecOf, "Array<string>");
        }

        if (status !== undefined) {
            localVarQueryParameters['status'] = ObjectSerializer.serialize(status, "Array<'in progress' | 'released' | 'deleted' | 'replaced' | 'revoked' | 'archived'>");
        }

        if (submittedById !== undefined) {
            localVarQueryParameters['submitted_by.@id'] = ObjectSerializer.serialize(submittedById, "Array<string>");
        }

        if (submittedByTitle !== undefined) {
            localVarQueryParameters['submitted_by.title'] = ObjectSerializer.serialize(submittedByTitle, "Array<string>");
        }

        if (submittedFileName !== undefined) {
            localVarQueryParameters['submitted_file_name'] = ObjectSerializer.serialize(submittedFileName, "Array<string>");
        }

        if (submitterComment !== undefined) {
            localVarQueryParameters['submitter_comment'] = ObjectSerializer.serialize(submitterComment, "Array<string>");
        }

        if (summary !== undefined) {
            localVarQueryParameters['summary'] = ObjectSerializer.serialize(summary, "Array<string>");
        }

        if (uploadStatus !== undefined) {
            localVarQueryParameters['upload_status'] = ObjectSerializer.serialize(uploadStatus, "Array<'pending' | 'file not found' | 'invalidated' | 'validated'>");
        }

        if (uuid !== undefined) {
            localVarQueryParameters['uuid'] = ObjectSerializer.serialize(uuid, "Array<string>");
        }

        if (validationErrorDetail !== undefined) {
            localVarQueryParameters['validation_error_detail'] = ObjectSerializer.serialize(validationErrorDetail, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: ConfigurationFileResults;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "ConfigurationFileResults");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Collection endpoint that accepts various query parameters to filter, sort, and paginate ConstructLibrarySet items. Supports filtering on fields within ConstructLibrarySet items.
     * @summary List items in the ConstructLibrarySet collection.
     * @param frame Constant value. Do not set.
     * @param query Query string for searching.
     * @param limit Maximum number of results to return. Default is 25. Use \&#39;all\&#39; for all results.
     * @param sort Fields to sort results by. Prefix with \&#39;-\&#39; for descending order. Can be repeated for multiple sort fields. Does not work with limit&#x3D;all.
     * @param id Filter by @id
     * @param accession Filter by accession
     * @param aliases Filter by aliases
     * @param alternateAccessions Filter by alternate_accessions
     * @param appliedToSamplesId Filter by applied_to_samples.@id
     * @param appliedToSamplesAccession Filter by applied_to_samples.accession
     * @param appliedToSamplesAliases Filter by applied_to_samples.aliases
     * @param appliedToSamplesDiseaseTermsId Filter by applied_to_samples.disease_terms.@id
     * @param appliedToSamplesDiseaseTermsTermName Filter by applied_to_samples.disease_terms.term_name
     * @param appliedToSamplesSampleTermsId Filter by applied_to_samples.sample_terms.@id
     * @param appliedToSamplesSampleTermsTermName Filter by applied_to_samples.sample_terms.term_name
     * @param appliedToSamplesStatus Filter by applied_to_samples.status
     * @param appliedToSamplesSummary Filter by applied_to_samples.summary
     * @param associatedPhenotypesId Filter by associated_phenotypes.@id
     * @param associatedPhenotypesTermId Filter by associated_phenotypes.term_id
     * @param associatedPhenotypesTermName Filter by associated_phenotypes.term_name
     * @param averageGuideCoverage Filter by average_guide_coverage
     * @param averageInsertSize Filter by average_insert_size
     * @param awardId Filter by award.@id
     * @param awardComponent Filter by award.component
     * @param collections Filter by collections
     * @param controlForId Filter by control_for.@id
     * @param controlForAccession Filter by control_for.accession
     * @param controlForAliases Filter by control_for.aliases
     * @param creationTimestamp Filter by creation_timestamp
     * @param description Filter by description
     * @param documents Filter by documents
     * @param exon Filter by exon
     * @param fileSetType Filter by file_set_type
     * @param filesId Filter by files.@id
     * @param filesAccession Filter by files.accession
     * @param filesAliases Filter by files.aliases
     * @param filesContentType Filter by files.content_type
     * @param filesFileFormat Filter by files.file_format
     * @param filesUploadStatus Filter by files.upload_status
     * @param guideType Filter by guide_type
     * @param inputFileSetFor Filter by input_file_set_for
     * @param integratedContentFiles Filter by integrated_content_files
     * @param labId Filter by lab.@id
     * @param labTitle Filter by lab.title
     * @param largeScaleGeneListId Filter by large_scale_gene_list.@id
     * @param largeScaleGeneListAccession Filter by large_scale_gene_list.accession
     * @param largeScaleGeneListAliases Filter by large_scale_gene_list.aliases
     * @param largeScaleLociListId Filter by large_scale_loci_list.@id
     * @param largeScaleLociListAccession Filter by large_scale_loci_list.accession
     * @param largeScaleLociListAliases Filter by large_scale_loci_list.aliases
     * @param lotId Filter by lot_id
     * @param lowerBoundGuideCoverage Filter by lower_bound_guide_coverage
     * @param lowerBoundInsertSize Filter by lower_bound_insert_size
     * @param notes Filter by notes
     * @param orfListId Filter by orf_list.@id
     * @param orfListAliases Filter by orf_list.aliases
     * @param orfListGene Filter by orf_list.gene
     * @param orfListOrfId Filter by orf_list.orf_id
     * @param productId Filter by product_id
     * @param publicationIdentifiers Filter by publication_identifiers
     * @param publications Filter by publications
     * @param releaseTimestamp Filter by release_timestamp
     * @param revokeDetail Filter by revoke_detail
     * @param scope Filter by scope
     * @param selectionCriteria Filter by selection_criteria
     * @param smallScaleGeneListId Filter by small_scale_gene_list.@id
     * @param smallScaleGeneListGeneid Filter by small_scale_gene_list.geneid
     * @param smallScaleGeneListName Filter by small_scale_gene_list.name
     * @param smallScaleGeneListSymbol Filter by small_scale_gene_list.symbol
     * @param smallScaleGeneListSynonyms Filter by small_scale_gene_list.synonyms
     * @param smallScaleLociList Filter by small_scale_loci_list
     * @param sources Filter by sources
     * @param status Filter by status
     * @param submittedById Filter by submitted_by.@id
     * @param submittedByTitle Filter by submitted_by.title
     * @param submittedFilesTimestamp Filter by submitted_files_timestamp
     * @param submitterComment Filter by submitter_comment
     * @param summary Filter by summary
     * @param targeton Filter by targeton
     * @param tilingModality Filter by tiling_modality
     * @param upperBoundGuideCoverage Filter by upper_bound_guide_coverage
     * @param upperBoundInsertSize Filter by upper_bound_insert_size
     * @param uuid Filter by uuid
     */
    public async constructLibrarySets (frame: 'object', query?: string, limit?: Limit, sort?: Array<string>, id?: Array<string>, accession?: Array<string>, aliases?: Array<string>, alternateAccessions?: Array<string>, appliedToSamplesId?: Array<string>, appliedToSamplesAccession?: Array<string>, appliedToSamplesAliases?: Array<string>, appliedToSamplesDiseaseTermsId?: Array<string>, appliedToSamplesDiseaseTermsTermName?: Array<string>, appliedToSamplesSampleTermsId?: Array<string>, appliedToSamplesSampleTermsTermName?: Array<string>, appliedToSamplesStatus?: Array<'in progress' | 'released' | 'deleted' | 'replaced' | 'revoked' | 'archived'>, appliedToSamplesSummary?: Array<string>, associatedPhenotypesId?: Array<string>, associatedPhenotypesTermId?: Array<string>, associatedPhenotypesTermName?: Array<string>, averageGuideCoverage?: Array<number>, averageInsertSize?: Array<number>, awardId?: Array<string>, awardComponent?: Array<'affiliate' | 'data analysis' | 'data coordination' | 'functional characterization' | 'mapping' | 'networks' | 'predictive modeling'>, collections?: Array<'ClinGen' | 'ENCODE' | 'GREGoR' | 'IGVF_catalog_beta_v0.1' | 'IGVF_catalog_beta_v0.2' | 'IGVF_catalog_beta_v0.3' | 'IGVF_catalog_beta_v0.4' | 'MaveDB' | 'MPRAbase' | 'Vista'>, controlForId?: Array<string>, controlForAccession?: Array<string>, controlForAliases?: Array<string>, creationTimestamp?: Array<string>, description?: Array<string>, documents?: Array<string>, exon?: Array<string>, fileSetType?: Array<'guide library' | 'reporter library' | 'expression vector library' | 'editing template library'>, filesId?: Array<string>, filesAccession?: Array<string>, filesAliases?: Array<string>, filesContentType?: Array<string>, filesFileFormat?: Array<string>, filesUploadStatus?: Array<'pending' | 'file not found' | 'invalidated' | 'validated'>, guideType?: Array<'sgRNA' | 'pgRNA'>, inputFileSetFor?: Array<string>, integratedContentFiles?: Array<string>, labId?: Array<string>, labTitle?: Array<string>, largeScaleGeneListId?: Array<string>, largeScaleGeneListAccession?: Array<string>, largeScaleGeneListAliases?: Array<string>, largeScaleLociListId?: Array<string>, largeScaleLociListAccession?: Array<string>, largeScaleLociListAliases?: Array<string>, lotId?: Array<string>, lowerBoundGuideCoverage?: Array<number>, lowerBoundInsertSize?: Array<number>, notes?: Array<string>, orfListId?: Array<string>, orfListAliases?: Array<string>, orfListGene?: Array<string>, orfListOrfId?: Array<string>, productId?: Array<string>, publicationIdentifiers?: Array<string>, publications?: Array<string>, releaseTimestamp?: Array<string>, revokeDetail?: Array<string>, scope?: Array<'tile' | 'exon' | 'genes' | 'loci' | 'genome-wide' | 'interactors' | 'alleles' | 'targeton'>, selectionCriteria?: Array<'accessible genome regions' | 'candidate cis-regulatory elements' | 'chromatin states' | 'phenotype-associated variants' | 'DNase hypersensitive sites' | 'genes' | 'histone modifications' | 'protein interactors' | 'sequence variants' | 'synthetic elements' | 'transcription start sites' | 'TF binding sites'>, smallScaleGeneListId?: Array<string>, smallScaleGeneListGeneid?: Array<string>, smallScaleGeneListName?: Array<string>, smallScaleGeneListSymbol?: Array<string>, smallScaleGeneListSynonyms?: Array<string>, smallScaleLociList?: Array<Locus>, sources?: Array<string>, status?: Array<'in progress' | 'released' | 'deleted' | 'replaced' | 'revoked' | 'archived'>, submittedById?: Array<string>, submittedByTitle?: Array<string>, submittedFilesTimestamp?: Array<string>, submitterComment?: Array<string>, summary?: Array<string>, targeton?: Array<string>, tilingModality?: Array<'peak tiling' | 'full tiling' | 'sparse peaks'>, upperBoundGuideCoverage?: Array<number>, upperBoundInsertSize?: Array<number>, uuid?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: ConstructLibrarySetResults;  }> {
        const localVarPath = this.basePath + '/construct-library-sets/@@listing';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'frame' is not null or undefined
        if (frame === null || frame === undefined) {
            throw new Error('Required parameter frame was null or undefined when calling constructLibrarySets.');
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (frame !== undefined) {
            localVarQueryParameters['frame'] = ObjectSerializer.serialize(frame, "'object'");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "Limit");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "Array<string>");
        }

        if (id !== undefined) {
            localVarQueryParameters['@id'] = ObjectSerializer.serialize(id, "Array<string>");
        }

        if (accession !== undefined) {
            localVarQueryParameters['accession'] = ObjectSerializer.serialize(accession, "Array<string>");
        }

        if (aliases !== undefined) {
            localVarQueryParameters['aliases'] = ObjectSerializer.serialize(aliases, "Array<string>");
        }

        if (alternateAccessions !== undefined) {
            localVarQueryParameters['alternate_accessions'] = ObjectSerializer.serialize(alternateAccessions, "Array<string>");
        }

        if (appliedToSamplesId !== undefined) {
            localVarQueryParameters['applied_to_samples.@id'] = ObjectSerializer.serialize(appliedToSamplesId, "Array<string>");
        }

        if (appliedToSamplesAccession !== undefined) {
            localVarQueryParameters['applied_to_samples.accession'] = ObjectSerializer.serialize(appliedToSamplesAccession, "Array<string>");
        }

        if (appliedToSamplesAliases !== undefined) {
            localVarQueryParameters['applied_to_samples.aliases'] = ObjectSerializer.serialize(appliedToSamplesAliases, "Array<string>");
        }

        if (appliedToSamplesDiseaseTermsId !== undefined) {
            localVarQueryParameters['applied_to_samples.disease_terms.@id'] = ObjectSerializer.serialize(appliedToSamplesDiseaseTermsId, "Array<string>");
        }

        if (appliedToSamplesDiseaseTermsTermName !== undefined) {
            localVarQueryParameters['applied_to_samples.disease_terms.term_name'] = ObjectSerializer.serialize(appliedToSamplesDiseaseTermsTermName, "Array<string>");
        }

        if (appliedToSamplesSampleTermsId !== undefined) {
            localVarQueryParameters['applied_to_samples.sample_terms.@id'] = ObjectSerializer.serialize(appliedToSamplesSampleTermsId, "Array<string>");
        }

        if (appliedToSamplesSampleTermsTermName !== undefined) {
            localVarQueryParameters['applied_to_samples.sample_terms.term_name'] = ObjectSerializer.serialize(appliedToSamplesSampleTermsTermName, "Array<string>");
        }

        if (appliedToSamplesStatus !== undefined) {
            localVarQueryParameters['applied_to_samples.status'] = ObjectSerializer.serialize(appliedToSamplesStatus, "Array<'in progress' | 'released' | 'deleted' | 'replaced' | 'revoked' | 'archived'>");
        }

        if (appliedToSamplesSummary !== undefined) {
            localVarQueryParameters['applied_to_samples.summary'] = ObjectSerializer.serialize(appliedToSamplesSummary, "Array<string>");
        }

        if (associatedPhenotypesId !== undefined) {
            localVarQueryParameters['associated_phenotypes.@id'] = ObjectSerializer.serialize(associatedPhenotypesId, "Array<string>");
        }

        if (associatedPhenotypesTermId !== undefined) {
            localVarQueryParameters['associated_phenotypes.term_id'] = ObjectSerializer.serialize(associatedPhenotypesTermId, "Array<string>");
        }

        if (associatedPhenotypesTermName !== undefined) {
            localVarQueryParameters['associated_phenotypes.term_name'] = ObjectSerializer.serialize(associatedPhenotypesTermName, "Array<string>");
        }

        if (averageGuideCoverage !== undefined) {
            localVarQueryParameters['average_guide_coverage'] = ObjectSerializer.serialize(averageGuideCoverage, "Array<number>");
        }

        if (averageInsertSize !== undefined) {
            localVarQueryParameters['average_insert_size'] = ObjectSerializer.serialize(averageInsertSize, "Array<number>");
        }

        if (awardId !== undefined) {
            localVarQueryParameters['award.@id'] = ObjectSerializer.serialize(awardId, "Array<string>");
        }

        if (awardComponent !== undefined) {
            localVarQueryParameters['award.component'] = ObjectSerializer.serialize(awardComponent, "Array<'affiliate' | 'data analysis' | 'data coordination' | 'functional characterization' | 'mapping' | 'networks' | 'predictive modeling'>");
        }

        if (collections !== undefined) {
            localVarQueryParameters['collections'] = ObjectSerializer.serialize(collections, "Array<'ClinGen' | 'ENCODE' | 'GREGoR' | 'IGVF_catalog_beta_v0.1' | 'IGVF_catalog_beta_v0.2' | 'IGVF_catalog_beta_v0.3' | 'IGVF_catalog_beta_v0.4' | 'MaveDB' | 'MPRAbase' | 'Vista'>");
        }

        if (controlForId !== undefined) {
            localVarQueryParameters['control_for.@id'] = ObjectSerializer.serialize(controlForId, "Array<string>");
        }

        if (controlForAccession !== undefined) {
            localVarQueryParameters['control_for.accession'] = ObjectSerializer.serialize(controlForAccession, "Array<string>");
        }

        if (controlForAliases !== undefined) {
            localVarQueryParameters['control_for.aliases'] = ObjectSerializer.serialize(controlForAliases, "Array<string>");
        }

        if (creationTimestamp !== undefined) {
            localVarQueryParameters['creation_timestamp'] = ObjectSerializer.serialize(creationTimestamp, "Array<string>");
        }

        if (description !== undefined) {
            localVarQueryParameters['description'] = ObjectSerializer.serialize(description, "Array<string>");
        }

        if (documents !== undefined) {
            localVarQueryParameters['documents'] = ObjectSerializer.serialize(documents, "Array<string>");
        }

        if (exon !== undefined) {
            localVarQueryParameters['exon'] = ObjectSerializer.serialize(exon, "Array<string>");
        }

        if (fileSetType !== undefined) {
            localVarQueryParameters['file_set_type'] = ObjectSerializer.serialize(fileSetType, "Array<'guide library' | 'reporter library' | 'expression vector library' | 'editing template library'>");
        }

        if (filesId !== undefined) {
            localVarQueryParameters['files.@id'] = ObjectSerializer.serialize(filesId, "Array<string>");
        }

        if (filesAccession !== undefined) {
            localVarQueryParameters['files.accession'] = ObjectSerializer.serialize(filesAccession, "Array<string>");
        }

        if (filesAliases !== undefined) {
            localVarQueryParameters['files.aliases'] = ObjectSerializer.serialize(filesAliases, "Array<string>");
        }

        if (filesContentType !== undefined) {
            localVarQueryParameters['files.content_type'] = ObjectSerializer.serialize(filesContentType, "Array<string>");
        }

        if (filesFileFormat !== undefined) {
            localVarQueryParameters['files.file_format'] = ObjectSerializer.serialize(filesFileFormat, "Array<string>");
        }

        if (filesUploadStatus !== undefined) {
            localVarQueryParameters['files.upload_status'] = ObjectSerializer.serialize(filesUploadStatus, "Array<'pending' | 'file not found' | 'invalidated' | 'validated'>");
        }

        if (guideType !== undefined) {
            localVarQueryParameters['guide_type'] = ObjectSerializer.serialize(guideType, "Array<'sgRNA' | 'pgRNA'>");
        }

        if (inputFileSetFor !== undefined) {
            localVarQueryParameters['input_file_set_for'] = ObjectSerializer.serialize(inputFileSetFor, "Array<string>");
        }

        if (integratedContentFiles !== undefined) {
            localVarQueryParameters['integrated_content_files'] = ObjectSerializer.serialize(integratedContentFiles, "Array<string>");
        }

        if (labId !== undefined) {
            localVarQueryParameters['lab.@id'] = ObjectSerializer.serialize(labId, "Array<string>");
        }

        if (labTitle !== undefined) {
            localVarQueryParameters['lab.title'] = ObjectSerializer.serialize(labTitle, "Array<string>");
        }

        if (largeScaleGeneListId !== undefined) {
            localVarQueryParameters['large_scale_gene_list.@id'] = ObjectSerializer.serialize(largeScaleGeneListId, "Array<string>");
        }

        if (largeScaleGeneListAccession !== undefined) {
            localVarQueryParameters['large_scale_gene_list.accession'] = ObjectSerializer.serialize(largeScaleGeneListAccession, "Array<string>");
        }

        if (largeScaleGeneListAliases !== undefined) {
            localVarQueryParameters['large_scale_gene_list.aliases'] = ObjectSerializer.serialize(largeScaleGeneListAliases, "Array<string>");
        }

        if (largeScaleLociListId !== undefined) {
            localVarQueryParameters['large_scale_loci_list.@id'] = ObjectSerializer.serialize(largeScaleLociListId, "Array<string>");
        }

        if (largeScaleLociListAccession !== undefined) {
            localVarQueryParameters['large_scale_loci_list.accession'] = ObjectSerializer.serialize(largeScaleLociListAccession, "Array<string>");
        }

        if (largeScaleLociListAliases !== undefined) {
            localVarQueryParameters['large_scale_loci_list.aliases'] = ObjectSerializer.serialize(largeScaleLociListAliases, "Array<string>");
        }

        if (lotId !== undefined) {
            localVarQueryParameters['lot_id'] = ObjectSerializer.serialize(lotId, "Array<string>");
        }

        if (lowerBoundGuideCoverage !== undefined) {
            localVarQueryParameters['lower_bound_guide_coverage'] = ObjectSerializer.serialize(lowerBoundGuideCoverage, "Array<number>");
        }

        if (lowerBoundInsertSize !== undefined) {
            localVarQueryParameters['lower_bound_insert_size'] = ObjectSerializer.serialize(lowerBoundInsertSize, "Array<number>");
        }

        if (notes !== undefined) {
            localVarQueryParameters['notes'] = ObjectSerializer.serialize(notes, "Array<string>");
        }

        if (orfListId !== undefined) {
            localVarQueryParameters['orf_list.@id'] = ObjectSerializer.serialize(orfListId, "Array<string>");
        }

        if (orfListAliases !== undefined) {
            localVarQueryParameters['orf_list.aliases'] = ObjectSerializer.serialize(orfListAliases, "Array<string>");
        }

        if (orfListGene !== undefined) {
            localVarQueryParameters['orf_list.gene'] = ObjectSerializer.serialize(orfListGene, "Array<string>");
        }

        if (orfListOrfId !== undefined) {
            localVarQueryParameters['orf_list.orf_id'] = ObjectSerializer.serialize(orfListOrfId, "Array<string>");
        }

        if (productId !== undefined) {
            localVarQueryParameters['product_id'] = ObjectSerializer.serialize(productId, "Array<string>");
        }

        if (publicationIdentifiers !== undefined) {
            localVarQueryParameters['publication_identifiers'] = ObjectSerializer.serialize(publicationIdentifiers, "Array<string>");
        }

        if (publications !== undefined) {
            localVarQueryParameters['publications'] = ObjectSerializer.serialize(publications, "Array<string>");
        }

        if (releaseTimestamp !== undefined) {
            localVarQueryParameters['release_timestamp'] = ObjectSerializer.serialize(releaseTimestamp, "Array<string>");
        }

        if (revokeDetail !== undefined) {
            localVarQueryParameters['revoke_detail'] = ObjectSerializer.serialize(revokeDetail, "Array<string>");
        }

        if (scope !== undefined) {
            localVarQueryParameters['scope'] = ObjectSerializer.serialize(scope, "Array<'tile' | 'exon' | 'genes' | 'loci' | 'genome-wide' | 'interactors' | 'alleles' | 'targeton'>");
        }

        if (selectionCriteria !== undefined) {
            localVarQueryParameters['selection_criteria'] = ObjectSerializer.serialize(selectionCriteria, "Array<'accessible genome regions' | 'candidate cis-regulatory elements' | 'chromatin states' | 'phenotype-associated variants' | 'DNase hypersensitive sites' | 'genes' | 'histone modifications' | 'protein interactors' | 'sequence variants' | 'synthetic elements' | 'transcription start sites' | 'TF binding sites'>");
        }

        if (smallScaleGeneListId !== undefined) {
            localVarQueryParameters['small_scale_gene_list.@id'] = ObjectSerializer.serialize(smallScaleGeneListId, "Array<string>");
        }

        if (smallScaleGeneListGeneid !== undefined) {
            localVarQueryParameters['small_scale_gene_list.geneid'] = ObjectSerializer.serialize(smallScaleGeneListGeneid, "Array<string>");
        }

        if (smallScaleGeneListName !== undefined) {
            localVarQueryParameters['small_scale_gene_list.name'] = ObjectSerializer.serialize(smallScaleGeneListName, "Array<string>");
        }

        if (smallScaleGeneListSymbol !== undefined) {
            localVarQueryParameters['small_scale_gene_list.symbol'] = ObjectSerializer.serialize(smallScaleGeneListSymbol, "Array<string>");
        }

        if (smallScaleGeneListSynonyms !== undefined) {
            localVarQueryParameters['small_scale_gene_list.synonyms'] = ObjectSerializer.serialize(smallScaleGeneListSynonyms, "Array<string>");
        }

        if (smallScaleLociList !== undefined) {
            localVarQueryParameters['small_scale_loci_list'] = ObjectSerializer.serialize(smallScaleLociList, "Array<Locus>");
        }

        if (sources !== undefined) {
            localVarQueryParameters['sources'] = ObjectSerializer.serialize(sources, "Array<string>");
        }

        if (status !== undefined) {
            localVarQueryParameters['status'] = ObjectSerializer.serialize(status, "Array<'in progress' | 'released' | 'deleted' | 'replaced' | 'revoked' | 'archived'>");
        }

        if (submittedById !== undefined) {
            localVarQueryParameters['submitted_by.@id'] = ObjectSerializer.serialize(submittedById, "Array<string>");
        }

        if (submittedByTitle !== undefined) {
            localVarQueryParameters['submitted_by.title'] = ObjectSerializer.serialize(submittedByTitle, "Array<string>");
        }

        if (submittedFilesTimestamp !== undefined) {
            localVarQueryParameters['submitted_files_timestamp'] = ObjectSerializer.serialize(submittedFilesTimestamp, "Array<string>");
        }

        if (submitterComment !== undefined) {
            localVarQueryParameters['submitter_comment'] = ObjectSerializer.serialize(submitterComment, "Array<string>");
        }

        if (summary !== undefined) {
            localVarQueryParameters['summary'] = ObjectSerializer.serialize(summary, "Array<string>");
        }

        if (targeton !== undefined) {
            localVarQueryParameters['targeton'] = ObjectSerializer.serialize(targeton, "Array<string>");
        }

        if (tilingModality !== undefined) {
            localVarQueryParameters['tiling_modality'] = ObjectSerializer.serialize(tilingModality, "Array<'peak tiling' | 'full tiling' | 'sparse peaks'>");
        }

        if (upperBoundGuideCoverage !== undefined) {
            localVarQueryParameters['upper_bound_guide_coverage'] = ObjectSerializer.serialize(upperBoundGuideCoverage, "Array<number>");
        }

        if (upperBoundInsertSize !== undefined) {
            localVarQueryParameters['upper_bound_insert_size'] = ObjectSerializer.serialize(upperBoundInsertSize, "Array<number>");
        }

        if (uuid !== undefined) {
            localVarQueryParameters['uuid'] = ObjectSerializer.serialize(uuid, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: ConstructLibrarySetResults;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "ConstructLibrarySetResults");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Collection endpoint that accepts various query parameters to filter, sort, and paginate CrisprModification items. Supports filtering on fields within CrisprModification items.
     * @summary List items in the CrisprModification collection.
     * @param frame Constant value. Do not set.
     * @param query Query string for searching.
     * @param limit Maximum number of results to return. Default is 25. Use \&#39;all\&#39; for all results.
     * @param sort Fields to sort results by. Prefix with \&#39;-\&#39; for descending order. Can be repeated for multiple sort fields. Does not work with limit&#x3D;all.
     * @param id Filter by @id
     * @param activated Filter by activated
     * @param activatingAgentTermId Filter by activating_agent_term_id
     * @param activatingAgentTermName Filter by activating_agent_term_name
     * @param aliases Filter by aliases
     * @param awardId Filter by award.@id
     * @param awardComponent Filter by award.component
     * @param biosamplesModified Filter by biosamples_modified
     * @param cas Filter by cas
     * @param casSpecies Filter by cas_species
     * @param creationTimestamp Filter by creation_timestamp
     * @param description Filter by description
     * @param documents Filter by documents
     * @param fusedDomain Filter by fused_domain
     * @param labId Filter by lab.@id
     * @param labTitle Filter by lab.title
     * @param lotId Filter by lot_id
     * @param modality Filter by modality
     * @param notes Filter by notes
     * @param productId Filter by product_id
     * @param releaseTimestamp Filter by release_timestamp
     * @param sources Filter by sources
     * @param status Filter by status
     * @param submittedById Filter by submitted_by.@id
     * @param submittedByTitle Filter by submitted_by.title
     * @param submitterComment Filter by submitter_comment
     * @param summary Filter by summary
     * @param taggedProtein Filter by tagged_protein
     * @param uuid Filter by uuid
     */
    public async crisprModifications (frame: 'object', query?: string, limit?: Limit, sort?: Array<string>, id?: Array<string>, activated?: Array<boolean>, activatingAgentTermId?: Array<string>, activatingAgentTermName?: Array<string>, aliases?: Array<string>, awardId?: Array<string>, awardComponent?: Array<'affiliate' | 'data analysis' | 'data coordination' | 'functional characterization' | 'mapping' | 'networks' | 'predictive modeling'>, biosamplesModified?: Array<string>, cas?: Array<'Cas9' | 'Cas12a' | 'Cas13' | 'dCas9' | 'nCas9' | 'SpG' | 'SpRY'>, casSpecies?: Array<'Streptococcus pyogenes (Sp)' | 'Staphylococcus aureus (Sa)' | 'Campylobacter jejuni (Cj)' | 'Neisseria meningitidis (Nm)'>, creationTimestamp?: Array<string>, description?: Array<string>, documents?: Array<string>, fusedDomain?: Array<'2xVP64' | '3xVP64' | 'ABE8e' | 'ABE8.20' | 'ANTI-FLAG' | 'BE4' | 'BE4max' | 'eA3A' | 'eA3A-T31A' | 'eA3A-T44D-S45A' | 'KOX1-KRAB' | 'M-MLV RT (PE2)' | 'p300' | 'TdCBE' | 'TdCGBE' | 'TdDE' | 'VPH' | 'VP64' | 'VP64-p65-Rta (VPR)' | 'ZIM3-KRAB'>, labId?: Array<string>, labTitle?: Array<string>, lotId?: Array<string>, modality?: Array<'activation' | 'base editing' | 'cutting' | 'interference' | 'knockout' | 'localizing' | 'prime editing'>, notes?: Array<string>, productId?: Array<string>, releaseTimestamp?: Array<string>, sources?: Array<string>, status?: Array<'archived' | 'deleted' | 'in progress' | 'released'>, submittedById?: Array<string>, submittedByTitle?: Array<string>, submitterComment?: Array<string>, summary?: Array<string>, taggedProtein?: Array<string>, uuid?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: CrisprModificationResults;  }> {
        const localVarPath = this.basePath + '/crispr-modifications/@@listing';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'frame' is not null or undefined
        if (frame === null || frame === undefined) {
            throw new Error('Required parameter frame was null or undefined when calling crisprModifications.');
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (frame !== undefined) {
            localVarQueryParameters['frame'] = ObjectSerializer.serialize(frame, "'object'");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "Limit");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "Array<string>");
        }

        if (id !== undefined) {
            localVarQueryParameters['@id'] = ObjectSerializer.serialize(id, "Array<string>");
        }

        if (activated !== undefined) {
            localVarQueryParameters['activated'] = ObjectSerializer.serialize(activated, "Array<boolean>");
        }

        if (activatingAgentTermId !== undefined) {
            localVarQueryParameters['activating_agent_term_id'] = ObjectSerializer.serialize(activatingAgentTermId, "Array<string>");
        }

        if (activatingAgentTermName !== undefined) {
            localVarQueryParameters['activating_agent_term_name'] = ObjectSerializer.serialize(activatingAgentTermName, "Array<string>");
        }

        if (aliases !== undefined) {
            localVarQueryParameters['aliases'] = ObjectSerializer.serialize(aliases, "Array<string>");
        }

        if (awardId !== undefined) {
            localVarQueryParameters['award.@id'] = ObjectSerializer.serialize(awardId, "Array<string>");
        }

        if (awardComponent !== undefined) {
            localVarQueryParameters['award.component'] = ObjectSerializer.serialize(awardComponent, "Array<'affiliate' | 'data analysis' | 'data coordination' | 'functional characterization' | 'mapping' | 'networks' | 'predictive modeling'>");
        }

        if (biosamplesModified !== undefined) {
            localVarQueryParameters['biosamples_modified'] = ObjectSerializer.serialize(biosamplesModified, "Array<string>");
        }

        if (cas !== undefined) {
            localVarQueryParameters['cas'] = ObjectSerializer.serialize(cas, "Array<'Cas9' | 'Cas12a' | 'Cas13' | 'dCas9' | 'nCas9' | 'SpG' | 'SpRY'>");
        }

        if (casSpecies !== undefined) {
            localVarQueryParameters['cas_species'] = ObjectSerializer.serialize(casSpecies, "Array<'Streptococcus pyogenes (Sp)' | 'Staphylococcus aureus (Sa)' | 'Campylobacter jejuni (Cj)' | 'Neisseria meningitidis (Nm)'>");
        }

        if (creationTimestamp !== undefined) {
            localVarQueryParameters['creation_timestamp'] = ObjectSerializer.serialize(creationTimestamp, "Array<string>");
        }

        if (description !== undefined) {
            localVarQueryParameters['description'] = ObjectSerializer.serialize(description, "Array<string>");
        }

        if (documents !== undefined) {
            localVarQueryParameters['documents'] = ObjectSerializer.serialize(documents, "Array<string>");
        }

        if (fusedDomain !== undefined) {
            localVarQueryParameters['fused_domain'] = ObjectSerializer.serialize(fusedDomain, "Array<'2xVP64' | '3xVP64' | 'ABE8e' | 'ABE8.20' | 'ANTI-FLAG' | 'BE4' | 'BE4max' | 'eA3A' | 'eA3A-T31A' | 'eA3A-T44D-S45A' | 'KOX1-KRAB' | 'M-MLV RT (PE2)' | 'p300' | 'TdCBE' | 'TdCGBE' | 'TdDE' | 'VPH' | 'VP64' | 'VP64-p65-Rta (VPR)' | 'ZIM3-KRAB'>");
        }

        if (labId !== undefined) {
            localVarQueryParameters['lab.@id'] = ObjectSerializer.serialize(labId, "Array<string>");
        }

        if (labTitle !== undefined) {
            localVarQueryParameters['lab.title'] = ObjectSerializer.serialize(labTitle, "Array<string>");
        }

        if (lotId !== undefined) {
            localVarQueryParameters['lot_id'] = ObjectSerializer.serialize(lotId, "Array<string>");
        }

        if (modality !== undefined) {
            localVarQueryParameters['modality'] = ObjectSerializer.serialize(modality, "Array<'activation' | 'base editing' | 'cutting' | 'interference' | 'knockout' | 'localizing' | 'prime editing'>");
        }

        if (notes !== undefined) {
            localVarQueryParameters['notes'] = ObjectSerializer.serialize(notes, "Array<string>");
        }

        if (productId !== undefined) {
            localVarQueryParameters['product_id'] = ObjectSerializer.serialize(productId, "Array<string>");
        }

        if (releaseTimestamp !== undefined) {
            localVarQueryParameters['release_timestamp'] = ObjectSerializer.serialize(releaseTimestamp, "Array<string>");
        }

        if (sources !== undefined) {
            localVarQueryParameters['sources'] = ObjectSerializer.serialize(sources, "Array<string>");
        }

        if (status !== undefined) {
            localVarQueryParameters['status'] = ObjectSerializer.serialize(status, "Array<'archived' | 'deleted' | 'in progress' | 'released'>");
        }

        if (submittedById !== undefined) {
            localVarQueryParameters['submitted_by.@id'] = ObjectSerializer.serialize(submittedById, "Array<string>");
        }

        if (submittedByTitle !== undefined) {
            localVarQueryParameters['submitted_by.title'] = ObjectSerializer.serialize(submittedByTitle, "Array<string>");
        }

        if (submitterComment !== undefined) {
            localVarQueryParameters['submitter_comment'] = ObjectSerializer.serialize(submitterComment, "Array<string>");
        }

        if (summary !== undefined) {
            localVarQueryParameters['summary'] = ObjectSerializer.serialize(summary, "Array<string>");
        }

        if (taggedProtein !== undefined) {
            localVarQueryParameters['tagged_protein'] = ObjectSerializer.serialize(taggedProtein, "Array<string>");
        }

        if (uuid !== undefined) {
            localVarQueryParameters['uuid'] = ObjectSerializer.serialize(uuid, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: CrisprModificationResults;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "CrisprModificationResults");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Collection endpoint that accepts various query parameters to filter, sort, and paginate CuratedSet items. Supports filtering on fields within CuratedSet items.
     * @summary List items in the CuratedSet collection.
     * @param frame Constant value. Do not set.
     * @param query Query string for searching.
     * @param limit Maximum number of results to return. Default is 25. Use \&#39;all\&#39; for all results.
     * @param sort Fields to sort results by. Prefix with \&#39;-\&#39; for descending order. Can be repeated for multiple sort fields. Does not work with limit&#x3D;all.
     * @param id Filter by @id
     * @param accession Filter by accession
     * @param aliases Filter by aliases
     * @param alternateAccessions Filter by alternate_accessions
     * @param assemblies Filter by assemblies
     * @param awardId Filter by award.@id
     * @param awardComponent Filter by award.component
     * @param awardContactPiId Filter by award.contact_pi.@id
     * @param awardContactPiTitle Filter by award.contact_pi.title
     * @param awardTitle Filter by award.title
     * @param collections Filter by collections
     * @param controlForId Filter by control_for.@id
     * @param controlForAccession Filter by control_for.accession
     * @param controlForAliases Filter by control_for.aliases
     * @param creationTimestamp Filter by creation_timestamp
     * @param dbxrefs Filter by dbxrefs
     * @param description Filter by description
     * @param documents Filter by documents
     * @param donorsId Filter by donors.@id
     * @param donorsAccession Filter by donors.accession
     * @param donorsAliases Filter by donors.aliases
     * @param donorsSex Filter by donors.sex
     * @param donorsStatus Filter by donors.status
     * @param donorsTaxa Filter by donors.taxa
     * @param fileSetType Filter by file_set_type
     * @param filesId Filter by files.@id
     * @param filesAccession Filter by files.accession
     * @param filesAliases Filter by files.aliases
     * @param filesContentType Filter by files.content_type
     * @param filesCreationTimestamp Filter by files.creation_timestamp
     * @param filesFileFormat Filter by files.file_format
     * @param filesFileSize Filter by files.file_size
     * @param filesHref Filter by files.href
     * @param filesS3Uri Filter by files.s3_uri
     * @param filesSequencingPlatform Filter by files.sequencing_platform
     * @param filesSubmittedFileName Filter by files.submitted_file_name
     * @param filesUploadStatus Filter by files.upload_status
     * @param inputFileSetFor Filter by input_file_set_for
     * @param labId Filter by lab.@id
     * @param labTitle Filter by lab.title
     * @param notes Filter by notes
     * @param publicationIdentifiers Filter by publication_identifiers
     * @param publications Filter by publications
     * @param releaseTimestamp Filter by release_timestamp
     * @param revokeDetail Filter by revoke_detail
     * @param samplesId Filter by samples.@id
     * @param samplesAccession Filter by samples.accession
     * @param samplesAliases Filter by samples.aliases
     * @param samplesCellFateChangeTreatments Filter by samples.cell_fate_change_treatments
     * @param samplesClassifications Filter by samples.classifications
     * @param samplesConstructLibrarySets Filter by samples.construct_library_sets
     * @param samplesDiseaseTermsId Filter by samples.disease_terms.@id
     * @param samplesDiseaseTermsTermName Filter by samples.disease_terms.term_name
     * @param samplesModifications Filter by samples.modifications
     * @param samplesSampleTermsId Filter by samples.sample_terms.@id
     * @param samplesSampleTermsAliases Filter by samples.sample_terms.aliases
     * @param samplesSampleTermsStatus Filter by samples.sample_terms.status
     * @param samplesSampleTermsSummary Filter by samples.sample_terms.summary
     * @param samplesSampleTermsTermName Filter by samples.sample_terms.term_name
     * @param samplesStatus Filter by samples.status
     * @param samplesSummary Filter by samples.summary
     * @param samplesTargetedSampleTermId Filter by samples.targeted_sample_term.@id
     * @param samplesTargetedSampleTermTermName Filter by samples.targeted_sample_term.term_name
     * @param samplesTaxa Filter by samples.taxa
     * @param samplesTreatments Filter by samples.treatments
     * @param status Filter by status
     * @param submittedById Filter by submitted_by.@id
     * @param submittedByTitle Filter by submitted_by.title
     * @param submittedFilesTimestamp Filter by submitted_files_timestamp
     * @param submitterComment Filter by submitter_comment
     * @param summary Filter by summary
     * @param taxa Filter by taxa
     * @param transcriptomeAnnotations Filter by transcriptome_annotations
     * @param url Filter by url
     * @param uuid Filter by uuid
     */
    public async curatedSets (frame: 'object', query?: string, limit?: Limit, sort?: Array<string>, id?: Array<string>, accession?: Array<string>, aliases?: Array<string>, alternateAccessions?: Array<string>, assemblies?: Array<string>, awardId?: Array<string>, awardComponent?: Array<'affiliate' | 'data analysis' | 'data coordination' | 'functional characterization' | 'mapping' | 'networks' | 'predictive modeling'>, awardContactPiId?: Array<string>, awardContactPiTitle?: Array<string>, awardTitle?: Array<string>, collections?: Array<'ClinGen' | 'ENCODE' | 'GREGoR' | 'IGVF_catalog_beta_v0.1' | 'IGVF_catalog_beta_v0.2' | 'IGVF_catalog_beta_v0.3' | 'IGVF_catalog_beta_v0.4' | 'MaveDB' | 'MPRAbase' | 'Vista'>, controlForId?: Array<string>, controlForAccession?: Array<string>, controlForAliases?: Array<string>, creationTimestamp?: Array<string>, dbxrefs?: Array<string>, description?: Array<string>, documents?: Array<string>, donorsId?: Array<string>, donorsAccession?: Array<string>, donorsAliases?: Array<string>, donorsSex?: Array<'male' | 'female' | 'unspecified'>, donorsStatus?: Array<'in progress' | 'released' | 'deleted' | 'replaced' | 'revoked' | 'archived'>, donorsTaxa?: Array<string>, fileSetType?: Array<'barcodes' | 'editing templates' | 'elements' | 'external data for catalog' | 'genome' | 'genes' | 'guide RNAs' | 'transcriptome' | 'variants'>, filesId?: Array<string>, filesAccession?: Array<string>, filesAliases?: Array<string>, filesContentType?: Array<string>, filesCreationTimestamp?: Array<string>, filesFileFormat?: Array<string>, filesFileSize?: Array<number>, filesHref?: Array<string>, filesS3Uri?: Array<string>, filesSequencingPlatform?: Array<string>, filesSubmittedFileName?: Array<string>, filesUploadStatus?: Array<'pending' | 'file not found' | 'invalidated' | 'validated'>, inputFileSetFor?: Array<string>, labId?: Array<string>, labTitle?: Array<string>, notes?: Array<string>, publicationIdentifiers?: Array<string>, publications?: Array<string>, releaseTimestamp?: Array<string>, revokeDetail?: Array<string>, samplesId?: Array<string>, samplesAccession?: Array<string>, samplesAliases?: Array<string>, samplesCellFateChangeTreatments?: Array<string>, samplesClassifications?: Array<'organoid' | 'gastruloid' | 'embryoid' | 'cell line' | 'differentiated cell specimen' | 'reprogrammed cell specimen' | 'pooled cell specimen'>, samplesConstructLibrarySets?: Array<string>, samplesDiseaseTermsId?: Array<string>, samplesDiseaseTermsTermName?: Array<string>, samplesModifications?: Array<string>, samplesSampleTermsId?: Array<string>, samplesSampleTermsAliases?: Array<string>, samplesSampleTermsStatus?: Array<'archived' | 'deleted' | 'in progress' | 'released'>, samplesSampleTermsSummary?: Array<string>, samplesSampleTermsTermName?: Array<string>, samplesStatus?: Array<'in progress' | 'released' | 'deleted' | 'replaced' | 'revoked' | 'archived'>, samplesSummary?: Array<string>, samplesTargetedSampleTermId?: Array<string>, samplesTargetedSampleTermTermName?: Array<string>, samplesTaxa?: Array<'Homo sapiens' | 'Mus musculus'>, samplesTreatments?: Array<string>, status?: Array<'in progress' | 'released' | 'deleted' | 'replaced' | 'revoked' | 'archived'>, submittedById?: Array<string>, submittedByTitle?: Array<string>, submittedFilesTimestamp?: Array<string>, submitterComment?: Array<string>, summary?: Array<string>, taxa?: Array<'Homo sapiens' | 'Mus musculus'>, transcriptomeAnnotations?: Array<string>, url?: Array<string>, uuid?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: CuratedSetResults;  }> {
        const localVarPath = this.basePath + '/curated-sets/@@listing';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'frame' is not null or undefined
        if (frame === null || frame === undefined) {
            throw new Error('Required parameter frame was null or undefined when calling curatedSets.');
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (frame !== undefined) {
            localVarQueryParameters['frame'] = ObjectSerializer.serialize(frame, "'object'");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "Limit");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "Array<string>");
        }

        if (id !== undefined) {
            localVarQueryParameters['@id'] = ObjectSerializer.serialize(id, "Array<string>");
        }

        if (accession !== undefined) {
            localVarQueryParameters['accession'] = ObjectSerializer.serialize(accession, "Array<string>");
        }

        if (aliases !== undefined) {
            localVarQueryParameters['aliases'] = ObjectSerializer.serialize(aliases, "Array<string>");
        }

        if (alternateAccessions !== undefined) {
            localVarQueryParameters['alternate_accessions'] = ObjectSerializer.serialize(alternateAccessions, "Array<string>");
        }

        if (assemblies !== undefined) {
            localVarQueryParameters['assemblies'] = ObjectSerializer.serialize(assemblies, "Array<string>");
        }

        if (awardId !== undefined) {
            localVarQueryParameters['award.@id'] = ObjectSerializer.serialize(awardId, "Array<string>");
        }

        if (awardComponent !== undefined) {
            localVarQueryParameters['award.component'] = ObjectSerializer.serialize(awardComponent, "Array<'affiliate' | 'data analysis' | 'data coordination' | 'functional characterization' | 'mapping' | 'networks' | 'predictive modeling'>");
        }

        if (awardContactPiId !== undefined) {
            localVarQueryParameters['award.contact_pi.@id'] = ObjectSerializer.serialize(awardContactPiId, "Array<string>");
        }

        if (awardContactPiTitle !== undefined) {
            localVarQueryParameters['award.contact_pi.title'] = ObjectSerializer.serialize(awardContactPiTitle, "Array<string>");
        }

        if (awardTitle !== undefined) {
            localVarQueryParameters['award.title'] = ObjectSerializer.serialize(awardTitle, "Array<string>");
        }

        if (collections !== undefined) {
            localVarQueryParameters['collections'] = ObjectSerializer.serialize(collections, "Array<'ClinGen' | 'ENCODE' | 'GREGoR' | 'IGVF_catalog_beta_v0.1' | 'IGVF_catalog_beta_v0.2' | 'IGVF_catalog_beta_v0.3' | 'IGVF_catalog_beta_v0.4' | 'MaveDB' | 'MPRAbase' | 'Vista'>");
        }

        if (controlForId !== undefined) {
            localVarQueryParameters['control_for.@id'] = ObjectSerializer.serialize(controlForId, "Array<string>");
        }

        if (controlForAccession !== undefined) {
            localVarQueryParameters['control_for.accession'] = ObjectSerializer.serialize(controlForAccession, "Array<string>");
        }

        if (controlForAliases !== undefined) {
            localVarQueryParameters['control_for.aliases'] = ObjectSerializer.serialize(controlForAliases, "Array<string>");
        }

        if (creationTimestamp !== undefined) {
            localVarQueryParameters['creation_timestamp'] = ObjectSerializer.serialize(creationTimestamp, "Array<string>");
        }

        if (dbxrefs !== undefined) {
            localVarQueryParameters['dbxrefs'] = ObjectSerializer.serialize(dbxrefs, "Array<string>");
        }

        if (description !== undefined) {
            localVarQueryParameters['description'] = ObjectSerializer.serialize(description, "Array<string>");
        }

        if (documents !== undefined) {
            localVarQueryParameters['documents'] = ObjectSerializer.serialize(documents, "Array<string>");
        }

        if (donorsId !== undefined) {
            localVarQueryParameters['donors.@id'] = ObjectSerializer.serialize(donorsId, "Array<string>");
        }

        if (donorsAccession !== undefined) {
            localVarQueryParameters['donors.accession'] = ObjectSerializer.serialize(donorsAccession, "Array<string>");
        }

        if (donorsAliases !== undefined) {
            localVarQueryParameters['donors.aliases'] = ObjectSerializer.serialize(donorsAliases, "Array<string>");
        }

        if (donorsSex !== undefined) {
            localVarQueryParameters['donors.sex'] = ObjectSerializer.serialize(donorsSex, "Array<'male' | 'female' | 'unspecified'>");
        }

        if (donorsStatus !== undefined) {
            localVarQueryParameters['donors.status'] = ObjectSerializer.serialize(donorsStatus, "Array<'in progress' | 'released' | 'deleted' | 'replaced' | 'revoked' | 'archived'>");
        }

        if (donorsTaxa !== undefined) {
            localVarQueryParameters['donors.taxa'] = ObjectSerializer.serialize(donorsTaxa, "Array<string>");
        }

        if (fileSetType !== undefined) {
            localVarQueryParameters['file_set_type'] = ObjectSerializer.serialize(fileSetType, "Array<'barcodes' | 'editing templates' | 'elements' | 'external data for catalog' | 'genome' | 'genes' | 'guide RNAs' | 'transcriptome' | 'variants'>");
        }

        if (filesId !== undefined) {
            localVarQueryParameters['files.@id'] = ObjectSerializer.serialize(filesId, "Array<string>");
        }

        if (filesAccession !== undefined) {
            localVarQueryParameters['files.accession'] = ObjectSerializer.serialize(filesAccession, "Array<string>");
        }

        if (filesAliases !== undefined) {
            localVarQueryParameters['files.aliases'] = ObjectSerializer.serialize(filesAliases, "Array<string>");
        }

        if (filesContentType !== undefined) {
            localVarQueryParameters['files.content_type'] = ObjectSerializer.serialize(filesContentType, "Array<string>");
        }

        if (filesCreationTimestamp !== undefined) {
            localVarQueryParameters['files.creation_timestamp'] = ObjectSerializer.serialize(filesCreationTimestamp, "Array<string>");
        }

        if (filesFileFormat !== undefined) {
            localVarQueryParameters['files.file_format'] = ObjectSerializer.serialize(filesFileFormat, "Array<string>");
        }

        if (filesFileSize !== undefined) {
            localVarQueryParameters['files.file_size'] = ObjectSerializer.serialize(filesFileSize, "Array<number>");
        }

        if (filesHref !== undefined) {
            localVarQueryParameters['files.href'] = ObjectSerializer.serialize(filesHref, "Array<string>");
        }

        if (filesS3Uri !== undefined) {
            localVarQueryParameters['files.s3_uri'] = ObjectSerializer.serialize(filesS3Uri, "Array<string>");
        }

        if (filesSequencingPlatform !== undefined) {
            localVarQueryParameters['files.sequencing_platform'] = ObjectSerializer.serialize(filesSequencingPlatform, "Array<string>");
        }

        if (filesSubmittedFileName !== undefined) {
            localVarQueryParameters['files.submitted_file_name'] = ObjectSerializer.serialize(filesSubmittedFileName, "Array<string>");
        }

        if (filesUploadStatus !== undefined) {
            localVarQueryParameters['files.upload_status'] = ObjectSerializer.serialize(filesUploadStatus, "Array<'pending' | 'file not found' | 'invalidated' | 'validated'>");
        }

        if (inputFileSetFor !== undefined) {
            localVarQueryParameters['input_file_set_for'] = ObjectSerializer.serialize(inputFileSetFor, "Array<string>");
        }

        if (labId !== undefined) {
            localVarQueryParameters['lab.@id'] = ObjectSerializer.serialize(labId, "Array<string>");
        }

        if (labTitle !== undefined) {
            localVarQueryParameters['lab.title'] = ObjectSerializer.serialize(labTitle, "Array<string>");
        }

        if (notes !== undefined) {
            localVarQueryParameters['notes'] = ObjectSerializer.serialize(notes, "Array<string>");
        }

        if (publicationIdentifiers !== undefined) {
            localVarQueryParameters['publication_identifiers'] = ObjectSerializer.serialize(publicationIdentifiers, "Array<string>");
        }

        if (publications !== undefined) {
            localVarQueryParameters['publications'] = ObjectSerializer.serialize(publications, "Array<string>");
        }

        if (releaseTimestamp !== undefined) {
            localVarQueryParameters['release_timestamp'] = ObjectSerializer.serialize(releaseTimestamp, "Array<string>");
        }

        if (revokeDetail !== undefined) {
            localVarQueryParameters['revoke_detail'] = ObjectSerializer.serialize(revokeDetail, "Array<string>");
        }

        if (samplesId !== undefined) {
            localVarQueryParameters['samples.@id'] = ObjectSerializer.serialize(samplesId, "Array<string>");
        }

        if (samplesAccession !== undefined) {
            localVarQueryParameters['samples.accession'] = ObjectSerializer.serialize(samplesAccession, "Array<string>");
        }

        if (samplesAliases !== undefined) {
            localVarQueryParameters['samples.aliases'] = ObjectSerializer.serialize(samplesAliases, "Array<string>");
        }

        if (samplesCellFateChangeTreatments !== undefined) {
            localVarQueryParameters['samples.cell_fate_change_treatments'] = ObjectSerializer.serialize(samplesCellFateChangeTreatments, "Array<string>");
        }

        if (samplesClassifications !== undefined) {
            localVarQueryParameters['samples.classifications'] = ObjectSerializer.serialize(samplesClassifications, "Array<'organoid' | 'gastruloid' | 'embryoid' | 'cell line' | 'differentiated cell specimen' | 'reprogrammed cell specimen' | 'pooled cell specimen'>");
        }

        if (samplesConstructLibrarySets !== undefined) {
            localVarQueryParameters['samples.construct_library_sets'] = ObjectSerializer.serialize(samplesConstructLibrarySets, "Array<string>");
        }

        if (samplesDiseaseTermsId !== undefined) {
            localVarQueryParameters['samples.disease_terms.@id'] = ObjectSerializer.serialize(samplesDiseaseTermsId, "Array<string>");
        }

        if (samplesDiseaseTermsTermName !== undefined) {
            localVarQueryParameters['samples.disease_terms.term_name'] = ObjectSerializer.serialize(samplesDiseaseTermsTermName, "Array<string>");
        }

        if (samplesModifications !== undefined) {
            localVarQueryParameters['samples.modifications'] = ObjectSerializer.serialize(samplesModifications, "Array<string>");
        }

        if (samplesSampleTermsId !== undefined) {
            localVarQueryParameters['samples.sample_terms.@id'] = ObjectSerializer.serialize(samplesSampleTermsId, "Array<string>");
        }

        if (samplesSampleTermsAliases !== undefined) {
            localVarQueryParameters['samples.sample_terms.aliases'] = ObjectSerializer.serialize(samplesSampleTermsAliases, "Array<string>");
        }

        if (samplesSampleTermsStatus !== undefined) {
            localVarQueryParameters['samples.sample_terms.status'] = ObjectSerializer.serialize(samplesSampleTermsStatus, "Array<'archived' | 'deleted' | 'in progress' | 'released'>");
        }

        if (samplesSampleTermsSummary !== undefined) {
            localVarQueryParameters['samples.sample_terms.summary'] = ObjectSerializer.serialize(samplesSampleTermsSummary, "Array<string>");
        }

        if (samplesSampleTermsTermName !== undefined) {
            localVarQueryParameters['samples.sample_terms.term_name'] = ObjectSerializer.serialize(samplesSampleTermsTermName, "Array<string>");
        }

        if (samplesStatus !== undefined) {
            localVarQueryParameters['samples.status'] = ObjectSerializer.serialize(samplesStatus, "Array<'in progress' | 'released' | 'deleted' | 'replaced' | 'revoked' | 'archived'>");
        }

        if (samplesSummary !== undefined) {
            localVarQueryParameters['samples.summary'] = ObjectSerializer.serialize(samplesSummary, "Array<string>");
        }

        if (samplesTargetedSampleTermId !== undefined) {
            localVarQueryParameters['samples.targeted_sample_term.@id'] = ObjectSerializer.serialize(samplesTargetedSampleTermId, "Array<string>");
        }

        if (samplesTargetedSampleTermTermName !== undefined) {
            localVarQueryParameters['samples.targeted_sample_term.term_name'] = ObjectSerializer.serialize(samplesTargetedSampleTermTermName, "Array<string>");
        }

        if (samplesTaxa !== undefined) {
            localVarQueryParameters['samples.taxa'] = ObjectSerializer.serialize(samplesTaxa, "Array<'Homo sapiens' | 'Mus musculus'>");
        }

        if (samplesTreatments !== undefined) {
            localVarQueryParameters['samples.treatments'] = ObjectSerializer.serialize(samplesTreatments, "Array<string>");
        }

        if (status !== undefined) {
            localVarQueryParameters['status'] = ObjectSerializer.serialize(status, "Array<'in progress' | 'released' | 'deleted' | 'replaced' | 'revoked' | 'archived'>");
        }

        if (submittedById !== undefined) {
            localVarQueryParameters['submitted_by.@id'] = ObjectSerializer.serialize(submittedById, "Array<string>");
        }

        if (submittedByTitle !== undefined) {
            localVarQueryParameters['submitted_by.title'] = ObjectSerializer.serialize(submittedByTitle, "Array<string>");
        }

        if (submittedFilesTimestamp !== undefined) {
            localVarQueryParameters['submitted_files_timestamp'] = ObjectSerializer.serialize(submittedFilesTimestamp, "Array<string>");
        }

        if (submitterComment !== undefined) {
            localVarQueryParameters['submitter_comment'] = ObjectSerializer.serialize(submitterComment, "Array<string>");
        }

        if (summary !== undefined) {
            localVarQueryParameters['summary'] = ObjectSerializer.serialize(summary, "Array<string>");
        }

        if (taxa !== undefined) {
            localVarQueryParameters['taxa'] = ObjectSerializer.serialize(taxa, "Array<'Homo sapiens' | 'Mus musculus'>");
        }

        if (transcriptomeAnnotations !== undefined) {
            localVarQueryParameters['transcriptome_annotations'] = ObjectSerializer.serialize(transcriptomeAnnotations, "Array<string>");
        }

        if (url !== undefined) {
            localVarQueryParameters['url'] = ObjectSerializer.serialize(url, "Array<string>");
        }

        if (uuid !== undefined) {
            localVarQueryParameters['uuid'] = ObjectSerializer.serialize(uuid, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: CuratedSetResults;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "CuratedSetResults");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Collection endpoint that accepts various query parameters to filter, sort, and paginate DegronModification items. Supports filtering on fields within DegronModification items.
     * @summary List items in the DegronModification collection.
     * @param frame Constant value. Do not set.
     * @param query Query string for searching.
     * @param limit Maximum number of results to return. Default is 25. Use \&#39;all\&#39; for all results.
     * @param sort Fields to sort results by. Prefix with \&#39;-\&#39; for descending order. Can be repeated for multiple sort fields. Does not work with limit&#x3D;all.
     * @param id Filter by @id
     * @param activated Filter by activated
     * @param activatingAgentTermId Filter by activating_agent_term_id
     * @param activatingAgentTermName Filter by activating_agent_term_name
     * @param aliases Filter by aliases
     * @param awardId Filter by award.@id
     * @param awardComponent Filter by award.component
     * @param biosamplesModified Filter by biosamples_modified
     * @param creationTimestamp Filter by creation_timestamp
     * @param degronSystem Filter by degron_system
     * @param description Filter by description
     * @param documents Filter by documents
     * @param labId Filter by lab.@id
     * @param labTitle Filter by lab.title
     * @param lotId Filter by lot_id
     * @param modality Filter by modality
     * @param notes Filter by notes
     * @param productId Filter by product_id
     * @param releaseTimestamp Filter by release_timestamp
     * @param sources Filter by sources
     * @param status Filter by status
     * @param submittedById Filter by submitted_by.@id
     * @param submittedByTitle Filter by submitted_by.title
     * @param submitterComment Filter by submitter_comment
     * @param summary Filter by summary
     * @param taggedProteins Filter by tagged_proteins
     * @param uuid Filter by uuid
     */
    public async degronModifications (frame: 'object', query?: string, limit?: Limit, sort?: Array<string>, id?: Array<string>, activated?: Array<boolean>, activatingAgentTermId?: Array<string>, activatingAgentTermName?: Array<string>, aliases?: Array<string>, awardId?: Array<string>, awardComponent?: Array<'affiliate' | 'data analysis' | 'data coordination' | 'functional characterization' | 'mapping' | 'networks' | 'predictive modeling'>, biosamplesModified?: Array<string>, creationTimestamp?: Array<string>, degronSystem?: Array<'AID' | 'AlissAid' | 'ssAID'>, description?: Array<string>, documents?: Array<string>, labId?: Array<string>, labTitle?: Array<string>, lotId?: Array<string>, modality?: Array<'degradation'>, notes?: Array<string>, productId?: Array<string>, releaseTimestamp?: Array<string>, sources?: Array<string>, status?: Array<'archived' | 'deleted' | 'in progress' | 'released'>, submittedById?: Array<string>, submittedByTitle?: Array<string>, submitterComment?: Array<string>, summary?: Array<string>, taggedProteins?: Array<string>, uuid?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: DegronModificationResults;  }> {
        const localVarPath = this.basePath + '/degron-modifications/@@listing';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'frame' is not null or undefined
        if (frame === null || frame === undefined) {
            throw new Error('Required parameter frame was null or undefined when calling degronModifications.');
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (frame !== undefined) {
            localVarQueryParameters['frame'] = ObjectSerializer.serialize(frame, "'object'");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "Limit");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "Array<string>");
        }

        if (id !== undefined) {
            localVarQueryParameters['@id'] = ObjectSerializer.serialize(id, "Array<string>");
        }

        if (activated !== undefined) {
            localVarQueryParameters['activated'] = ObjectSerializer.serialize(activated, "Array<boolean>");
        }

        if (activatingAgentTermId !== undefined) {
            localVarQueryParameters['activating_agent_term_id'] = ObjectSerializer.serialize(activatingAgentTermId, "Array<string>");
        }

        if (activatingAgentTermName !== undefined) {
            localVarQueryParameters['activating_agent_term_name'] = ObjectSerializer.serialize(activatingAgentTermName, "Array<string>");
        }

        if (aliases !== undefined) {
            localVarQueryParameters['aliases'] = ObjectSerializer.serialize(aliases, "Array<string>");
        }

        if (awardId !== undefined) {
            localVarQueryParameters['award.@id'] = ObjectSerializer.serialize(awardId, "Array<string>");
        }

        if (awardComponent !== undefined) {
            localVarQueryParameters['award.component'] = ObjectSerializer.serialize(awardComponent, "Array<'affiliate' | 'data analysis' | 'data coordination' | 'functional characterization' | 'mapping' | 'networks' | 'predictive modeling'>");
        }

        if (biosamplesModified !== undefined) {
            localVarQueryParameters['biosamples_modified'] = ObjectSerializer.serialize(biosamplesModified, "Array<string>");
        }

        if (creationTimestamp !== undefined) {
            localVarQueryParameters['creation_timestamp'] = ObjectSerializer.serialize(creationTimestamp, "Array<string>");
        }

        if (degronSystem !== undefined) {
            localVarQueryParameters['degron_system'] = ObjectSerializer.serialize(degronSystem, "Array<'AID' | 'AlissAid' | 'ssAID'>");
        }

        if (description !== undefined) {
            localVarQueryParameters['description'] = ObjectSerializer.serialize(description, "Array<string>");
        }

        if (documents !== undefined) {
            localVarQueryParameters['documents'] = ObjectSerializer.serialize(documents, "Array<string>");
        }

        if (labId !== undefined) {
            localVarQueryParameters['lab.@id'] = ObjectSerializer.serialize(labId, "Array<string>");
        }

        if (labTitle !== undefined) {
            localVarQueryParameters['lab.title'] = ObjectSerializer.serialize(labTitle, "Array<string>");
        }

        if (lotId !== undefined) {
            localVarQueryParameters['lot_id'] = ObjectSerializer.serialize(lotId, "Array<string>");
        }

        if (modality !== undefined) {
            localVarQueryParameters['modality'] = ObjectSerializer.serialize(modality, "Array<'degradation'>");
        }

        if (notes !== undefined) {
            localVarQueryParameters['notes'] = ObjectSerializer.serialize(notes, "Array<string>");
        }

        if (productId !== undefined) {
            localVarQueryParameters['product_id'] = ObjectSerializer.serialize(productId, "Array<string>");
        }

        if (releaseTimestamp !== undefined) {
            localVarQueryParameters['release_timestamp'] = ObjectSerializer.serialize(releaseTimestamp, "Array<string>");
        }

        if (sources !== undefined) {
            localVarQueryParameters['sources'] = ObjectSerializer.serialize(sources, "Array<string>");
        }

        if (status !== undefined) {
            localVarQueryParameters['status'] = ObjectSerializer.serialize(status, "Array<'archived' | 'deleted' | 'in progress' | 'released'>");
        }

        if (submittedById !== undefined) {
            localVarQueryParameters['submitted_by.@id'] = ObjectSerializer.serialize(submittedById, "Array<string>");
        }

        if (submittedByTitle !== undefined) {
            localVarQueryParameters['submitted_by.title'] = ObjectSerializer.serialize(submittedByTitle, "Array<string>");
        }

        if (submitterComment !== undefined) {
            localVarQueryParameters['submitter_comment'] = ObjectSerializer.serialize(submitterComment, "Array<string>");
        }

        if (summary !== undefined) {
            localVarQueryParameters['summary'] = ObjectSerializer.serialize(summary, "Array<string>");
        }

        if (taggedProteins !== undefined) {
            localVarQueryParameters['tagged_proteins'] = ObjectSerializer.serialize(taggedProteins, "Array<string>");
        }

        if (uuid !== undefined) {
            localVarQueryParameters['uuid'] = ObjectSerializer.serialize(uuid, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: DegronModificationResults;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "DegronModificationResults");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Collection endpoint that accepts various query parameters to filter, sort, and paginate Document items. Supports filtering on fields within Document items.
     * @summary List items in the Document collection.
     * @param frame Constant value. Do not set.
     * @param query Query string for searching.
     * @param limit Maximum number of results to return. Default is 25. Use \&#39;all\&#39; for all results.
     * @param sort Fields to sort results by. Prefix with \&#39;-\&#39; for descending order. Can be repeated for multiple sort fields. Does not work with limit&#x3D;all.
     * @param id Filter by @id
     * @param aliases Filter by aliases
     * @param awardId Filter by award.@id
     * @param awardComponent Filter by award.component
     * @param characterizationMethod Filter by characterization_method
     * @param creationTimestamp Filter by creation_timestamp
     * @param description Filter by description
     * @param documentType Filter by document_type
     * @param labId Filter by lab.@id
     * @param labTitle Filter by lab.title
     * @param notes Filter by notes
     * @param releaseTimestamp Filter by release_timestamp
     * @param status Filter by status
     * @param submittedById Filter by submitted_by.@id
     * @param submittedByTitle Filter by submitted_by.title
     * @param submitterComment Filter by submitter_comment
     * @param summary Filter by summary
     * @param urls Filter by urls
     * @param uuid Filter by uuid
     */
    public async documents (frame: 'object', query?: string, limit?: Limit, sort?: Array<string>, id?: Array<string>, aliases?: Array<string>, awardId?: Array<string>, awardComponent?: Array<'affiliate' | 'data analysis' | 'data coordination' | 'functional characterization' | 'mapping' | 'networks' | 'predictive modeling'>, characterizationMethod?: Array<'FACS' | 'immunoblot' | 'immunofluorescence' | 'immunoprecipitation' | 'mass spectrometry' | 'PCR' | 'restriction digest' | 'RT-qPCR' | 'sequencing'>, creationTimestamp?: Array<string>, description?: Array<string>, documentType?: Array<'cell fate change protocol' | 'characterization' | 'computational protocol' | 'experimental protocol' | 'file format specification' | 'image' | 'model source data' | 'plate map' | 'plasmid map' | 'plasmid sequence' | 'standards'>, labId?: Array<string>, labTitle?: Array<string>, notes?: Array<string>, releaseTimestamp?: Array<string>, status?: Array<'archived' | 'deleted' | 'in progress' | 'released'>, submittedById?: Array<string>, submittedByTitle?: Array<string>, submitterComment?: Array<string>, summary?: Array<string>, urls?: Array<string>, uuid?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: DocumentResults;  }> {
        const localVarPath = this.basePath + '/documents/@@listing';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'frame' is not null or undefined
        if (frame === null || frame === undefined) {
            throw new Error('Required parameter frame was null or undefined when calling documents.');
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (frame !== undefined) {
            localVarQueryParameters['frame'] = ObjectSerializer.serialize(frame, "'object'");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "Limit");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "Array<string>");
        }

        if (id !== undefined) {
            localVarQueryParameters['@id'] = ObjectSerializer.serialize(id, "Array<string>");
        }

        if (aliases !== undefined) {
            localVarQueryParameters['aliases'] = ObjectSerializer.serialize(aliases, "Array<string>");
        }

        if (awardId !== undefined) {
            localVarQueryParameters['award.@id'] = ObjectSerializer.serialize(awardId, "Array<string>");
        }

        if (awardComponent !== undefined) {
            localVarQueryParameters['award.component'] = ObjectSerializer.serialize(awardComponent, "Array<'affiliate' | 'data analysis' | 'data coordination' | 'functional characterization' | 'mapping' | 'networks' | 'predictive modeling'>");
        }

        if (characterizationMethod !== undefined) {
            localVarQueryParameters['characterization_method'] = ObjectSerializer.serialize(characterizationMethod, "Array<'FACS' | 'immunoblot' | 'immunofluorescence' | 'immunoprecipitation' | 'mass spectrometry' | 'PCR' | 'restriction digest' | 'RT-qPCR' | 'sequencing'>");
        }

        if (creationTimestamp !== undefined) {
            localVarQueryParameters['creation_timestamp'] = ObjectSerializer.serialize(creationTimestamp, "Array<string>");
        }

        if (description !== undefined) {
            localVarQueryParameters['description'] = ObjectSerializer.serialize(description, "Array<string>");
        }

        if (documentType !== undefined) {
            localVarQueryParameters['document_type'] = ObjectSerializer.serialize(documentType, "Array<'cell fate change protocol' | 'characterization' | 'computational protocol' | 'experimental protocol' | 'file format specification' | 'image' | 'model source data' | 'plate map' | 'plasmid map' | 'plasmid sequence' | 'standards'>");
        }

        if (labId !== undefined) {
            localVarQueryParameters['lab.@id'] = ObjectSerializer.serialize(labId, "Array<string>");
        }

        if (labTitle !== undefined) {
            localVarQueryParameters['lab.title'] = ObjectSerializer.serialize(labTitle, "Array<string>");
        }

        if (notes !== undefined) {
            localVarQueryParameters['notes'] = ObjectSerializer.serialize(notes, "Array<string>");
        }

        if (releaseTimestamp !== undefined) {
            localVarQueryParameters['release_timestamp'] = ObjectSerializer.serialize(releaseTimestamp, "Array<string>");
        }

        if (status !== undefined) {
            localVarQueryParameters['status'] = ObjectSerializer.serialize(status, "Array<'archived' | 'deleted' | 'in progress' | 'released'>");
        }

        if (submittedById !== undefined) {
            localVarQueryParameters['submitted_by.@id'] = ObjectSerializer.serialize(submittedById, "Array<string>");
        }

        if (submittedByTitle !== undefined) {
            localVarQueryParameters['submitted_by.title'] = ObjectSerializer.serialize(submittedByTitle, "Array<string>");
        }

        if (submitterComment !== undefined) {
            localVarQueryParameters['submitter_comment'] = ObjectSerializer.serialize(submitterComment, "Array<string>");
        }

        if (summary !== undefined) {
            localVarQueryParameters['summary'] = ObjectSerializer.serialize(summary, "Array<string>");
        }

        if (urls !== undefined) {
            localVarQueryParameters['urls'] = ObjectSerializer.serialize(urls, "Array<string>");
        }

        if (uuid !== undefined) {
            localVarQueryParameters['uuid'] = ObjectSerializer.serialize(uuid, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: DocumentResults;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "DocumentResults");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Returns underlying file associated with file metadata
     * @summary Download file.
     * @param fileId The unique identifier for the file to download, e.g. @id (/tabular-files/IGVFFI8092FZKL/), accession (IGVFFI8092FZKL), or UUID (fdbdc159-e5b9-40a8-b788-3f72c9886b03).
     */
    public async download (fileId: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Buffer;  }> {
        const localVarPath = this.basePath + '/{file_id}/@@download'
            .replace('{' + 'file_id' + '}', encodeURIComponent(String(fileId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/octet-stream'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'fileId' is not null or undefined
        if (fileId === null || fileId === undefined) {
            throw new Error('Required parameter fileId was null or undefined when calling download.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            encoding: null,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Buffer;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Buffer");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Collection endpoint that accepts various query parameters to filter, sort, and paginate Gene items. Supports filtering on fields within Gene items.
     * @summary List items in the Gene collection.
     * @param frame Constant value. Do not set.
     * @param query Query string for searching.
     * @param limit Maximum number of results to return. Default is 25. Use \&#39;all\&#39; for all results.
     * @param sort Fields to sort results by. Prefix with \&#39;-\&#39; for descending order. Can be repeated for multiple sort fields. Does not work with limit&#x3D;all.
     * @param id Filter by @id
     * @param aliases Filter by aliases
     * @param creationTimestamp Filter by creation_timestamp
     * @param dbxrefs Filter by dbxrefs
     * @param description Filter by description
     * @param geneid Filter by geneid
     * @param geneidWithVersion Filter by geneid_with_version
     * @param locations Filter by locations
     * @param name Filter by name
     * @param notes Filter by notes
     * @param releaseTimestamp Filter by release_timestamp
     * @param status Filter by status
     * @param submittedById Filter by submitted_by.@id
     * @param submittedByTitle Filter by submitted_by.title
     * @param submitterComment Filter by submitter_comment
     * @param summary Filter by summary
     * @param symbol Filter by symbol
     * @param synonyms Filter by synonyms
     * @param taxa Filter by taxa
     * @param title Filter by title
     * @param transcriptomeAnnotation Filter by transcriptome_annotation
     * @param uuid Filter by uuid
     * @param versionNumber Filter by version_number
     */
    public async genes (frame: 'object', query?: string, limit?: Limit, sort?: Array<string>, id?: Array<string>, aliases?: Array<string>, creationTimestamp?: Array<string>, dbxrefs?: Array<string>, description?: Array<string>, geneid?: Array<string>, geneidWithVersion?: Array<string>, locations?: Array<GeneLocation>, name?: Array<string>, notes?: Array<string>, releaseTimestamp?: Array<string>, status?: Array<'archived' | 'deleted' | 'in progress' | 'released'>, submittedById?: Array<string>, submittedByTitle?: Array<string>, submitterComment?: Array<string>, summary?: Array<string>, symbol?: Array<string>, synonyms?: Array<string>, taxa?: Array<'Homo sapiens' | 'Mus musculus'>, title?: Array<string>, transcriptomeAnnotation?: Array<'GENCODE 40' | 'GENCODE 41' | 'GENCODE 42' | 'GENCODE 43' | 'GENCODE 44' | 'GENCODE 45' | 'GENCODE M30' | 'GENCODE M31' | 'GENCODE M32' | 'GENCODE M33' | 'GENCODE M34'>, uuid?: Array<string>, versionNumber?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: GeneResults;  }> {
        const localVarPath = this.basePath + '/genes/@@listing';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'frame' is not null or undefined
        if (frame === null || frame === undefined) {
            throw new Error('Required parameter frame was null or undefined when calling genes.');
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (frame !== undefined) {
            localVarQueryParameters['frame'] = ObjectSerializer.serialize(frame, "'object'");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "Limit");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "Array<string>");
        }

        if (id !== undefined) {
            localVarQueryParameters['@id'] = ObjectSerializer.serialize(id, "Array<string>");
        }

        if (aliases !== undefined) {
            localVarQueryParameters['aliases'] = ObjectSerializer.serialize(aliases, "Array<string>");
        }

        if (creationTimestamp !== undefined) {
            localVarQueryParameters['creation_timestamp'] = ObjectSerializer.serialize(creationTimestamp, "Array<string>");
        }

        if (dbxrefs !== undefined) {
            localVarQueryParameters['dbxrefs'] = ObjectSerializer.serialize(dbxrefs, "Array<string>");
        }

        if (description !== undefined) {
            localVarQueryParameters['description'] = ObjectSerializer.serialize(description, "Array<string>");
        }

        if (geneid !== undefined) {
            localVarQueryParameters['geneid'] = ObjectSerializer.serialize(geneid, "Array<string>");
        }

        if (geneidWithVersion !== undefined) {
            localVarQueryParameters['geneid_with_version'] = ObjectSerializer.serialize(geneidWithVersion, "Array<string>");
        }

        if (locations !== undefined) {
            localVarQueryParameters['locations'] = ObjectSerializer.serialize(locations, "Array<GeneLocation>");
        }

        if (name !== undefined) {
            localVarQueryParameters['name'] = ObjectSerializer.serialize(name, "Array<string>");
        }

        if (notes !== undefined) {
            localVarQueryParameters['notes'] = ObjectSerializer.serialize(notes, "Array<string>");
        }

        if (releaseTimestamp !== undefined) {
            localVarQueryParameters['release_timestamp'] = ObjectSerializer.serialize(releaseTimestamp, "Array<string>");
        }

        if (status !== undefined) {
            localVarQueryParameters['status'] = ObjectSerializer.serialize(status, "Array<'archived' | 'deleted' | 'in progress' | 'released'>");
        }

        if (submittedById !== undefined) {
            localVarQueryParameters['submitted_by.@id'] = ObjectSerializer.serialize(submittedById, "Array<string>");
        }

        if (submittedByTitle !== undefined) {
            localVarQueryParameters['submitted_by.title'] = ObjectSerializer.serialize(submittedByTitle, "Array<string>");
        }

        if (submitterComment !== undefined) {
            localVarQueryParameters['submitter_comment'] = ObjectSerializer.serialize(submitterComment, "Array<string>");
        }

        if (summary !== undefined) {
            localVarQueryParameters['summary'] = ObjectSerializer.serialize(summary, "Array<string>");
        }

        if (symbol !== undefined) {
            localVarQueryParameters['symbol'] = ObjectSerializer.serialize(symbol, "Array<string>");
        }

        if (synonyms !== undefined) {
            localVarQueryParameters['synonyms'] = ObjectSerializer.serialize(synonyms, "Array<string>");
        }

        if (taxa !== undefined) {
            localVarQueryParameters['taxa'] = ObjectSerializer.serialize(taxa, "Array<'Homo sapiens' | 'Mus musculus'>");
        }

        if (title !== undefined) {
            localVarQueryParameters['title'] = ObjectSerializer.serialize(title, "Array<string>");
        }

        if (transcriptomeAnnotation !== undefined) {
            localVarQueryParameters['transcriptome_annotation'] = ObjectSerializer.serialize(transcriptomeAnnotation, "Array<'GENCODE 40' | 'GENCODE 41' | 'GENCODE 42' | 'GENCODE 43' | 'GENCODE 44' | 'GENCODE 45' | 'GENCODE M30' | 'GENCODE M31' | 'GENCODE M32' | 'GENCODE M33' | 'GENCODE M34'>");
        }

        if (uuid !== undefined) {
            localVarQueryParameters['uuid'] = ObjectSerializer.serialize(uuid, "Array<string>");
        }

        if (versionNumber !== undefined) {
            localVarQueryParameters['version_number'] = ObjectSerializer.serialize(versionNumber, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: GeneResults;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "GeneResults");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Collection endpoint that accepts various query parameters to filter, sort, and paginate GenomeBrowserAnnotationFile items. Supports filtering on fields within GenomeBrowserAnnotationFile items.
     * @summary List items in the GenomeBrowserAnnotationFile collection.
     * @param frame Constant value. Do not set.
     * @param query Query string for searching.
     * @param limit Maximum number of results to return. Default is 25. Use \&#39;all\&#39; for all results.
     * @param sort Fields to sort results by. Prefix with \&#39;-\&#39; for descending order. Can be repeated for multiple sort fields. Does not work with limit&#x3D;all.
     * @param id Filter by @id
     * @param accession Filter by accession
     * @param aliases Filter by aliases
     * @param alternateAccessions Filter by alternate_accessions
     * @param analysisStepVersion Filter by analysis_step_version
     * @param assembly Filter by assembly
     * @param awardId Filter by award.@id
     * @param awardComponent Filter by award.component
     * @param collections Filter by collections
     * @param contentMd5sum Filter by content_md5sum
     * @param contentType Filter by content_type
     * @param creationTimestamp Filter by creation_timestamp
     * @param dbxrefs Filter by dbxrefs
     * @param derivedFrom Filter by derived_from
     * @param description Filter by description
     * @param documents Filter by documents
     * @param fileFormat Filter by file_format
     * @param fileFormatSpecifications Filter by file_format_specifications
     * @param fileFormatType Filter by file_format_type
     * @param fileSet Filter by file_set
     * @param fileSize Filter by file_size
     * @param geneListFor Filter by gene_list_for
     * @param href Filter by href
     * @param inputFileFor Filter by input_file_for
     * @param integratedIn Filter by integrated_in
     * @param labId Filter by lab.@id
     * @param labTitle Filter by lab.title
     * @param lociListFor Filter by loci_list_for
     * @param md5sum Filter by md5sum
     * @param notes Filter by notes
     * @param releaseTimestamp Filter by release_timestamp
     * @param revokeDetail Filter by revoke_detail
     * @param s3Uri Filter by s3_uri
     * @param status Filter by status
     * @param submittedById Filter by submitted_by.@id
     * @param submittedByTitle Filter by submitted_by.title
     * @param submittedFileName Filter by submitted_file_name
     * @param submitterComment Filter by submitter_comment
     * @param summary Filter by summary
     * @param transcriptomeAnnotation Filter by transcriptome_annotation
     * @param uploadStatus Filter by upload_status
     * @param uuid Filter by uuid
     * @param validationErrorDetail Filter by validation_error_detail
     */
    public async genomeBrowserAnnotationFiles (frame: 'object', query?: string, limit?: Limit, sort?: Array<string>, id?: Array<string>, accession?: Array<string>, aliases?: Array<string>, alternateAccessions?: Array<string>, analysisStepVersion?: Array<string>, assembly?: Array<'GRCh38' | 'GRCm39'>, awardId?: Array<string>, awardComponent?: Array<'affiliate' | 'data analysis' | 'data coordination' | 'functional characterization' | 'mapping' | 'networks' | 'predictive modeling'>, collections?: Array<'ClinGen' | 'ENCODE' | 'GREGoR' | 'IGVF_catalog_beta_v0.1' | 'IGVF_catalog_beta_v0.2' | 'IGVF_catalog_beta_v0.3' | 'IGVF_catalog_beta_v0.4' | 'MaveDB' | 'MPRAbase' | 'Vista'>, contentMd5sum?: Array<string>, contentType?: Array<string>, creationTimestamp?: Array<string>, dbxrefs?: Array<string>, derivedFrom?: Array<string>, description?: Array<string>, documents?: Array<string>, fileFormat?: Array<'bigBed' | 'tabix'>, fileFormatSpecifications?: Array<string>, fileFormatType?: Array<'bed12' | 'bed3' | 'bed3+' | 'bed5' | 'bed6' | 'bed6+' | 'bed9' | 'bed9+' | 'mpra_starr'>, fileSet?: Array<string>, fileSize?: Array<number>, geneListFor?: Array<string>, href?: Array<string>, inputFileFor?: Array<string>, integratedIn?: Array<string>, labId?: Array<string>, labTitle?: Array<string>, lociListFor?: Array<string>, md5sum?: Array<string>, notes?: Array<string>, releaseTimestamp?: Array<string>, revokeDetail?: Array<string>, s3Uri?: Array<string>, status?: Array<'in progress' | 'released' | 'deleted' | 'replaced' | 'revoked' | 'archived'>, submittedById?: Array<string>, submittedByTitle?: Array<string>, submittedFileName?: Array<string>, submitterComment?: Array<string>, summary?: Array<string>, transcriptomeAnnotation?: Array<'GENCODE 40' | 'GENCODE 41' | 'GENCODE 42' | 'GENCODE 43' | 'GENCODE 44' | 'GENCODE 45' | 'GENCODE M30' | 'GENCODE M31' | 'GENCODE M32' | 'GENCODE M33' | 'GENCODE M34'>, uploadStatus?: Array<'pending' | 'file not found' | 'invalidated' | 'validated'>, uuid?: Array<string>, validationErrorDetail?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: GenomeBrowserAnnotationFileResults;  }> {
        const localVarPath = this.basePath + '/genome-browser-annotation-files/@@listing';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'frame' is not null or undefined
        if (frame === null || frame === undefined) {
            throw new Error('Required parameter frame was null or undefined when calling genomeBrowserAnnotationFiles.');
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (frame !== undefined) {
            localVarQueryParameters['frame'] = ObjectSerializer.serialize(frame, "'object'");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "Limit");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "Array<string>");
        }

        if (id !== undefined) {
            localVarQueryParameters['@id'] = ObjectSerializer.serialize(id, "Array<string>");
        }

        if (accession !== undefined) {
            localVarQueryParameters['accession'] = ObjectSerializer.serialize(accession, "Array<string>");
        }

        if (aliases !== undefined) {
            localVarQueryParameters['aliases'] = ObjectSerializer.serialize(aliases, "Array<string>");
        }

        if (alternateAccessions !== undefined) {
            localVarQueryParameters['alternate_accessions'] = ObjectSerializer.serialize(alternateAccessions, "Array<string>");
        }

        if (analysisStepVersion !== undefined) {
            localVarQueryParameters['analysis_step_version'] = ObjectSerializer.serialize(analysisStepVersion, "Array<string>");
        }

        if (assembly !== undefined) {
            localVarQueryParameters['assembly'] = ObjectSerializer.serialize(assembly, "Array<'GRCh38' | 'GRCm39'>");
        }

        if (awardId !== undefined) {
            localVarQueryParameters['award.@id'] = ObjectSerializer.serialize(awardId, "Array<string>");
        }

        if (awardComponent !== undefined) {
            localVarQueryParameters['award.component'] = ObjectSerializer.serialize(awardComponent, "Array<'affiliate' | 'data analysis' | 'data coordination' | 'functional characterization' | 'mapping' | 'networks' | 'predictive modeling'>");
        }

        if (collections !== undefined) {
            localVarQueryParameters['collections'] = ObjectSerializer.serialize(collections, "Array<'ClinGen' | 'ENCODE' | 'GREGoR' | 'IGVF_catalog_beta_v0.1' | 'IGVF_catalog_beta_v0.2' | 'IGVF_catalog_beta_v0.3' | 'IGVF_catalog_beta_v0.4' | 'MaveDB' | 'MPRAbase' | 'Vista'>");
        }

        if (contentMd5sum !== undefined) {
            localVarQueryParameters['content_md5sum'] = ObjectSerializer.serialize(contentMd5sum, "Array<string>");
        }

        if (contentType !== undefined) {
            localVarQueryParameters['content_type'] = ObjectSerializer.serialize(contentType, "Array<string>");
        }

        if (creationTimestamp !== undefined) {
            localVarQueryParameters['creation_timestamp'] = ObjectSerializer.serialize(creationTimestamp, "Array<string>");
        }

        if (dbxrefs !== undefined) {
            localVarQueryParameters['dbxrefs'] = ObjectSerializer.serialize(dbxrefs, "Array<string>");
        }

        if (derivedFrom !== undefined) {
            localVarQueryParameters['derived_from'] = ObjectSerializer.serialize(derivedFrom, "Array<string>");
        }

        if (description !== undefined) {
            localVarQueryParameters['description'] = ObjectSerializer.serialize(description, "Array<string>");
        }

        if (documents !== undefined) {
            localVarQueryParameters['documents'] = ObjectSerializer.serialize(documents, "Array<string>");
        }

        if (fileFormat !== undefined) {
            localVarQueryParameters['file_format'] = ObjectSerializer.serialize(fileFormat, "Array<'bigBed' | 'tabix'>");
        }

        if (fileFormatSpecifications !== undefined) {
            localVarQueryParameters['file_format_specifications'] = ObjectSerializer.serialize(fileFormatSpecifications, "Array<string>");
        }

        if (fileFormatType !== undefined) {
            localVarQueryParameters['file_format_type'] = ObjectSerializer.serialize(fileFormatType, "Array<'bed12' | 'bed3' | 'bed3+' | 'bed5' | 'bed6' | 'bed6+' | 'bed9' | 'bed9+' | 'mpra_starr'>");
        }

        if (fileSet !== undefined) {
            localVarQueryParameters['file_set'] = ObjectSerializer.serialize(fileSet, "Array<string>");
        }

        if (fileSize !== undefined) {
            localVarQueryParameters['file_size'] = ObjectSerializer.serialize(fileSize, "Array<number>");
        }

        if (geneListFor !== undefined) {
            localVarQueryParameters['gene_list_for'] = ObjectSerializer.serialize(geneListFor, "Array<string>");
        }

        if (href !== undefined) {
            localVarQueryParameters['href'] = ObjectSerializer.serialize(href, "Array<string>");
        }

        if (inputFileFor !== undefined) {
            localVarQueryParameters['input_file_for'] = ObjectSerializer.serialize(inputFileFor, "Array<string>");
        }

        if (integratedIn !== undefined) {
            localVarQueryParameters['integrated_in'] = ObjectSerializer.serialize(integratedIn, "Array<string>");
        }

        if (labId !== undefined) {
            localVarQueryParameters['lab.@id'] = ObjectSerializer.serialize(labId, "Array<string>");
        }

        if (labTitle !== undefined) {
            localVarQueryParameters['lab.title'] = ObjectSerializer.serialize(labTitle, "Array<string>");
        }

        if (lociListFor !== undefined) {
            localVarQueryParameters['loci_list_for'] = ObjectSerializer.serialize(lociListFor, "Array<string>");
        }

        if (md5sum !== undefined) {
            localVarQueryParameters['md5sum'] = ObjectSerializer.serialize(md5sum, "Array<string>");
        }

        if (notes !== undefined) {
            localVarQueryParameters['notes'] = ObjectSerializer.serialize(notes, "Array<string>");
        }

        if (releaseTimestamp !== undefined) {
            localVarQueryParameters['release_timestamp'] = ObjectSerializer.serialize(releaseTimestamp, "Array<string>");
        }

        if (revokeDetail !== undefined) {
            localVarQueryParameters['revoke_detail'] = ObjectSerializer.serialize(revokeDetail, "Array<string>");
        }

        if (s3Uri !== undefined) {
            localVarQueryParameters['s3_uri'] = ObjectSerializer.serialize(s3Uri, "Array<string>");
        }

        if (status !== undefined) {
            localVarQueryParameters['status'] = ObjectSerializer.serialize(status, "Array<'in progress' | 'released' | 'deleted' | 'replaced' | 'revoked' | 'archived'>");
        }

        if (submittedById !== undefined) {
            localVarQueryParameters['submitted_by.@id'] = ObjectSerializer.serialize(submittedById, "Array<string>");
        }

        if (submittedByTitle !== undefined) {
            localVarQueryParameters['submitted_by.title'] = ObjectSerializer.serialize(submittedByTitle, "Array<string>");
        }

        if (submittedFileName !== undefined) {
            localVarQueryParameters['submitted_file_name'] = ObjectSerializer.serialize(submittedFileName, "Array<string>");
        }

        if (submitterComment !== undefined) {
            localVarQueryParameters['submitter_comment'] = ObjectSerializer.serialize(submitterComment, "Array<string>");
        }

        if (summary !== undefined) {
            localVarQueryParameters['summary'] = ObjectSerializer.serialize(summary, "Array<string>");
        }

        if (transcriptomeAnnotation !== undefined) {
            localVarQueryParameters['transcriptome_annotation'] = ObjectSerializer.serialize(transcriptomeAnnotation, "Array<'GENCODE 40' | 'GENCODE 41' | 'GENCODE 42' | 'GENCODE 43' | 'GENCODE 44' | 'GENCODE 45' | 'GENCODE M30' | 'GENCODE M31' | 'GENCODE M32' | 'GENCODE M33' | 'GENCODE M34'>");
        }

        if (uploadStatus !== undefined) {
            localVarQueryParameters['upload_status'] = ObjectSerializer.serialize(uploadStatus, "Array<'pending' | 'file not found' | 'invalidated' | 'validated'>");
        }

        if (uuid !== undefined) {
            localVarQueryParameters['uuid'] = ObjectSerializer.serialize(uuid, "Array<string>");
        }

        if (validationErrorDetail !== undefined) {
            localVarQueryParameters['validation_error_detail'] = ObjectSerializer.serialize(validationErrorDetail, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: GenomeBrowserAnnotationFileResults;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "GenomeBrowserAnnotationFileResults");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Retrieve detailed information about a specific item using its @id or uuid.
     * @summary Get item information
     * @param resourceId The unique identifier for the resource i.e. @id (&#x60;/sequence-files/IGVFFI1165AJSO/&#x60;), accession (&#x60;IGVFFI1165AJSO&#x60;) or UUID (&#x60;fffcd64e-af02-4675-8953-7352459ee06a&#x60;).
     * @param frame Constant value. Do not set.
     */
    public async getById (resourceId: string, frame: 'object', options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Item;  }> {
        const localVarPath = this.basePath + '/{resource_id}'
            .replace('{' + 'resource_id' + '}', encodeURIComponent(String(resourceId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'resourceId' is not null or undefined
        if (resourceId === null || resourceId === undefined) {
            throw new Error('Required parameter resourceId was null or undefined when calling getById.');
        }

        // verify required parameter 'frame' is not null or undefined
        if (frame === null || frame === undefined) {
            throw new Error('Required parameter frame was null or undefined when calling getById.');
        }

        if (frame !== undefined) {
            localVarQueryParameters['frame'] = ObjectSerializer.serialize(frame, "'object'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Item;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Item");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Collection endpoint that accepts various query parameters to filter, sort, and paginate HumanDonor items. Supports filtering on fields within HumanDonor items.
     * @summary List items in the HumanDonor collection.
     * @param frame Constant value. Do not set.
     * @param query Query string for searching.
     * @param limit Maximum number of results to return. Default is 25. Use \&#39;all\&#39; for all results.
     * @param sort Fields to sort results by. Prefix with \&#39;-\&#39; for descending order. Can be repeated for multiple sort fields. Does not work with limit&#x3D;all.
     * @param id Filter by @id
     * @param accession Filter by accession
     * @param aliases Filter by aliases
     * @param alternateAccessions Filter by alternate_accessions
     * @param awardId Filter by award.@id
     * @param awardComponent Filter by award.component
     * @param collections Filter by collections
     * @param creationTimestamp Filter by creation_timestamp
     * @param dbxrefs Filter by dbxrefs
     * @param description Filter by description
     * @param documents Filter by documents
     * @param ethnicities Filter by ethnicities
     * @param humanDonorIdentifiers Filter by human_donor_identifiers
     * @param labId Filter by lab.@id
     * @param labTitle Filter by lab.title
     * @param notes Filter by notes
     * @param phenotypicFeaturesId Filter by phenotypic_features.@id
     * @param phenotypicFeaturesFeatureId Filter by phenotypic_features.feature.@id
     * @param phenotypicFeaturesFeatureTermId Filter by phenotypic_features.feature.term_id
     * @param phenotypicFeaturesFeatureTermName Filter by phenotypic_features.feature.term_name
     * @param phenotypicFeaturesObservationDate Filter by phenotypic_features.observation_date
     * @param phenotypicFeaturesQuantityUnits Filter by phenotypic_features.quantity_units
     * @param publicationIdentifiers Filter by publication_identifiers
     * @param publications Filter by publications
     * @param relatedDonorsDonorId Filter by related_donors.donor.@id
     * @param relatedDonorsDonorAccession Filter by related_donors.donor.accession
     * @param releaseTimestamp Filter by release_timestamp
     * @param revokeDetail Filter by revoke_detail
     * @param sex Filter by sex
     * @param status Filter by status
     * @param submittedById Filter by submitted_by.@id
     * @param submittedByTitle Filter by submitted_by.title
     * @param submitterComment Filter by submitter_comment
     * @param summary Filter by summary
     * @param taxa Filter by taxa
     * @param url Filter by url
     * @param uuid Filter by uuid
     * @param virtual Filter by virtual
     */
    public async humanDonors (frame: 'object', query?: string, limit?: Limit, sort?: Array<string>, id?: Array<string>, accession?: Array<string>, aliases?: Array<string>, alternateAccessions?: Array<string>, awardId?: Array<string>, awardComponent?: Array<'affiliate' | 'data analysis' | 'data coordination' | 'functional characterization' | 'mapping' | 'networks' | 'predictive modeling'>, collections?: Array<'ClinGen' | 'ENCODE' | 'GREGoR' | 'IGVF_catalog_beta_v0.1' | 'IGVF_catalog_beta_v0.2' | 'IGVF_catalog_beta_v0.3' | 'IGVF_catalog_beta_v0.4' | 'MaveDB' | 'MPRAbase' | 'Vista'>, creationTimestamp?: Array<string>, dbxrefs?: Array<string>, description?: Array<string>, documents?: Array<string>, ethnicities?: Array<'African American' | 'African Caribbean' | 'Arab' | 'Asian' | 'Black' | 'Black African' | 'Chinese' | 'Colombian' | 'Dai Chinese' | 'Esan' | 'Eskimo' | 'European' | 'Gambian' | 'Han Chinese' | 'Hispanic' | 'Indian' | 'Japanese' | 'Kinh Vietnamese' | 'Luhya' | 'Maasai' | 'Mende' | 'Native Hawaiian' | 'Pacific Islander' | 'Puerto Rican' | 'Yoruba'>, humanDonorIdentifiers?: Array<string>, labId?: Array<string>, labTitle?: Array<string>, notes?: Array<string>, phenotypicFeaturesId?: Array<string>, phenotypicFeaturesFeatureId?: Array<string>, phenotypicFeaturesFeatureTermId?: Array<string>, phenotypicFeaturesFeatureTermName?: Array<string>, phenotypicFeaturesObservationDate?: Array<string>, phenotypicFeaturesQuantityUnits?: Array<'meter' | 'micromole' | 'nanogram' | 'microgram' | 'milligram' | 'gram' | 'kilogram' | 'milli-International Unit per milliliter' | 'picogram per milliliter' | 'nanogram per milliliter' | 'milligram per deciliter'>, publicationIdentifiers?: Array<string>, publications?: Array<string>, relatedDonorsDonorId?: Array<string>, relatedDonorsDonorAccession?: Array<string>, releaseTimestamp?: Array<string>, revokeDetail?: Array<string>, sex?: Array<'male' | 'female' | 'unspecified'>, status?: Array<'in progress' | 'released' | 'deleted' | 'replaced' | 'revoked' | 'archived'>, submittedById?: Array<string>, submittedByTitle?: Array<string>, submitterComment?: Array<string>, summary?: Array<string>, taxa?: Array<'Homo sapiens'>, url?: Array<string>, uuid?: Array<string>, virtual?: Array<boolean>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: HumanDonorResults;  }> {
        const localVarPath = this.basePath + '/human-donors/@@listing';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'frame' is not null or undefined
        if (frame === null || frame === undefined) {
            throw new Error('Required parameter frame was null or undefined when calling humanDonors.');
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (frame !== undefined) {
            localVarQueryParameters['frame'] = ObjectSerializer.serialize(frame, "'object'");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "Limit");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "Array<string>");
        }

        if (id !== undefined) {
            localVarQueryParameters['@id'] = ObjectSerializer.serialize(id, "Array<string>");
        }

        if (accession !== undefined) {
            localVarQueryParameters['accession'] = ObjectSerializer.serialize(accession, "Array<string>");
        }

        if (aliases !== undefined) {
            localVarQueryParameters['aliases'] = ObjectSerializer.serialize(aliases, "Array<string>");
        }

        if (alternateAccessions !== undefined) {
            localVarQueryParameters['alternate_accessions'] = ObjectSerializer.serialize(alternateAccessions, "Array<string>");
        }

        if (awardId !== undefined) {
            localVarQueryParameters['award.@id'] = ObjectSerializer.serialize(awardId, "Array<string>");
        }

        if (awardComponent !== undefined) {
            localVarQueryParameters['award.component'] = ObjectSerializer.serialize(awardComponent, "Array<'affiliate' | 'data analysis' | 'data coordination' | 'functional characterization' | 'mapping' | 'networks' | 'predictive modeling'>");
        }

        if (collections !== undefined) {
            localVarQueryParameters['collections'] = ObjectSerializer.serialize(collections, "Array<'ClinGen' | 'ENCODE' | 'GREGoR' | 'IGVF_catalog_beta_v0.1' | 'IGVF_catalog_beta_v0.2' | 'IGVF_catalog_beta_v0.3' | 'IGVF_catalog_beta_v0.4' | 'MaveDB' | 'MPRAbase' | 'Vista'>");
        }

        if (creationTimestamp !== undefined) {
            localVarQueryParameters['creation_timestamp'] = ObjectSerializer.serialize(creationTimestamp, "Array<string>");
        }

        if (dbxrefs !== undefined) {
            localVarQueryParameters['dbxrefs'] = ObjectSerializer.serialize(dbxrefs, "Array<string>");
        }

        if (description !== undefined) {
            localVarQueryParameters['description'] = ObjectSerializer.serialize(description, "Array<string>");
        }

        if (documents !== undefined) {
            localVarQueryParameters['documents'] = ObjectSerializer.serialize(documents, "Array<string>");
        }

        if (ethnicities !== undefined) {
            localVarQueryParameters['ethnicities'] = ObjectSerializer.serialize(ethnicities, "Array<'African American' | 'African Caribbean' | 'Arab' | 'Asian' | 'Black' | 'Black African' | 'Chinese' | 'Colombian' | 'Dai Chinese' | 'Esan' | 'Eskimo' | 'European' | 'Gambian' | 'Han Chinese' | 'Hispanic' | 'Indian' | 'Japanese' | 'Kinh Vietnamese' | 'Luhya' | 'Maasai' | 'Mende' | 'Native Hawaiian' | 'Pacific Islander' | 'Puerto Rican' | 'Yoruba'>");
        }

        if (humanDonorIdentifiers !== undefined) {
            localVarQueryParameters['human_donor_identifiers'] = ObjectSerializer.serialize(humanDonorIdentifiers, "Array<string>");
        }

        if (labId !== undefined) {
            localVarQueryParameters['lab.@id'] = ObjectSerializer.serialize(labId, "Array<string>");
        }

        if (labTitle !== undefined) {
            localVarQueryParameters['lab.title'] = ObjectSerializer.serialize(labTitle, "Array<string>");
        }

        if (notes !== undefined) {
            localVarQueryParameters['notes'] = ObjectSerializer.serialize(notes, "Array<string>");
        }

        if (phenotypicFeaturesId !== undefined) {
            localVarQueryParameters['phenotypic_features.@id'] = ObjectSerializer.serialize(phenotypicFeaturesId, "Array<string>");
        }

        if (phenotypicFeaturesFeatureId !== undefined) {
            localVarQueryParameters['phenotypic_features.feature.@id'] = ObjectSerializer.serialize(phenotypicFeaturesFeatureId, "Array<string>");
        }

        if (phenotypicFeaturesFeatureTermId !== undefined) {
            localVarQueryParameters['phenotypic_features.feature.term_id'] = ObjectSerializer.serialize(phenotypicFeaturesFeatureTermId, "Array<string>");
        }

        if (phenotypicFeaturesFeatureTermName !== undefined) {
            localVarQueryParameters['phenotypic_features.feature.term_name'] = ObjectSerializer.serialize(phenotypicFeaturesFeatureTermName, "Array<string>");
        }

        if (phenotypicFeaturesObservationDate !== undefined) {
            localVarQueryParameters['phenotypic_features.observation_date'] = ObjectSerializer.serialize(phenotypicFeaturesObservationDate, "Array<string>");
        }

        if (phenotypicFeaturesQuantityUnits !== undefined) {
            localVarQueryParameters['phenotypic_features.quantity_units'] = ObjectSerializer.serialize(phenotypicFeaturesQuantityUnits, "Array<'meter' | 'micromole' | 'nanogram' | 'microgram' | 'milligram' | 'gram' | 'kilogram' | 'milli-International Unit per milliliter' | 'picogram per milliliter' | 'nanogram per milliliter' | 'milligram per deciliter'>");
        }

        if (publicationIdentifiers !== undefined) {
            localVarQueryParameters['publication_identifiers'] = ObjectSerializer.serialize(publicationIdentifiers, "Array<string>");
        }

        if (publications !== undefined) {
            localVarQueryParameters['publications'] = ObjectSerializer.serialize(publications, "Array<string>");
        }

        if (relatedDonorsDonorId !== undefined) {
            localVarQueryParameters['related_donors.donor.@id'] = ObjectSerializer.serialize(relatedDonorsDonorId, "Array<string>");
        }

        if (relatedDonorsDonorAccession !== undefined) {
            localVarQueryParameters['related_donors.donor.accession'] = ObjectSerializer.serialize(relatedDonorsDonorAccession, "Array<string>");
        }

        if (releaseTimestamp !== undefined) {
            localVarQueryParameters['release_timestamp'] = ObjectSerializer.serialize(releaseTimestamp, "Array<string>");
        }

        if (revokeDetail !== undefined) {
            localVarQueryParameters['revoke_detail'] = ObjectSerializer.serialize(revokeDetail, "Array<string>");
        }

        if (sex !== undefined) {
            localVarQueryParameters['sex'] = ObjectSerializer.serialize(sex, "Array<'male' | 'female' | 'unspecified'>");
        }

        if (status !== undefined) {
            localVarQueryParameters['status'] = ObjectSerializer.serialize(status, "Array<'in progress' | 'released' | 'deleted' | 'replaced' | 'revoked' | 'archived'>");
        }

        if (submittedById !== undefined) {
            localVarQueryParameters['submitted_by.@id'] = ObjectSerializer.serialize(submittedById, "Array<string>");
        }

        if (submittedByTitle !== undefined) {
            localVarQueryParameters['submitted_by.title'] = ObjectSerializer.serialize(submittedByTitle, "Array<string>");
        }

        if (submitterComment !== undefined) {
            localVarQueryParameters['submitter_comment'] = ObjectSerializer.serialize(submitterComment, "Array<string>");
        }

        if (summary !== undefined) {
            localVarQueryParameters['summary'] = ObjectSerializer.serialize(summary, "Array<string>");
        }

        if (taxa !== undefined) {
            localVarQueryParameters['taxa'] = ObjectSerializer.serialize(taxa, "Array<'Homo sapiens'>");
        }

        if (url !== undefined) {
            localVarQueryParameters['url'] = ObjectSerializer.serialize(url, "Array<string>");
        }

        if (uuid !== undefined) {
            localVarQueryParameters['uuid'] = ObjectSerializer.serialize(uuid, "Array<string>");
        }

        if (virtual !== undefined) {
            localVarQueryParameters['virtual'] = ObjectSerializer.serialize(virtual, "Array<boolean>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: HumanDonorResults;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "HumanDonorResults");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Collection endpoint that accepts various query parameters to filter, sort, and paginate ImageFile items. Supports filtering on fields within ImageFile items.
     * @summary List items in the ImageFile collection.
     * @param frame Constant value. Do not set.
     * @param query Query string for searching.
     * @param limit Maximum number of results to return. Default is 25. Use \&#39;all\&#39; for all results.
     * @param sort Fields to sort results by. Prefix with \&#39;-\&#39; for descending order. Can be repeated for multiple sort fields. Does not work with limit&#x3D;all.
     * @param id Filter by @id
     * @param accession Filter by accession
     * @param aliases Filter by aliases
     * @param alternateAccessions Filter by alternate_accessions
     * @param analysisStepVersion Filter by analysis_step_version
     * @param awardId Filter by award.@id
     * @param awardComponent Filter by award.component
     * @param collections Filter by collections
     * @param contentMd5sum Filter by content_md5sum
     * @param contentType Filter by content_type
     * @param creationTimestamp Filter by creation_timestamp
     * @param dbxrefs Filter by dbxrefs
     * @param derivedFrom Filter by derived_from
     * @param description Filter by description
     * @param documents Filter by documents
     * @param fileFormat Filter by file_format
     * @param fileFormatSpecifications Filter by file_format_specifications
     * @param fileSet Filter by file_set
     * @param fileSize Filter by file_size
     * @param geneListFor Filter by gene_list_for
     * @param href Filter by href
     * @param inputFileFor Filter by input_file_for
     * @param integratedIn Filter by integrated_in
     * @param labId Filter by lab.@id
     * @param labTitle Filter by lab.title
     * @param lociListFor Filter by loci_list_for
     * @param md5sum Filter by md5sum
     * @param notes Filter by notes
     * @param releaseTimestamp Filter by release_timestamp
     * @param revokeDetail Filter by revoke_detail
     * @param s3Uri Filter by s3_uri
     * @param status Filter by status
     * @param submittedById Filter by submitted_by.@id
     * @param submittedByTitle Filter by submitted_by.title
     * @param submittedFileName Filter by submitted_file_name
     * @param submitterComment Filter by submitter_comment
     * @param summary Filter by summary
     * @param uploadStatus Filter by upload_status
     * @param uuid Filter by uuid
     * @param validationErrorDetail Filter by validation_error_detail
     */
    public async imageFiles (frame: 'object', query?: string, limit?: Limit, sort?: Array<string>, id?: Array<string>, accession?: Array<string>, aliases?: Array<string>, alternateAccessions?: Array<string>, analysisStepVersion?: Array<string>, awardId?: Array<string>, awardComponent?: Array<'affiliate' | 'data analysis' | 'data coordination' | 'functional characterization' | 'mapping' | 'networks' | 'predictive modeling'>, collections?: Array<'ClinGen' | 'ENCODE' | 'GREGoR' | 'IGVF_catalog_beta_v0.1' | 'IGVF_catalog_beta_v0.2' | 'IGVF_catalog_beta_v0.3' | 'IGVF_catalog_beta_v0.4' | 'MaveDB' | 'MPRAbase' | 'Vista'>, contentMd5sum?: Array<string>, contentType?: Array<string>, creationTimestamp?: Array<string>, dbxrefs?: Array<string>, derivedFrom?: Array<string>, description?: Array<string>, documents?: Array<string>, fileFormat?: Array<'jpg' | 'png'>, fileFormatSpecifications?: Array<string>, fileSet?: Array<string>, fileSize?: Array<number>, geneListFor?: Array<string>, href?: Array<string>, inputFileFor?: Array<string>, integratedIn?: Array<string>, labId?: Array<string>, labTitle?: Array<string>, lociListFor?: Array<string>, md5sum?: Array<string>, notes?: Array<string>, releaseTimestamp?: Array<string>, revokeDetail?: Array<string>, s3Uri?: Array<string>, status?: Array<'in progress' | 'released' | 'deleted' | 'replaced' | 'revoked' | 'archived'>, submittedById?: Array<string>, submittedByTitle?: Array<string>, submittedFileName?: Array<string>, submitterComment?: Array<string>, summary?: Array<string>, uploadStatus?: Array<'pending' | 'file not found' | 'invalidated' | 'validated'>, uuid?: Array<string>, validationErrorDetail?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: ImageFileResults;  }> {
        const localVarPath = this.basePath + '/image-files/@@listing';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'frame' is not null or undefined
        if (frame === null || frame === undefined) {
            throw new Error('Required parameter frame was null or undefined when calling imageFiles.');
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (frame !== undefined) {
            localVarQueryParameters['frame'] = ObjectSerializer.serialize(frame, "'object'");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "Limit");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "Array<string>");
        }

        if (id !== undefined) {
            localVarQueryParameters['@id'] = ObjectSerializer.serialize(id, "Array<string>");
        }

        if (accession !== undefined) {
            localVarQueryParameters['accession'] = ObjectSerializer.serialize(accession, "Array<string>");
        }

        if (aliases !== undefined) {
            localVarQueryParameters['aliases'] = ObjectSerializer.serialize(aliases, "Array<string>");
        }

        if (alternateAccessions !== undefined) {
            localVarQueryParameters['alternate_accessions'] = ObjectSerializer.serialize(alternateAccessions, "Array<string>");
        }

        if (analysisStepVersion !== undefined) {
            localVarQueryParameters['analysis_step_version'] = ObjectSerializer.serialize(analysisStepVersion, "Array<string>");
        }

        if (awardId !== undefined) {
            localVarQueryParameters['award.@id'] = ObjectSerializer.serialize(awardId, "Array<string>");
        }

        if (awardComponent !== undefined) {
            localVarQueryParameters['award.component'] = ObjectSerializer.serialize(awardComponent, "Array<'affiliate' | 'data analysis' | 'data coordination' | 'functional characterization' | 'mapping' | 'networks' | 'predictive modeling'>");
        }

        if (collections !== undefined) {
            localVarQueryParameters['collections'] = ObjectSerializer.serialize(collections, "Array<'ClinGen' | 'ENCODE' | 'GREGoR' | 'IGVF_catalog_beta_v0.1' | 'IGVF_catalog_beta_v0.2' | 'IGVF_catalog_beta_v0.3' | 'IGVF_catalog_beta_v0.4' | 'MaveDB' | 'MPRAbase' | 'Vista'>");
        }

        if (contentMd5sum !== undefined) {
            localVarQueryParameters['content_md5sum'] = ObjectSerializer.serialize(contentMd5sum, "Array<string>");
        }

        if (contentType !== undefined) {
            localVarQueryParameters['content_type'] = ObjectSerializer.serialize(contentType, "Array<string>");
        }

        if (creationTimestamp !== undefined) {
            localVarQueryParameters['creation_timestamp'] = ObjectSerializer.serialize(creationTimestamp, "Array<string>");
        }

        if (dbxrefs !== undefined) {
            localVarQueryParameters['dbxrefs'] = ObjectSerializer.serialize(dbxrefs, "Array<string>");
        }

        if (derivedFrom !== undefined) {
            localVarQueryParameters['derived_from'] = ObjectSerializer.serialize(derivedFrom, "Array<string>");
        }

        if (description !== undefined) {
            localVarQueryParameters['description'] = ObjectSerializer.serialize(description, "Array<string>");
        }

        if (documents !== undefined) {
            localVarQueryParameters['documents'] = ObjectSerializer.serialize(documents, "Array<string>");
        }

        if (fileFormat !== undefined) {
            localVarQueryParameters['file_format'] = ObjectSerializer.serialize(fileFormat, "Array<'jpg' | 'png'>");
        }

        if (fileFormatSpecifications !== undefined) {
            localVarQueryParameters['file_format_specifications'] = ObjectSerializer.serialize(fileFormatSpecifications, "Array<string>");
        }

        if (fileSet !== undefined) {
            localVarQueryParameters['file_set'] = ObjectSerializer.serialize(fileSet, "Array<string>");
        }

        if (fileSize !== undefined) {
            localVarQueryParameters['file_size'] = ObjectSerializer.serialize(fileSize, "Array<number>");
        }

        if (geneListFor !== undefined) {
            localVarQueryParameters['gene_list_for'] = ObjectSerializer.serialize(geneListFor, "Array<string>");
        }

        if (href !== undefined) {
            localVarQueryParameters['href'] = ObjectSerializer.serialize(href, "Array<string>");
        }

        if (inputFileFor !== undefined) {
            localVarQueryParameters['input_file_for'] = ObjectSerializer.serialize(inputFileFor, "Array<string>");
        }

        if (integratedIn !== undefined) {
            localVarQueryParameters['integrated_in'] = ObjectSerializer.serialize(integratedIn, "Array<string>");
        }

        if (labId !== undefined) {
            localVarQueryParameters['lab.@id'] = ObjectSerializer.serialize(labId, "Array<string>");
        }

        if (labTitle !== undefined) {
            localVarQueryParameters['lab.title'] = ObjectSerializer.serialize(labTitle, "Array<string>");
        }

        if (lociListFor !== undefined) {
            localVarQueryParameters['loci_list_for'] = ObjectSerializer.serialize(lociListFor, "Array<string>");
        }

        if (md5sum !== undefined) {
            localVarQueryParameters['md5sum'] = ObjectSerializer.serialize(md5sum, "Array<string>");
        }

        if (notes !== undefined) {
            localVarQueryParameters['notes'] = ObjectSerializer.serialize(notes, "Array<string>");
        }

        if (releaseTimestamp !== undefined) {
            localVarQueryParameters['release_timestamp'] = ObjectSerializer.serialize(releaseTimestamp, "Array<string>");
        }

        if (revokeDetail !== undefined) {
            localVarQueryParameters['revoke_detail'] = ObjectSerializer.serialize(revokeDetail, "Array<string>");
        }

        if (s3Uri !== undefined) {
            localVarQueryParameters['s3_uri'] = ObjectSerializer.serialize(s3Uri, "Array<string>");
        }

        if (status !== undefined) {
            localVarQueryParameters['status'] = ObjectSerializer.serialize(status, "Array<'in progress' | 'released' | 'deleted' | 'replaced' | 'revoked' | 'archived'>");
        }

        if (submittedById !== undefined) {
            localVarQueryParameters['submitted_by.@id'] = ObjectSerializer.serialize(submittedById, "Array<string>");
        }

        if (submittedByTitle !== undefined) {
            localVarQueryParameters['submitted_by.title'] = ObjectSerializer.serialize(submittedByTitle, "Array<string>");
        }

        if (submittedFileName !== undefined) {
            localVarQueryParameters['submitted_file_name'] = ObjectSerializer.serialize(submittedFileName, "Array<string>");
        }

        if (submitterComment !== undefined) {
            localVarQueryParameters['submitter_comment'] = ObjectSerializer.serialize(submitterComment, "Array<string>");
        }

        if (summary !== undefined) {
            localVarQueryParameters['summary'] = ObjectSerializer.serialize(summary, "Array<string>");
        }

        if (uploadStatus !== undefined) {
            localVarQueryParameters['upload_status'] = ObjectSerializer.serialize(uploadStatus, "Array<'pending' | 'file not found' | 'invalidated' | 'validated'>");
        }

        if (uuid !== undefined) {
            localVarQueryParameters['uuid'] = ObjectSerializer.serialize(uuid, "Array<string>");
        }

        if (validationErrorDetail !== undefined) {
            localVarQueryParameters['validation_error_detail'] = ObjectSerializer.serialize(validationErrorDetail, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: ImageFileResults;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "ImageFileResults");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Collection endpoint that accepts various query parameters to filter, sort, and paginate Image items. Supports filtering on fields within Image items.
     * @summary List items in the Image collection.
     * @param frame Constant value. Do not set.
     * @param query Query string for searching.
     * @param limit Maximum number of results to return. Default is 25. Use \&#39;all\&#39; for all results.
     * @param sort Fields to sort results by. Prefix with \&#39;-\&#39; for descending order. Can be repeated for multiple sort fields. Does not work with limit&#x3D;all.
     * @param id Filter by @id
     * @param aliases Filter by aliases
     * @param caption Filter by caption
     * @param creationTimestamp Filter by creation_timestamp
     * @param description Filter by description
     * @param downloadUrl Filter by download_url
     * @param notes Filter by notes
     * @param releaseTimestamp Filter by release_timestamp
     * @param status Filter by status
     * @param submittedById Filter by submitted_by.@id
     * @param submittedByTitle Filter by submitted_by.title
     * @param submitterComment Filter by submitter_comment
     * @param summary Filter by summary
     * @param thumbNail Filter by thumb_nail
     * @param uuid Filter by uuid
     */
    public async images (frame: 'object', query?: string, limit?: Limit, sort?: Array<string>, id?: Array<string>, aliases?: Array<string>, caption?: Array<string>, creationTimestamp?: Array<string>, description?: Array<string>, downloadUrl?: Array<string>, notes?: Array<string>, releaseTimestamp?: Array<string>, status?: Array<'archived' | 'deleted' | 'in progress' | 'released'>, submittedById?: Array<string>, submittedByTitle?: Array<string>, submitterComment?: Array<string>, summary?: Array<string>, thumbNail?: Array<string>, uuid?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: ImageResults;  }> {
        const localVarPath = this.basePath + '/images/@@listing';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'frame' is not null or undefined
        if (frame === null || frame === undefined) {
            throw new Error('Required parameter frame was null or undefined when calling images.');
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (frame !== undefined) {
            localVarQueryParameters['frame'] = ObjectSerializer.serialize(frame, "'object'");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "Limit");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "Array<string>");
        }

        if (id !== undefined) {
            localVarQueryParameters['@id'] = ObjectSerializer.serialize(id, "Array<string>");
        }

        if (aliases !== undefined) {
            localVarQueryParameters['aliases'] = ObjectSerializer.serialize(aliases, "Array<string>");
        }

        if (caption !== undefined) {
            localVarQueryParameters['caption'] = ObjectSerializer.serialize(caption, "Array<string>");
        }

        if (creationTimestamp !== undefined) {
            localVarQueryParameters['creation_timestamp'] = ObjectSerializer.serialize(creationTimestamp, "Array<string>");
        }

        if (description !== undefined) {
            localVarQueryParameters['description'] = ObjectSerializer.serialize(description, "Array<string>");
        }

        if (downloadUrl !== undefined) {
            localVarQueryParameters['download_url'] = ObjectSerializer.serialize(downloadUrl, "Array<string>");
        }

        if (notes !== undefined) {
            localVarQueryParameters['notes'] = ObjectSerializer.serialize(notes, "Array<string>");
        }

        if (releaseTimestamp !== undefined) {
            localVarQueryParameters['release_timestamp'] = ObjectSerializer.serialize(releaseTimestamp, "Array<string>");
        }

        if (status !== undefined) {
            localVarQueryParameters['status'] = ObjectSerializer.serialize(status, "Array<'archived' | 'deleted' | 'in progress' | 'released'>");
        }

        if (submittedById !== undefined) {
            localVarQueryParameters['submitted_by.@id'] = ObjectSerializer.serialize(submittedById, "Array<string>");
        }

        if (submittedByTitle !== undefined) {
            localVarQueryParameters['submitted_by.title'] = ObjectSerializer.serialize(submittedByTitle, "Array<string>");
        }

        if (submitterComment !== undefined) {
            localVarQueryParameters['submitter_comment'] = ObjectSerializer.serialize(submitterComment, "Array<string>");
        }

        if (summary !== undefined) {
            localVarQueryParameters['summary'] = ObjectSerializer.serialize(summary, "Array<string>");
        }

        if (thumbNail !== undefined) {
            localVarQueryParameters['thumb_nail'] = ObjectSerializer.serialize(thumbNail, "Array<string>");
        }

        if (uuid !== undefined) {
            localVarQueryParameters['uuid'] = ObjectSerializer.serialize(uuid, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: ImageResults;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "ImageResults");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Collection endpoint that accepts various query parameters to filter, sort, and paginate InVitroSystem items. Supports filtering on fields within InVitroSystem items.
     * @summary List items in the InVitroSystem collection.
     * @param frame Constant value. Do not set.
     * @param query Query string for searching.
     * @param limit Maximum number of results to return. Default is 25. Use \&#39;all\&#39; for all results.
     * @param sort Fields to sort results by. Prefix with \&#39;-\&#39; for descending order. Can be repeated for multiple sort fields. Does not work with limit&#x3D;all.
     * @param id Filter by @id
     * @param accession Filter by accession
     * @param age Filter by age
     * @param ageUnits Filter by age_units
     * @param aliases Filter by aliases
     * @param alternateAccessions Filter by alternate_accessions
     * @param awardId Filter by award.@id
     * @param awardComponent Filter by award.component
     * @param biomarkers Filter by biomarkers
     * @param cellFateChangeProtocol Filter by cell_fate_change_protocol
     * @param cellFateChangeTreatmentsId Filter by cell_fate_change_treatments.@id
     * @param cellFateChangeTreatmentsPurpose Filter by cell_fate_change_treatments.purpose
     * @param cellFateChangeTreatmentsStatus Filter by cell_fate_change_treatments.status
     * @param cellFateChangeTreatmentsSummary Filter by cell_fate_change_treatments.summary
     * @param cellFateChangeTreatmentsTreatmentType Filter by cell_fate_change_treatments.treatment_type
     * @param cellularSubPool Filter by cellular_sub_pool
     * @param classifications Filter by classifications
     * @param collections Filter by collections
     * @param constructLibrarySets Filter by construct_library_sets
     * @param creationTimestamp Filter by creation_timestamp
     * @param dateObtained Filter by date_obtained
     * @param dbxrefs Filter by dbxrefs
     * @param demultiplexedFrom Filter by demultiplexed_from
     * @param demultiplexedTo Filter by demultiplexed_to
     * @param description Filter by description
     * @param diseaseTermsId Filter by disease_terms.@id
     * @param diseaseTermsTermName Filter by disease_terms.term_name
     * @param documents Filter by documents
     * @param donors Filter by donors
     * @param embryonic Filter by embryonic
     * @param fileSetsId Filter by file_sets.@id
     * @param fileSetsAccession Filter by file_sets.accession
     * @param fileSetsAliases Filter by file_sets.aliases
     * @param fileSetsAssayTermTermName Filter by file_sets.assay_term.term_name
     * @param fileSetsLabTitle Filter by file_sets.lab.title
     * @param fileSetsStatus Filter by file_sets.status
     * @param fileSetsSummary Filter by file_sets.summary
     * @param growthMedium Filter by growth_medium
     * @param institutionalCertificatesId Filter by institutional_certificates.@id
     * @param institutionalCertificatesCertificateIdentifier Filter by institutional_certificates.certificate_identifier
     * @param labId Filter by lab.@id
     * @param labTitle Filter by lab.title
     * @param lotId Filter by lot_id
     * @param lowerBoundAge Filter by lower_bound_age
     * @param lowerBoundAgeInHours Filter by lower_bound_age_in_hours
     * @param modificationsId Filter by modifications.@id
     * @param modificationsStatus Filter by modifications.status
     * @param modificationsSummary Filter by modifications.summary
     * @param moi Filter by moi
     * @param multiplexedInId Filter by multiplexed_in.@id
     * @param multiplexedInAccession Filter by multiplexed_in.accession
     * @param notes Filter by notes
     * @param nucleicAcidDelivery Filter by nucleic_acid_delivery
     * @param originOf Filter by origin_of
     * @param originatedFromId Filter by originated_from.@id
     * @param originatedFromAccession Filter by originated_from.accession
     * @param partOf Filter by part_of
     * @param parts Filter by parts
     * @param passageNumber Filter by passage_number
     * @param pooledFrom Filter by pooled_from
     * @param pooledIn Filter by pooled_in
     * @param productId Filter by product_id
     * @param protocols Filter by protocols
     * @param publicationIdentifiers Filter by publication_identifiers
     * @param publications Filter by publications
     * @param releaseTimestamp Filter by release_timestamp
     * @param revokeDetail Filter by revoke_detail
     * @param sampleTermsId Filter by sample_terms.@id
     * @param sampleTermsTermName Filter by sample_terms.term_name
     * @param sex Filter by sex
     * @param sortedFractions Filter by sorted_fractions
     * @param sortedFromId Filter by sorted_from.@id
     * @param sortedFromAccession Filter by sorted_from.accession
     * @param sortedFromDetail Filter by sorted_from_detail
     * @param sourcesId Filter by sources.@id
     * @param startingAmount Filter by starting_amount
     * @param startingAmountUnits Filter by starting_amount_units
     * @param status Filter by status
     * @param submittedById Filter by submitted_by.@id
     * @param submittedByTitle Filter by submitted_by.title
     * @param submitterComment Filter by submitter_comment
     * @param summary Filter by summary
     * @param targetedSampleTerm Filter by targeted_sample_term
     * @param taxa Filter by taxa
     * @param timePostChange Filter by time_post_change
     * @param timePostChangeUnits Filter by time_post_change_units
     * @param timePostLibraryDelivery Filter by time_post_library_delivery
     * @param timePostLibraryDeliveryUnits Filter by time_post_library_delivery_units
     * @param treatmentsId Filter by treatments.@id
     * @param treatmentsPurpose Filter by treatments.purpose
     * @param treatmentsStatus Filter by treatments.status
     * @param treatmentsSummary Filter by treatments.summary
     * @param treatmentsTreatmentType Filter by treatments.treatment_type
     * @param upperBoundAge Filter by upper_bound_age
     * @param upperBoundAgeInHours Filter by upper_bound_age_in_hours
     * @param url Filter by url
     * @param uuid Filter by uuid
     * @param virtual Filter by virtual
     */
    public async inVitroSystems (frame: 'object', query?: string, limit?: Limit, sort?: Array<string>, id?: Array<string>, accession?: Array<string>, age?: Array<string>, ageUnits?: Array<'minute' | 'hour' | 'day' | 'week' | 'month' | 'year'>, aliases?: Array<string>, alternateAccessions?: Array<string>, awardId?: Array<string>, awardComponent?: Array<'affiliate' | 'data analysis' | 'data coordination' | 'functional characterization' | 'mapping' | 'networks' | 'predictive modeling'>, biomarkers?: Array<string>, cellFateChangeProtocol?: Array<string>, cellFateChangeTreatmentsId?: Array<string>, cellFateChangeTreatmentsPurpose?: Array<'activation' | 'agonist' | 'antagonist' | 'control' | 'differentiation' | 'de-differentiation' | 'perturbation' | 'selection' | 'stimulation'>, cellFateChangeTreatmentsStatus?: Array<'archived' | 'deleted' | 'in progress' | 'released'>, cellFateChangeTreatmentsSummary?: Array<string>, cellFateChangeTreatmentsTreatmentType?: Array<'chemical' | 'protein' | 'environmental'>, cellularSubPool?: Array<string>, classifications?: Array<'organoid' | 'gastruloid' | 'embryoid' | 'cell line' | 'differentiated cell specimen' | 'reprogrammed cell specimen' | 'pooled cell specimen'>, collections?: Array<'ClinGen' | 'ENCODE' | 'GREGoR' | 'IGVF_catalog_beta_v0.1' | 'IGVF_catalog_beta_v0.2' | 'IGVF_catalog_beta_v0.3' | 'IGVF_catalog_beta_v0.4' | 'MaveDB' | 'MPRAbase' | 'Vista'>, constructLibrarySets?: Array<string>, creationTimestamp?: Array<string>, dateObtained?: Array<string>, dbxrefs?: Array<string>, demultiplexedFrom?: Array<string>, demultiplexedTo?: Array<string>, description?: Array<string>, diseaseTermsId?: Array<string>, diseaseTermsTermName?: Array<string>, documents?: Array<string>, donors?: Array<string>, embryonic?: Array<boolean>, fileSetsId?: Array<string>, fileSetsAccession?: Array<string>, fileSetsAliases?: Array<string>, fileSetsAssayTermTermName?: Array<string>, fileSetsLabTitle?: Array<string>, fileSetsStatus?: Array<'in progress' | 'released' | 'deleted' | 'replaced' | 'revoked' | 'archived'>, fileSetsSummary?: Array<string>, growthMedium?: Array<'DMEM with serum' | 'DMEM without serum' | 'SMBM with serum' | 'SMBM without serum'>, institutionalCertificatesId?: Array<string>, institutionalCertificatesCertificateIdentifier?: Array<string>, labId?: Array<string>, labTitle?: Array<string>, lotId?: Array<string>, lowerBoundAge?: Array<number>, lowerBoundAgeInHours?: Array<number>, modificationsId?: Array<string>, modificationsStatus?: Array<'archived' | 'deleted' | 'in progress' | 'released'>, modificationsSummary?: Array<string>, moi?: Array<number>, multiplexedInId?: Array<string>, multiplexedInAccession?: Array<string>, notes?: Array<string>, nucleicAcidDelivery?: Array<'transfection' | 'adenoviral transduction' | 'lentiviral transduction'>, originOf?: Array<string>, originatedFromId?: Array<string>, originatedFromAccession?: Array<string>, partOf?: Array<string>, parts?: Array<string>, passageNumber?: Array<number>, pooledFrom?: Array<string>, pooledIn?: Array<string>, productId?: Array<string>, protocols?: Array<string>, publicationIdentifiers?: Array<string>, publications?: Array<string>, releaseTimestamp?: Array<string>, revokeDetail?: Array<string>, sampleTermsId?: Array<string>, sampleTermsTermName?: Array<string>, sex?: Array<'female' | 'male' | 'mixed' | 'unspecified'>, sortedFractions?: Array<string>, sortedFromId?: Array<string>, sortedFromAccession?: Array<string>, sortedFromDetail?: Array<string>, sourcesId?: Array<string>, startingAmount?: Array<number>, startingAmountUnits?: Array<'cells' | 'cells/ml' | 'g' | 'items' | 'mg' | 'whole animals' | 'whole embryos' | 'μg' | 'ng'>, status?: Array<'in progress' | 'released' | 'deleted' | 'replaced' | 'revoked' | 'archived'>, submittedById?: Array<string>, submittedByTitle?: Array<string>, submitterComment?: Array<string>, summary?: Array<string>, targetedSampleTerm?: Array<string>, taxa?: Array<'Homo sapiens' | 'Mus musculus'>, timePostChange?: Array<number>, timePostChangeUnits?: Array<'minute' | 'hour' | 'day' | 'week' | 'month'>, timePostLibraryDelivery?: Array<number>, timePostLibraryDeliveryUnits?: Array<'minute' | 'hour' | 'day' | 'week' | 'month'>, treatmentsId?: Array<string>, treatmentsPurpose?: Array<'activation' | 'agonist' | 'antagonist' | 'control' | 'differentiation' | 'de-differentiation' | 'perturbation' | 'selection' | 'stimulation'>, treatmentsStatus?: Array<'archived' | 'deleted' | 'in progress' | 'released'>, treatmentsSummary?: Array<string>, treatmentsTreatmentType?: Array<'chemical' | 'protein' | 'environmental'>, upperBoundAge?: Array<number>, upperBoundAgeInHours?: Array<number>, url?: Array<string>, uuid?: Array<string>, virtual?: Array<boolean>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: InVitroSystemResults;  }> {
        const localVarPath = this.basePath + '/in-vitro-systems/@@listing';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'frame' is not null or undefined
        if (frame === null || frame === undefined) {
            throw new Error('Required parameter frame was null or undefined when calling inVitroSystems.');
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (frame !== undefined) {
            localVarQueryParameters['frame'] = ObjectSerializer.serialize(frame, "'object'");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "Limit");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "Array<string>");
        }

        if (id !== undefined) {
            localVarQueryParameters['@id'] = ObjectSerializer.serialize(id, "Array<string>");
        }

        if (accession !== undefined) {
            localVarQueryParameters['accession'] = ObjectSerializer.serialize(accession, "Array<string>");
        }

        if (age !== undefined) {
            localVarQueryParameters['age'] = ObjectSerializer.serialize(age, "Array<string>");
        }

        if (ageUnits !== undefined) {
            localVarQueryParameters['age_units'] = ObjectSerializer.serialize(ageUnits, "Array<'minute' | 'hour' | 'day' | 'week' | 'month' | 'year'>");
        }

        if (aliases !== undefined) {
            localVarQueryParameters['aliases'] = ObjectSerializer.serialize(aliases, "Array<string>");
        }

        if (alternateAccessions !== undefined) {
            localVarQueryParameters['alternate_accessions'] = ObjectSerializer.serialize(alternateAccessions, "Array<string>");
        }

        if (awardId !== undefined) {
            localVarQueryParameters['award.@id'] = ObjectSerializer.serialize(awardId, "Array<string>");
        }

        if (awardComponent !== undefined) {
            localVarQueryParameters['award.component'] = ObjectSerializer.serialize(awardComponent, "Array<'affiliate' | 'data analysis' | 'data coordination' | 'functional characterization' | 'mapping' | 'networks' | 'predictive modeling'>");
        }

        if (biomarkers !== undefined) {
            localVarQueryParameters['biomarkers'] = ObjectSerializer.serialize(biomarkers, "Array<string>");
        }

        if (cellFateChangeProtocol !== undefined) {
            localVarQueryParameters['cell_fate_change_protocol'] = ObjectSerializer.serialize(cellFateChangeProtocol, "Array<string>");
        }

        if (cellFateChangeTreatmentsId !== undefined) {
            localVarQueryParameters['cell_fate_change_treatments.@id'] = ObjectSerializer.serialize(cellFateChangeTreatmentsId, "Array<string>");
        }

        if (cellFateChangeTreatmentsPurpose !== undefined) {
            localVarQueryParameters['cell_fate_change_treatments.purpose'] = ObjectSerializer.serialize(cellFateChangeTreatmentsPurpose, "Array<'activation' | 'agonist' | 'antagonist' | 'control' | 'differentiation' | 'de-differentiation' | 'perturbation' | 'selection' | 'stimulation'>");
        }

        if (cellFateChangeTreatmentsStatus !== undefined) {
            localVarQueryParameters['cell_fate_change_treatments.status'] = ObjectSerializer.serialize(cellFateChangeTreatmentsStatus, "Array<'archived' | 'deleted' | 'in progress' | 'released'>");
        }

        if (cellFateChangeTreatmentsSummary !== undefined) {
            localVarQueryParameters['cell_fate_change_treatments.summary'] = ObjectSerializer.serialize(cellFateChangeTreatmentsSummary, "Array<string>");
        }

        if (cellFateChangeTreatmentsTreatmentType !== undefined) {
            localVarQueryParameters['cell_fate_change_treatments.treatment_type'] = ObjectSerializer.serialize(cellFateChangeTreatmentsTreatmentType, "Array<'chemical' | 'protein' | 'environmental'>");
        }

        if (cellularSubPool !== undefined) {
            localVarQueryParameters['cellular_sub_pool'] = ObjectSerializer.serialize(cellularSubPool, "Array<string>");
        }

        if (classifications !== undefined) {
            localVarQueryParameters['classifications'] = ObjectSerializer.serialize(classifications, "Array<'organoid' | 'gastruloid' | 'embryoid' | 'cell line' | 'differentiated cell specimen' | 'reprogrammed cell specimen' | 'pooled cell specimen'>");
        }

        if (collections !== undefined) {
            localVarQueryParameters['collections'] = ObjectSerializer.serialize(collections, "Array<'ClinGen' | 'ENCODE' | 'GREGoR' | 'IGVF_catalog_beta_v0.1' | 'IGVF_catalog_beta_v0.2' | 'IGVF_catalog_beta_v0.3' | 'IGVF_catalog_beta_v0.4' | 'MaveDB' | 'MPRAbase' | 'Vista'>");
        }

        if (constructLibrarySets !== undefined) {
            localVarQueryParameters['construct_library_sets'] = ObjectSerializer.serialize(constructLibrarySets, "Array<string>");
        }

        if (creationTimestamp !== undefined) {
            localVarQueryParameters['creation_timestamp'] = ObjectSerializer.serialize(creationTimestamp, "Array<string>");
        }

        if (dateObtained !== undefined) {
            localVarQueryParameters['date_obtained'] = ObjectSerializer.serialize(dateObtained, "Array<string>");
        }

        if (dbxrefs !== undefined) {
            localVarQueryParameters['dbxrefs'] = ObjectSerializer.serialize(dbxrefs, "Array<string>");
        }

        if (demultiplexedFrom !== undefined) {
            localVarQueryParameters['demultiplexed_from'] = ObjectSerializer.serialize(demultiplexedFrom, "Array<string>");
        }

        if (demultiplexedTo !== undefined) {
            localVarQueryParameters['demultiplexed_to'] = ObjectSerializer.serialize(demultiplexedTo, "Array<string>");
        }

        if (description !== undefined) {
            localVarQueryParameters['description'] = ObjectSerializer.serialize(description, "Array<string>");
        }

        if (diseaseTermsId !== undefined) {
            localVarQueryParameters['disease_terms.@id'] = ObjectSerializer.serialize(diseaseTermsId, "Array<string>");
        }

        if (diseaseTermsTermName !== undefined) {
            localVarQueryParameters['disease_terms.term_name'] = ObjectSerializer.serialize(diseaseTermsTermName, "Array<string>");
        }

        if (documents !== undefined) {
            localVarQueryParameters['documents'] = ObjectSerializer.serialize(documents, "Array<string>");
        }

        if (donors !== undefined) {
            localVarQueryParameters['donors'] = ObjectSerializer.serialize(donors, "Array<string>");
        }

        if (embryonic !== undefined) {
            localVarQueryParameters['embryonic'] = ObjectSerializer.serialize(embryonic, "Array<boolean>");
        }

        if (fileSetsId !== undefined) {
            localVarQueryParameters['file_sets.@id'] = ObjectSerializer.serialize(fileSetsId, "Array<string>");
        }

        if (fileSetsAccession !== undefined) {
            localVarQueryParameters['file_sets.accession'] = ObjectSerializer.serialize(fileSetsAccession, "Array<string>");
        }

        if (fileSetsAliases !== undefined) {
            localVarQueryParameters['file_sets.aliases'] = ObjectSerializer.serialize(fileSetsAliases, "Array<string>");
        }

        if (fileSetsAssayTermTermName !== undefined) {
            localVarQueryParameters['file_sets.assay_term.term_name'] = ObjectSerializer.serialize(fileSetsAssayTermTermName, "Array<string>");
        }

        if (fileSetsLabTitle !== undefined) {
            localVarQueryParameters['file_sets.lab.title'] = ObjectSerializer.serialize(fileSetsLabTitle, "Array<string>");
        }

        if (fileSetsStatus !== undefined) {
            localVarQueryParameters['file_sets.status'] = ObjectSerializer.serialize(fileSetsStatus, "Array<'in progress' | 'released' | 'deleted' | 'replaced' | 'revoked' | 'archived'>");
        }

        if (fileSetsSummary !== undefined) {
            localVarQueryParameters['file_sets.summary'] = ObjectSerializer.serialize(fileSetsSummary, "Array<string>");
        }

        if (growthMedium !== undefined) {
            localVarQueryParameters['growth_medium'] = ObjectSerializer.serialize(growthMedium, "Array<'DMEM with serum' | 'DMEM without serum' | 'SMBM with serum' | 'SMBM without serum'>");
        }

        if (institutionalCertificatesId !== undefined) {
            localVarQueryParameters['institutional_certificates.@id'] = ObjectSerializer.serialize(institutionalCertificatesId, "Array<string>");
        }

        if (institutionalCertificatesCertificateIdentifier !== undefined) {
            localVarQueryParameters['institutional_certificates.certificate_identifier'] = ObjectSerializer.serialize(institutionalCertificatesCertificateIdentifier, "Array<string>");
        }

        if (labId !== undefined) {
            localVarQueryParameters['lab.@id'] = ObjectSerializer.serialize(labId, "Array<string>");
        }

        if (labTitle !== undefined) {
            localVarQueryParameters['lab.title'] = ObjectSerializer.serialize(labTitle, "Array<string>");
        }

        if (lotId !== undefined) {
            localVarQueryParameters['lot_id'] = ObjectSerializer.serialize(lotId, "Array<string>");
        }

        if (lowerBoundAge !== undefined) {
            localVarQueryParameters['lower_bound_age'] = ObjectSerializer.serialize(lowerBoundAge, "Array<number>");
        }

        if (lowerBoundAgeInHours !== undefined) {
            localVarQueryParameters['lower_bound_age_in_hours'] = ObjectSerializer.serialize(lowerBoundAgeInHours, "Array<number>");
        }

        if (modificationsId !== undefined) {
            localVarQueryParameters['modifications.@id'] = ObjectSerializer.serialize(modificationsId, "Array<string>");
        }

        if (modificationsStatus !== undefined) {
            localVarQueryParameters['modifications.status'] = ObjectSerializer.serialize(modificationsStatus, "Array<'archived' | 'deleted' | 'in progress' | 'released'>");
        }

        if (modificationsSummary !== undefined) {
            localVarQueryParameters['modifications.summary'] = ObjectSerializer.serialize(modificationsSummary, "Array<string>");
        }

        if (moi !== undefined) {
            localVarQueryParameters['moi'] = ObjectSerializer.serialize(moi, "Array<number>");
        }

        if (multiplexedInId !== undefined) {
            localVarQueryParameters['multiplexed_in.@id'] = ObjectSerializer.serialize(multiplexedInId, "Array<string>");
        }

        if (multiplexedInAccession !== undefined) {
            localVarQueryParameters['multiplexed_in.accession'] = ObjectSerializer.serialize(multiplexedInAccession, "Array<string>");
        }

        if (notes !== undefined) {
            localVarQueryParameters['notes'] = ObjectSerializer.serialize(notes, "Array<string>");
        }

        if (nucleicAcidDelivery !== undefined) {
            localVarQueryParameters['nucleic_acid_delivery'] = ObjectSerializer.serialize(nucleicAcidDelivery, "Array<'transfection' | 'adenoviral transduction' | 'lentiviral transduction'>");
        }

        if (originOf !== undefined) {
            localVarQueryParameters['origin_of'] = ObjectSerializer.serialize(originOf, "Array<string>");
        }

        if (originatedFromId !== undefined) {
            localVarQueryParameters['originated_from.@id'] = ObjectSerializer.serialize(originatedFromId, "Array<string>");
        }

        if (originatedFromAccession !== undefined) {
            localVarQueryParameters['originated_from.accession'] = ObjectSerializer.serialize(originatedFromAccession, "Array<string>");
        }

        if (partOf !== undefined) {
            localVarQueryParameters['part_of'] = ObjectSerializer.serialize(partOf, "Array<string>");
        }

        if (parts !== undefined) {
            localVarQueryParameters['parts'] = ObjectSerializer.serialize(parts, "Array<string>");
        }

        if (passageNumber !== undefined) {
            localVarQueryParameters['passage_number'] = ObjectSerializer.serialize(passageNumber, "Array<number>");
        }

        if (pooledFrom !== undefined) {
            localVarQueryParameters['pooled_from'] = ObjectSerializer.serialize(pooledFrom, "Array<string>");
        }

        if (pooledIn !== undefined) {
            localVarQueryParameters['pooled_in'] = ObjectSerializer.serialize(pooledIn, "Array<string>");
        }

        if (productId !== undefined) {
            localVarQueryParameters['product_id'] = ObjectSerializer.serialize(productId, "Array<string>");
        }

        if (protocols !== undefined) {
            localVarQueryParameters['protocols'] = ObjectSerializer.serialize(protocols, "Array<string>");
        }

        if (publicationIdentifiers !== undefined) {
            localVarQueryParameters['publication_identifiers'] = ObjectSerializer.serialize(publicationIdentifiers, "Array<string>");
        }

        if (publications !== undefined) {
            localVarQueryParameters['publications'] = ObjectSerializer.serialize(publications, "Array<string>");
        }

        if (releaseTimestamp !== undefined) {
            localVarQueryParameters['release_timestamp'] = ObjectSerializer.serialize(releaseTimestamp, "Array<string>");
        }

        if (revokeDetail !== undefined) {
            localVarQueryParameters['revoke_detail'] = ObjectSerializer.serialize(revokeDetail, "Array<string>");
        }

        if (sampleTermsId !== undefined) {
            localVarQueryParameters['sample_terms.@id'] = ObjectSerializer.serialize(sampleTermsId, "Array<string>");
        }

        if (sampleTermsTermName !== undefined) {
            localVarQueryParameters['sample_terms.term_name'] = ObjectSerializer.serialize(sampleTermsTermName, "Array<string>");
        }

        if (sex !== undefined) {
            localVarQueryParameters['sex'] = ObjectSerializer.serialize(sex, "Array<'female' | 'male' | 'mixed' | 'unspecified'>");
        }

        if (sortedFractions !== undefined) {
            localVarQueryParameters['sorted_fractions'] = ObjectSerializer.serialize(sortedFractions, "Array<string>");
        }

        if (sortedFromId !== undefined) {
            localVarQueryParameters['sorted_from.@id'] = ObjectSerializer.serialize(sortedFromId, "Array<string>");
        }

        if (sortedFromAccession !== undefined) {
            localVarQueryParameters['sorted_from.accession'] = ObjectSerializer.serialize(sortedFromAccession, "Array<string>");
        }

        if (sortedFromDetail !== undefined) {
            localVarQueryParameters['sorted_from_detail'] = ObjectSerializer.serialize(sortedFromDetail, "Array<string>");
        }

        if (sourcesId !== undefined) {
            localVarQueryParameters['sources.@id'] = ObjectSerializer.serialize(sourcesId, "Array<string>");
        }

        if (startingAmount !== undefined) {
            localVarQueryParameters['starting_amount'] = ObjectSerializer.serialize(startingAmount, "Array<number>");
        }

        if (startingAmountUnits !== undefined) {
            localVarQueryParameters['starting_amount_units'] = ObjectSerializer.serialize(startingAmountUnits, "Array<'cells' | 'cells/ml' | 'g' | 'items' | 'mg' | 'whole animals' | 'whole embryos' | 'μg' | 'ng'>");
        }

        if (status !== undefined) {
            localVarQueryParameters['status'] = ObjectSerializer.serialize(status, "Array<'in progress' | 'released' | 'deleted' | 'replaced' | 'revoked' | 'archived'>");
        }

        if (submittedById !== undefined) {
            localVarQueryParameters['submitted_by.@id'] = ObjectSerializer.serialize(submittedById, "Array<string>");
        }

        if (submittedByTitle !== undefined) {
            localVarQueryParameters['submitted_by.title'] = ObjectSerializer.serialize(submittedByTitle, "Array<string>");
        }

        if (submitterComment !== undefined) {
            localVarQueryParameters['submitter_comment'] = ObjectSerializer.serialize(submitterComment, "Array<string>");
        }

        if (summary !== undefined) {
            localVarQueryParameters['summary'] = ObjectSerializer.serialize(summary, "Array<string>");
        }

        if (targetedSampleTerm !== undefined) {
            localVarQueryParameters['targeted_sample_term'] = ObjectSerializer.serialize(targetedSampleTerm, "Array<string>");
        }

        if (taxa !== undefined) {
            localVarQueryParameters['taxa'] = ObjectSerializer.serialize(taxa, "Array<'Homo sapiens' | 'Mus musculus'>");
        }

        if (timePostChange !== undefined) {
            localVarQueryParameters['time_post_change'] = ObjectSerializer.serialize(timePostChange, "Array<number>");
        }

        if (timePostChangeUnits !== undefined) {
            localVarQueryParameters['time_post_change_units'] = ObjectSerializer.serialize(timePostChangeUnits, "Array<'minute' | 'hour' | 'day' | 'week' | 'month'>");
        }

        if (timePostLibraryDelivery !== undefined) {
            localVarQueryParameters['time_post_library_delivery'] = ObjectSerializer.serialize(timePostLibraryDelivery, "Array<number>");
        }

        if (timePostLibraryDeliveryUnits !== undefined) {
            localVarQueryParameters['time_post_library_delivery_units'] = ObjectSerializer.serialize(timePostLibraryDeliveryUnits, "Array<'minute' | 'hour' | 'day' | 'week' | 'month'>");
        }

        if (treatmentsId !== undefined) {
            localVarQueryParameters['treatments.@id'] = ObjectSerializer.serialize(treatmentsId, "Array<string>");
        }

        if (treatmentsPurpose !== undefined) {
            localVarQueryParameters['treatments.purpose'] = ObjectSerializer.serialize(treatmentsPurpose, "Array<'activation' | 'agonist' | 'antagonist' | 'control' | 'differentiation' | 'de-differentiation' | 'perturbation' | 'selection' | 'stimulation'>");
        }

        if (treatmentsStatus !== undefined) {
            localVarQueryParameters['treatments.status'] = ObjectSerializer.serialize(treatmentsStatus, "Array<'archived' | 'deleted' | 'in progress' | 'released'>");
        }

        if (treatmentsSummary !== undefined) {
            localVarQueryParameters['treatments.summary'] = ObjectSerializer.serialize(treatmentsSummary, "Array<string>");
        }

        if (treatmentsTreatmentType !== undefined) {
            localVarQueryParameters['treatments.treatment_type'] = ObjectSerializer.serialize(treatmentsTreatmentType, "Array<'chemical' | 'protein' | 'environmental'>");
        }

        if (upperBoundAge !== undefined) {
            localVarQueryParameters['upper_bound_age'] = ObjectSerializer.serialize(upperBoundAge, "Array<number>");
        }

        if (upperBoundAgeInHours !== undefined) {
            localVarQueryParameters['upper_bound_age_in_hours'] = ObjectSerializer.serialize(upperBoundAgeInHours, "Array<number>");
        }

        if (url !== undefined) {
            localVarQueryParameters['url'] = ObjectSerializer.serialize(url, "Array<string>");
        }

        if (uuid !== undefined) {
            localVarQueryParameters['uuid'] = ObjectSerializer.serialize(uuid, "Array<string>");
        }

        if (virtual !== undefined) {
            localVarQueryParameters['virtual'] = ObjectSerializer.serialize(virtual, "Array<boolean>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: InVitroSystemResults;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "InVitroSystemResults");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Collection endpoint that accepts various query parameters to filter, sort, and paginate InstitutionalCertificate items. Supports filtering on fields within InstitutionalCertificate items.
     * @summary List items in the InstitutionalCertificate collection.
     * @param frame Constant value. Do not set.
     * @param query Query string for searching.
     * @param limit Maximum number of results to return. Default is 25. Use \&#39;all\&#39; for all results.
     * @param sort Fields to sort results by. Prefix with \&#39;-\&#39; for descending order. Can be repeated for multiple sort fields. Does not work with limit&#x3D;all.
     * @param id Filter by @id
     * @param aliases Filter by aliases
     * @param awardId Filter by award.@id
     * @param awardComponent Filter by award.component
     * @param certificateIdentifier Filter by certificate_identifier
     * @param controlledAccess Filter by controlled_access
     * @param creationTimestamp Filter by creation_timestamp
     * @param dataUseLimitation Filter by data_use_limitation
     * @param dataUseLimitationModifiers Filter by data_use_limitation_modifiers
     * @param description Filter by description
     * @param labId Filter by lab.@id
     * @param labTitle Filter by lab.title
     * @param notes Filter by notes
     * @param releaseTimestamp Filter by release_timestamp
     * @param samples Filter by samples
     * @param status Filter by status
     * @param submittedById Filter by submitted_by.@id
     * @param submittedByTitle Filter by submitted_by.title
     * @param submitterComment Filter by submitter_comment
     * @param summary Filter by summary
     * @param urls Filter by urls
     * @param uuid Filter by uuid
     */
    public async institutionalCertificates (frame: 'object', query?: string, limit?: Limit, sort?: Array<string>, id?: Array<string>, aliases?: Array<string>, awardId?: Array<string>, awardComponent?: Array<'affiliate' | 'data analysis' | 'data coordination' | 'functional characterization' | 'mapping' | 'networks' | 'predictive modeling'>, certificateIdentifier?: Array<string>, controlledAccess?: Array<boolean>, creationTimestamp?: Array<string>, dataUseLimitation?: Array<'DS' | 'GRU' | 'HMB' | 'other'>, dataUseLimitationModifiers?: Array<'COL' | 'GSO' | 'IRB' | 'MDS' | 'NPU' | 'PUB'>, description?: Array<string>, labId?: Array<string>, labTitle?: Array<string>, notes?: Array<string>, releaseTimestamp?: Array<string>, samples?: Array<string>, status?: Array<'archived' | 'deleted' | 'in progress' | 'released'>, submittedById?: Array<string>, submittedByTitle?: Array<string>, submitterComment?: Array<string>, summary?: Array<string>, urls?: Array<string>, uuid?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: InstitutionalCertificateResults;  }> {
        const localVarPath = this.basePath + '/institutional-certificates/@@listing';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'frame' is not null or undefined
        if (frame === null || frame === undefined) {
            throw new Error('Required parameter frame was null or undefined when calling institutionalCertificates.');
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (frame !== undefined) {
            localVarQueryParameters['frame'] = ObjectSerializer.serialize(frame, "'object'");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "Limit");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "Array<string>");
        }

        if (id !== undefined) {
            localVarQueryParameters['@id'] = ObjectSerializer.serialize(id, "Array<string>");
        }

        if (aliases !== undefined) {
            localVarQueryParameters['aliases'] = ObjectSerializer.serialize(aliases, "Array<string>");
        }

        if (awardId !== undefined) {
            localVarQueryParameters['award.@id'] = ObjectSerializer.serialize(awardId, "Array<string>");
        }

        if (awardComponent !== undefined) {
            localVarQueryParameters['award.component'] = ObjectSerializer.serialize(awardComponent, "Array<'affiliate' | 'data analysis' | 'data coordination' | 'functional characterization' | 'mapping' | 'networks' | 'predictive modeling'>");
        }

        if (certificateIdentifier !== undefined) {
            localVarQueryParameters['certificate_identifier'] = ObjectSerializer.serialize(certificateIdentifier, "Array<string>");
        }

        if (controlledAccess !== undefined) {
            localVarQueryParameters['controlled_access'] = ObjectSerializer.serialize(controlledAccess, "Array<boolean>");
        }

        if (creationTimestamp !== undefined) {
            localVarQueryParameters['creation_timestamp'] = ObjectSerializer.serialize(creationTimestamp, "Array<string>");
        }

        if (dataUseLimitation !== undefined) {
            localVarQueryParameters['data_use_limitation'] = ObjectSerializer.serialize(dataUseLimitation, "Array<'DS' | 'GRU' | 'HMB' | 'other'>");
        }

        if (dataUseLimitationModifiers !== undefined) {
            localVarQueryParameters['data_use_limitation_modifiers'] = ObjectSerializer.serialize(dataUseLimitationModifiers, "Array<'COL' | 'GSO' | 'IRB' | 'MDS' | 'NPU' | 'PUB'>");
        }

        if (description !== undefined) {
            localVarQueryParameters['description'] = ObjectSerializer.serialize(description, "Array<string>");
        }

        if (labId !== undefined) {
            localVarQueryParameters['lab.@id'] = ObjectSerializer.serialize(labId, "Array<string>");
        }

        if (labTitle !== undefined) {
            localVarQueryParameters['lab.title'] = ObjectSerializer.serialize(labTitle, "Array<string>");
        }

        if (notes !== undefined) {
            localVarQueryParameters['notes'] = ObjectSerializer.serialize(notes, "Array<string>");
        }

        if (releaseTimestamp !== undefined) {
            localVarQueryParameters['release_timestamp'] = ObjectSerializer.serialize(releaseTimestamp, "Array<string>");
        }

        if (samples !== undefined) {
            localVarQueryParameters['samples'] = ObjectSerializer.serialize(samples, "Array<string>");
        }

        if (status !== undefined) {
            localVarQueryParameters['status'] = ObjectSerializer.serialize(status, "Array<'archived' | 'deleted' | 'in progress' | 'released'>");
        }

        if (submittedById !== undefined) {
            localVarQueryParameters['submitted_by.@id'] = ObjectSerializer.serialize(submittedById, "Array<string>");
        }

        if (submittedByTitle !== undefined) {
            localVarQueryParameters['submitted_by.title'] = ObjectSerializer.serialize(submittedByTitle, "Array<string>");
        }

        if (submitterComment !== undefined) {
            localVarQueryParameters['submitter_comment'] = ObjectSerializer.serialize(submitterComment, "Array<string>");
        }

        if (summary !== undefined) {
            localVarQueryParameters['summary'] = ObjectSerializer.serialize(summary, "Array<string>");
        }

        if (urls !== undefined) {
            localVarQueryParameters['urls'] = ObjectSerializer.serialize(urls, "Array<string>");
        }

        if (uuid !== undefined) {
            localVarQueryParameters['uuid'] = ObjectSerializer.serialize(uuid, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: InstitutionalCertificateResults;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "InstitutionalCertificateResults");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Collection endpoint that accepts various query parameters to filter, sort, and paginate Lab items. Supports filtering on fields within Lab items.
     * @summary List items in the Lab collection.
     * @param frame Constant value. Do not set.
     * @param query Query string for searching.
     * @param limit Maximum number of results to return. Default is 25. Use \&#39;all\&#39; for all results.
     * @param sort Fields to sort results by. Prefix with \&#39;-\&#39; for descending order. Can be repeated for multiple sort fields. Does not work with limit&#x3D;all.
     * @param id Filter by @id
     * @param aliases Filter by aliases
     * @param awardsId Filter by awards.@id
     * @param awardsComponent Filter by awards.component
     * @param awardsName Filter by awards.name
     * @param creationTimestamp Filter by creation_timestamp
     * @param description Filter by description
     * @param instituteLabel Filter by institute_label
     * @param name Filter by name
     * @param notes Filter by notes
     * @param pi Filter by pi
     * @param status Filter by status
     * @param submittedById Filter by submitted_by.@id
     * @param submittedByTitle Filter by submitted_by.title
     * @param submitterComment Filter by submitter_comment
     * @param summary Filter by summary
     * @param title Filter by title
     * @param url Filter by url
     * @param uuid Filter by uuid
     */
    public async labs (frame: 'object', query?: string, limit?: Limit, sort?: Array<string>, id?: Array<string>, aliases?: Array<string>, awardsId?: Array<string>, awardsComponent?: Array<'affiliate' | 'data analysis' | 'data coordination' | 'functional characterization' | 'mapping' | 'networks' | 'predictive modeling'>, awardsName?: Array<string>, creationTimestamp?: Array<string>, description?: Array<string>, instituteLabel?: Array<string>, name?: Array<string>, notes?: Array<string>, pi?: Array<string>, status?: Array<'current' | 'deleted' | 'disabled'>, submittedById?: Array<string>, submittedByTitle?: Array<string>, submitterComment?: Array<string>, summary?: Array<string>, title?: Array<string>, url?: Array<string>, uuid?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: LabResults;  }> {
        const localVarPath = this.basePath + '/labs/@@listing';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'frame' is not null or undefined
        if (frame === null || frame === undefined) {
            throw new Error('Required parameter frame was null or undefined when calling labs.');
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (frame !== undefined) {
            localVarQueryParameters['frame'] = ObjectSerializer.serialize(frame, "'object'");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "Limit");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "Array<string>");
        }

        if (id !== undefined) {
            localVarQueryParameters['@id'] = ObjectSerializer.serialize(id, "Array<string>");
        }

        if (aliases !== undefined) {
            localVarQueryParameters['aliases'] = ObjectSerializer.serialize(aliases, "Array<string>");
        }

        if (awardsId !== undefined) {
            localVarQueryParameters['awards.@id'] = ObjectSerializer.serialize(awardsId, "Array<string>");
        }

        if (awardsComponent !== undefined) {
            localVarQueryParameters['awards.component'] = ObjectSerializer.serialize(awardsComponent, "Array<'affiliate' | 'data analysis' | 'data coordination' | 'functional characterization' | 'mapping' | 'networks' | 'predictive modeling'>");
        }

        if (awardsName !== undefined) {
            localVarQueryParameters['awards.name'] = ObjectSerializer.serialize(awardsName, "Array<string>");
        }

        if (creationTimestamp !== undefined) {
            localVarQueryParameters['creation_timestamp'] = ObjectSerializer.serialize(creationTimestamp, "Array<string>");
        }

        if (description !== undefined) {
            localVarQueryParameters['description'] = ObjectSerializer.serialize(description, "Array<string>");
        }

        if (instituteLabel !== undefined) {
            localVarQueryParameters['institute_label'] = ObjectSerializer.serialize(instituteLabel, "Array<string>");
        }

        if (name !== undefined) {
            localVarQueryParameters['name'] = ObjectSerializer.serialize(name, "Array<string>");
        }

        if (notes !== undefined) {
            localVarQueryParameters['notes'] = ObjectSerializer.serialize(notes, "Array<string>");
        }

        if (pi !== undefined) {
            localVarQueryParameters['pi'] = ObjectSerializer.serialize(pi, "Array<string>");
        }

        if (status !== undefined) {
            localVarQueryParameters['status'] = ObjectSerializer.serialize(status, "Array<'current' | 'deleted' | 'disabled'>");
        }

        if (submittedById !== undefined) {
            localVarQueryParameters['submitted_by.@id'] = ObjectSerializer.serialize(submittedById, "Array<string>");
        }

        if (submittedByTitle !== undefined) {
            localVarQueryParameters['submitted_by.title'] = ObjectSerializer.serialize(submittedByTitle, "Array<string>");
        }

        if (submitterComment !== undefined) {
            localVarQueryParameters['submitter_comment'] = ObjectSerializer.serialize(submitterComment, "Array<string>");
        }

        if (summary !== undefined) {
            localVarQueryParameters['summary'] = ObjectSerializer.serialize(summary, "Array<string>");
        }

        if (title !== undefined) {
            localVarQueryParameters['title'] = ObjectSerializer.serialize(title, "Array<string>");
        }

        if (url !== undefined) {
            localVarQueryParameters['url'] = ObjectSerializer.serialize(url, "Array<string>");
        }

        if (uuid !== undefined) {
            localVarQueryParameters['uuid'] = ObjectSerializer.serialize(uuid, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: LabResults;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "LabResults");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Collection endpoint that accepts various query parameters to filter, sort, and paginate MatrixFile items. Supports filtering on fields within MatrixFile items.
     * @summary List items in the MatrixFile collection.
     * @param frame Constant value. Do not set.
     * @param query Query string for searching.
     * @param limit Maximum number of results to return. Default is 25. Use \&#39;all\&#39; for all results.
     * @param sort Fields to sort results by. Prefix with \&#39;-\&#39; for descending order. Can be repeated for multiple sort fields. Does not work with limit&#x3D;all.
     * @param id Filter by @id
     * @param accession Filter by accession
     * @param aliases Filter by aliases
     * @param alternateAccessions Filter by alternate_accessions
     * @param analysisStepVersion Filter by analysis_step_version
     * @param awardId Filter by award.@id
     * @param awardComponent Filter by award.component
     * @param collections Filter by collections
     * @param contentMd5sum Filter by content_md5sum
     * @param contentSummary Filter by content_summary
     * @param contentType Filter by content_type
     * @param creationTimestamp Filter by creation_timestamp
     * @param dbxrefs Filter by dbxrefs
     * @param derivedFrom Filter by derived_from
     * @param description Filter by description
     * @param dimension1 Filter by dimension1
     * @param dimension2 Filter by dimension2
     * @param documents Filter by documents
     * @param fileFormat Filter by file_format
     * @param fileFormatSpecifications Filter by file_format_specifications
     * @param fileSet Filter by file_set
     * @param fileSize Filter by file_size
     * @param geneListFor Filter by gene_list_for
     * @param href Filter by href
     * @param inputFileFor Filter by input_file_for
     * @param integratedIn Filter by integrated_in
     * @param labId Filter by lab.@id
     * @param labTitle Filter by lab.title
     * @param lociListFor Filter by loci_list_for
     * @param md5sum Filter by md5sum
     * @param notes Filter by notes
     * @param referenceFiles Filter by reference_files
     * @param releaseTimestamp Filter by release_timestamp
     * @param revokeDetail Filter by revoke_detail
     * @param s3Uri Filter by s3_uri
     * @param status Filter by status
     * @param submittedById Filter by submitted_by.@id
     * @param submittedByTitle Filter by submitted_by.title
     * @param submittedFileName Filter by submitted_file_name
     * @param submitterComment Filter by submitter_comment
     * @param summary Filter by summary
     * @param uploadStatus Filter by upload_status
     * @param uuid Filter by uuid
     * @param validationErrorDetail Filter by validation_error_detail
     */
    public async matrixFiles (frame: 'object', query?: string, limit?: Limit, sort?: Array<string>, id?: Array<string>, accession?: Array<string>, aliases?: Array<string>, alternateAccessions?: Array<string>, analysisStepVersion?: Array<string>, awardId?: Array<string>, awardComponent?: Array<'affiliate' | 'data analysis' | 'data coordination' | 'functional characterization' | 'mapping' | 'networks' | 'predictive modeling'>, collections?: Array<'ClinGen' | 'ENCODE' | 'GREGoR' | 'IGVF_catalog_beta_v0.1' | 'IGVF_catalog_beta_v0.2' | 'IGVF_catalog_beta_v0.3' | 'IGVF_catalog_beta_v0.4' | 'MaveDB' | 'MPRAbase' | 'Vista'>, contentMd5sum?: Array<string>, contentSummary?: Array<string>, contentType?: Array<string>, creationTimestamp?: Array<string>, dbxrefs?: Array<string>, derivedFrom?: Array<string>, description?: Array<string>, dimension1?: Array<'cell' | 'fragment' | 'gene' | 'time' | 'treatment' | 'variant' | 'genomic position'>, dimension2?: Array<'cell' | 'fragment' | 'gene' | 'time' | 'treatment' | 'variant' | 'genomic position'>, documents?: Array<string>, fileFormat?: Array<'h5ad' | 'hdf5' | 'mtx' | 'tar' | 'hic'>, fileFormatSpecifications?: Array<string>, fileSet?: Array<string>, fileSize?: Array<number>, geneListFor?: Array<string>, href?: Array<string>, inputFileFor?: Array<string>, integratedIn?: Array<string>, labId?: Array<string>, labTitle?: Array<string>, lociListFor?: Array<string>, md5sum?: Array<string>, notes?: Array<string>, referenceFiles?: Array<string>, releaseTimestamp?: Array<string>, revokeDetail?: Array<string>, s3Uri?: Array<string>, status?: Array<'in progress' | 'released' | 'deleted' | 'replaced' | 'revoked' | 'archived'>, submittedById?: Array<string>, submittedByTitle?: Array<string>, submittedFileName?: Array<string>, submitterComment?: Array<string>, summary?: Array<string>, uploadStatus?: Array<'pending' | 'file not found' | 'invalidated' | 'validated'>, uuid?: Array<string>, validationErrorDetail?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: MatrixFileResults;  }> {
        const localVarPath = this.basePath + '/matrix-files/@@listing';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'frame' is not null or undefined
        if (frame === null || frame === undefined) {
            throw new Error('Required parameter frame was null or undefined when calling matrixFiles.');
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (frame !== undefined) {
            localVarQueryParameters['frame'] = ObjectSerializer.serialize(frame, "'object'");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "Limit");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "Array<string>");
        }

        if (id !== undefined) {
            localVarQueryParameters['@id'] = ObjectSerializer.serialize(id, "Array<string>");
        }

        if (accession !== undefined) {
            localVarQueryParameters['accession'] = ObjectSerializer.serialize(accession, "Array<string>");
        }

        if (aliases !== undefined) {
            localVarQueryParameters['aliases'] = ObjectSerializer.serialize(aliases, "Array<string>");
        }

        if (alternateAccessions !== undefined) {
            localVarQueryParameters['alternate_accessions'] = ObjectSerializer.serialize(alternateAccessions, "Array<string>");
        }

        if (analysisStepVersion !== undefined) {
            localVarQueryParameters['analysis_step_version'] = ObjectSerializer.serialize(analysisStepVersion, "Array<string>");
        }

        if (awardId !== undefined) {
            localVarQueryParameters['award.@id'] = ObjectSerializer.serialize(awardId, "Array<string>");
        }

        if (awardComponent !== undefined) {
            localVarQueryParameters['award.component'] = ObjectSerializer.serialize(awardComponent, "Array<'affiliate' | 'data analysis' | 'data coordination' | 'functional characterization' | 'mapping' | 'networks' | 'predictive modeling'>");
        }

        if (collections !== undefined) {
            localVarQueryParameters['collections'] = ObjectSerializer.serialize(collections, "Array<'ClinGen' | 'ENCODE' | 'GREGoR' | 'IGVF_catalog_beta_v0.1' | 'IGVF_catalog_beta_v0.2' | 'IGVF_catalog_beta_v0.3' | 'IGVF_catalog_beta_v0.4' | 'MaveDB' | 'MPRAbase' | 'Vista'>");
        }

        if (contentMd5sum !== undefined) {
            localVarQueryParameters['content_md5sum'] = ObjectSerializer.serialize(contentMd5sum, "Array<string>");
        }

        if (contentSummary !== undefined) {
            localVarQueryParameters['content_summary'] = ObjectSerializer.serialize(contentSummary, "Array<string>");
        }

        if (contentType !== undefined) {
            localVarQueryParameters['content_type'] = ObjectSerializer.serialize(contentType, "Array<string>");
        }

        if (creationTimestamp !== undefined) {
            localVarQueryParameters['creation_timestamp'] = ObjectSerializer.serialize(creationTimestamp, "Array<string>");
        }

        if (dbxrefs !== undefined) {
            localVarQueryParameters['dbxrefs'] = ObjectSerializer.serialize(dbxrefs, "Array<string>");
        }

        if (derivedFrom !== undefined) {
            localVarQueryParameters['derived_from'] = ObjectSerializer.serialize(derivedFrom, "Array<string>");
        }

        if (description !== undefined) {
            localVarQueryParameters['description'] = ObjectSerializer.serialize(description, "Array<string>");
        }

        if (dimension1 !== undefined) {
            localVarQueryParameters['dimension1'] = ObjectSerializer.serialize(dimension1, "Array<'cell' | 'fragment' | 'gene' | 'time' | 'treatment' | 'variant' | 'genomic position'>");
        }

        if (dimension2 !== undefined) {
            localVarQueryParameters['dimension2'] = ObjectSerializer.serialize(dimension2, "Array<'cell' | 'fragment' | 'gene' | 'time' | 'treatment' | 'variant' | 'genomic position'>");
        }

        if (documents !== undefined) {
            localVarQueryParameters['documents'] = ObjectSerializer.serialize(documents, "Array<string>");
        }

        if (fileFormat !== undefined) {
            localVarQueryParameters['file_format'] = ObjectSerializer.serialize(fileFormat, "Array<'h5ad' | 'hdf5' | 'mtx' | 'tar' | 'hic'>");
        }

        if (fileFormatSpecifications !== undefined) {
            localVarQueryParameters['file_format_specifications'] = ObjectSerializer.serialize(fileFormatSpecifications, "Array<string>");
        }

        if (fileSet !== undefined) {
            localVarQueryParameters['file_set'] = ObjectSerializer.serialize(fileSet, "Array<string>");
        }

        if (fileSize !== undefined) {
            localVarQueryParameters['file_size'] = ObjectSerializer.serialize(fileSize, "Array<number>");
        }

        if (geneListFor !== undefined) {
            localVarQueryParameters['gene_list_for'] = ObjectSerializer.serialize(geneListFor, "Array<string>");
        }

        if (href !== undefined) {
            localVarQueryParameters['href'] = ObjectSerializer.serialize(href, "Array<string>");
        }

        if (inputFileFor !== undefined) {
            localVarQueryParameters['input_file_for'] = ObjectSerializer.serialize(inputFileFor, "Array<string>");
        }

        if (integratedIn !== undefined) {
            localVarQueryParameters['integrated_in'] = ObjectSerializer.serialize(integratedIn, "Array<string>");
        }

        if (labId !== undefined) {
            localVarQueryParameters['lab.@id'] = ObjectSerializer.serialize(labId, "Array<string>");
        }

        if (labTitle !== undefined) {
            localVarQueryParameters['lab.title'] = ObjectSerializer.serialize(labTitle, "Array<string>");
        }

        if (lociListFor !== undefined) {
            localVarQueryParameters['loci_list_for'] = ObjectSerializer.serialize(lociListFor, "Array<string>");
        }

        if (md5sum !== undefined) {
            localVarQueryParameters['md5sum'] = ObjectSerializer.serialize(md5sum, "Array<string>");
        }

        if (notes !== undefined) {
            localVarQueryParameters['notes'] = ObjectSerializer.serialize(notes, "Array<string>");
        }

        if (referenceFiles !== undefined) {
            localVarQueryParameters['reference_files'] = ObjectSerializer.serialize(referenceFiles, "Array<string>");
        }

        if (releaseTimestamp !== undefined) {
            localVarQueryParameters['release_timestamp'] = ObjectSerializer.serialize(releaseTimestamp, "Array<string>");
        }

        if (revokeDetail !== undefined) {
            localVarQueryParameters['revoke_detail'] = ObjectSerializer.serialize(revokeDetail, "Array<string>");
        }

        if (s3Uri !== undefined) {
            localVarQueryParameters['s3_uri'] = ObjectSerializer.serialize(s3Uri, "Array<string>");
        }

        if (status !== undefined) {
            localVarQueryParameters['status'] = ObjectSerializer.serialize(status, "Array<'in progress' | 'released' | 'deleted' | 'replaced' | 'revoked' | 'archived'>");
        }

        if (submittedById !== undefined) {
            localVarQueryParameters['submitted_by.@id'] = ObjectSerializer.serialize(submittedById, "Array<string>");
        }

        if (submittedByTitle !== undefined) {
            localVarQueryParameters['submitted_by.title'] = ObjectSerializer.serialize(submittedByTitle, "Array<string>");
        }

        if (submittedFileName !== undefined) {
            localVarQueryParameters['submitted_file_name'] = ObjectSerializer.serialize(submittedFileName, "Array<string>");
        }

        if (submitterComment !== undefined) {
            localVarQueryParameters['submitter_comment'] = ObjectSerializer.serialize(submitterComment, "Array<string>");
        }

        if (summary !== undefined) {
            localVarQueryParameters['summary'] = ObjectSerializer.serialize(summary, "Array<string>");
        }

        if (uploadStatus !== undefined) {
            localVarQueryParameters['upload_status'] = ObjectSerializer.serialize(uploadStatus, "Array<'pending' | 'file not found' | 'invalidated' | 'validated'>");
        }

        if (uuid !== undefined) {
            localVarQueryParameters['uuid'] = ObjectSerializer.serialize(uuid, "Array<string>");
        }

        if (validationErrorDetail !== undefined) {
            localVarQueryParameters['validation_error_detail'] = ObjectSerializer.serialize(validationErrorDetail, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: MatrixFileResults;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "MatrixFileResults");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Collection endpoint that accepts various query parameters to filter, sort, and paginate MeasurementSet items. Supports filtering on fields within MeasurementSet items.
     * @summary List items in the MeasurementSet collection.
     * @param frame Constant value. Do not set.
     * @param query Query string for searching.
     * @param limit Maximum number of results to return. Default is 25. Use \&#39;all\&#39; for all results.
     * @param sort Fields to sort results by. Prefix with \&#39;-\&#39; for descending order. Can be repeated for multiple sort fields. Does not work with limit&#x3D;all.
     * @param id Filter by @id
     * @param accession Filter by accession
     * @param aliases Filter by aliases
     * @param alternateAccessions Filter by alternate_accessions
     * @param assayTermId Filter by assay_term.@id
     * @param assayTermTermName Filter by assay_term.term_name
     * @param auxiliarySetsId Filter by auxiliary_sets.@id
     * @param auxiliarySetsAccession Filter by auxiliary_sets.accession
     * @param auxiliarySetsAliases Filter by auxiliary_sets.aliases
     * @param auxiliarySetsFileSetType Filter by auxiliary_sets.file_set_type
     * @param awardId Filter by award.@id
     * @param awardComponent Filter by award.component
     * @param awardContactPiId Filter by award.contact_pi.@id
     * @param awardContactPiTitle Filter by award.contact_pi.title
     * @param awardTitle Filter by award.title
     * @param collections Filter by collections
     * @param controlFileSetsId Filter by control_file_sets.@id
     * @param controlFileSetsAccession Filter by control_file_sets.accession
     * @param controlFileSetsAliases Filter by control_file_sets.aliases
     * @param controlForId Filter by control_for.@id
     * @param controlForAccession Filter by control_for.accession
     * @param controlForAliases Filter by control_for.aliases
     * @param creationTimestamp Filter by creation_timestamp
     * @param dbxrefs Filter by dbxrefs
     * @param description Filter by description
     * @param documents Filter by documents
     * @param donorsId Filter by donors.@id
     * @param donorsAccession Filter by donors.accession
     * @param donorsAliases Filter by donors.aliases
     * @param donorsSex Filter by donors.sex
     * @param donorsStatus Filter by donors.status
     * @param donorsTaxa Filter by donors.taxa
     * @param externalImageUrl Filter by external_image_url
     * @param fileSetType Filter by file_set_type
     * @param filesId Filter by files.@id
     * @param filesAccession Filter by files.accession
     * @param filesAliases Filter by files.aliases
     * @param filesContentType Filter by files.content_type
     * @param filesCreationTimestamp Filter by files.creation_timestamp
     * @param filesFileFormat Filter by files.file_format
     * @param filesFileSize Filter by files.file_size
     * @param filesHref Filter by files.href
     * @param filesS3Uri Filter by files.s3_uri
     * @param filesSequencingPlatformId Filter by files.sequencing_platform.@id
     * @param filesSequencingPlatformTermName Filter by files.sequencing_platform.term_name
     * @param filesSubmittedFileName Filter by files.submitted_file_name
     * @param filesUploadStatus Filter by files.upload_status
     * @param inputFileSetFor Filter by input_file_set_for
     * @param labId Filter by lab.@id
     * @param labTitle Filter by lab.title
     * @param libraryConstructionPlatformId Filter by library_construction_platform.@id
     * @param libraryConstructionPlatformTermName Filter by library_construction_platform.term_name
     * @param multiomeSize Filter by multiome_size
     * @param notes Filter by notes
     * @param preferredAssayTitle Filter by preferred_assay_title
     * @param protocols Filter by protocols
     * @param publicationIdentifiers Filter by publication_identifiers
     * @param publications Filter by publications
     * @param relatedMultiomeDatasetsId Filter by related_multiome_datasets.@id
     * @param relatedMultiomeDatasetsAccession Filter by related_multiome_datasets.accession
     * @param releaseTimestamp Filter by release_timestamp
     * @param revokeDetail Filter by revoke_detail
     * @param samplesId Filter by samples.@id
     * @param samplesAccession Filter by samples.accession
     * @param samplesAliases Filter by samples.aliases
     * @param samplesCellFateChangeTreatmentsId Filter by samples.cell_fate_change_treatments.@id
     * @param samplesCellFateChangeTreatmentsPurpose Filter by samples.cell_fate_change_treatments.purpose
     * @param samplesCellFateChangeTreatmentsSummary Filter by samples.cell_fate_change_treatments.summary
     * @param samplesCellFateChangeTreatmentsTreatmentType Filter by samples.cell_fate_change_treatments.treatment_type
     * @param samplesClassifications Filter by samples.classifications
     * @param samplesConstructLibrarySetsId Filter by samples.construct_library_sets.@id
     * @param samplesConstructLibrarySetsAccession Filter by samples.construct_library_sets.accession
     * @param samplesConstructLibrarySetsFileSetType Filter by samples.construct_library_sets.file_set_type
     * @param samplesConstructLibrarySetsSmallScaleGeneListId Filter by samples.construct_library_sets.small_scale_gene_list.@id
     * @param samplesConstructLibrarySetsSmallScaleGeneListGeneid Filter by samples.construct_library_sets.small_scale_gene_list.geneid
     * @param samplesConstructLibrarySetsSmallScaleGeneListName Filter by samples.construct_library_sets.small_scale_gene_list.name
     * @param samplesConstructLibrarySetsSmallScaleGeneListSummary Filter by samples.construct_library_sets.small_scale_gene_list.summary
     * @param samplesConstructLibrarySetsSmallScaleGeneListSymbol Filter by samples.construct_library_sets.small_scale_gene_list.symbol
     * @param samplesConstructLibrarySetsSummary Filter by samples.construct_library_sets.summary
     * @param samplesDiseaseTermsId Filter by samples.disease_terms.@id
     * @param samplesDiseaseTermsTermName Filter by samples.disease_terms.term_name
     * @param samplesModificationsId Filter by samples.modifications.@id
     * @param samplesSampleTermsId Filter by samples.sample_terms.@id
     * @param samplesSampleTermsAliases Filter by samples.sample_terms.aliases
     * @param samplesSampleTermsStatus Filter by samples.sample_terms.status
     * @param samplesSampleTermsSummary Filter by samples.sample_terms.summary
     * @param samplesSampleTermsTermName Filter by samples.sample_terms.term_name
     * @param samplesStatus Filter by samples.status
     * @param samplesSummary Filter by samples.summary
     * @param samplesTargetedSampleTermId Filter by samples.targeted_sample_term.@id
     * @param samplesTargetedSampleTermTermName Filter by samples.targeted_sample_term.term_name
     * @param samplesTaxa Filter by samples.taxa
     * @param samplesTreatmentsId Filter by samples.treatments.@id
     * @param samplesTreatmentsPurpose Filter by samples.treatments.purpose
     * @param samplesTreatmentsSummary Filter by samples.treatments.summary
     * @param samplesTreatmentsTreatmentType Filter by samples.treatments.treatment_type
     * @param sequencingLibraryTypes Filter by sequencing_library_types
     * @param status Filter by status
     * @param submittedById Filter by submitted_by.@id
     * @param submittedByTitle Filter by submitted_by.title
     * @param submittedFilesTimestamp Filter by submitted_files_timestamp
     * @param submitterComment Filter by submitter_comment
     * @param summary Filter by summary
     * @param targetedGenesId Filter by targeted_genes.@id
     * @param targetedGenesGeneid Filter by targeted_genes.geneid
     * @param targetedGenesName Filter by targeted_genes.name
     * @param targetedGenesSymbol Filter by targeted_genes.symbol
     * @param targetedGenesSynonyms Filter by targeted_genes.synonyms
     * @param uuid Filter by uuid
     */
    public async measurementSets (frame: 'object', query?: string, limit?: Limit, sort?: Array<string>, id?: Array<string>, accession?: Array<string>, aliases?: Array<string>, alternateAccessions?: Array<string>, assayTermId?: Array<string>, assayTermTermName?: Array<string>, auxiliarySetsId?: Array<string>, auxiliarySetsAccession?: Array<string>, auxiliarySetsAliases?: Array<string>, auxiliarySetsFileSetType?: Array<'cell hashing' | 'cell sorting' | 'circularized RNA barcode detection' | 'gRNA sequencing' | 'oligo-conjugated lipids' | 'quantification DNA barcode sequencing' | 'variant sequencing'>, awardId?: Array<string>, awardComponent?: Array<'affiliate' | 'data analysis' | 'data coordination' | 'functional characterization' | 'mapping' | 'networks' | 'predictive modeling'>, awardContactPiId?: Array<string>, awardContactPiTitle?: Array<string>, awardTitle?: Array<string>, collections?: Array<'ClinGen' | 'ENCODE' | 'GREGoR' | 'IGVF_catalog_beta_v0.1' | 'IGVF_catalog_beta_v0.2' | 'IGVF_catalog_beta_v0.3' | 'IGVF_catalog_beta_v0.4' | 'MaveDB' | 'MPRAbase' | 'Vista'>, controlFileSetsId?: Array<string>, controlFileSetsAccession?: Array<string>, controlFileSetsAliases?: Array<string>, controlForId?: Array<string>, controlForAccession?: Array<string>, controlForAliases?: Array<string>, creationTimestamp?: Array<string>, dbxrefs?: Array<string>, description?: Array<string>, documents?: Array<string>, donorsId?: Array<string>, donorsAccession?: Array<string>, donorsAliases?: Array<string>, donorsSex?: Array<'male' | 'female' | 'unspecified'>, donorsStatus?: Array<'in progress' | 'released' | 'deleted' | 'replaced' | 'revoked' | 'archived'>, donorsTaxa?: Array<string>, externalImageUrl?: Array<string>, fileSetType?: Array<'experimental data'>, filesId?: Array<string>, filesAccession?: Array<string>, filesAliases?: Array<string>, filesContentType?: Array<string>, filesCreationTimestamp?: Array<string>, filesFileFormat?: Array<string>, filesFileSize?: Array<number>, filesHref?: Array<string>, filesS3Uri?: Array<string>, filesSequencingPlatformId?: Array<string>, filesSequencingPlatformTermName?: Array<string>, filesSubmittedFileName?: Array<string>, filesUploadStatus?: Array<'pending' | 'file not found' | 'invalidated' | 'validated'>, inputFileSetFor?: Array<string>, labId?: Array<string>, labTitle?: Array<string>, libraryConstructionPlatformId?: Array<string>, libraryConstructionPlatformTermName?: Array<string>, multiomeSize?: Array<number>, notes?: Array<string>, preferredAssayTitle?: Array<'10x multiome' | '10x multiome with MULTI-seq' | 'AAV-MPRA' | 'ATAC-seq' | 'CERES-seq' | 'Cell painting' | 'CRISPR FlowFISH' | 'DOGMA-seq' | 'Histone ChIP-seq' | 'Hi-C' | 'lentiMPRA' | 'MERFISH' | 'MIAA' | 'mN2H' | 'MPRA' | 'MPRA (scQer)' | 'MULTI-seq' | 'Parse SPLiT-seq' | 'Perturb-seq' | 'RNA-seq' | 'SGE' | 'scATAC-seq' | 'scNT-seq' | 'scNT-seq2' | 'scRNA-seq' | 'semi-qY2H' | 'SHARE-seq' | 'smFISH' | 'snATAC-seq' | 'snmC-Seq2' | 'snMCT-seq' | 'snM3C-seq' | 'snRNA-seq' | 'SUPERSTARR' | 'TAP-seq' | 'TF ChIP-seq' | 'VAMP-seq' | 'Variant FlowFISH' | 'Variant painting' | 'Y2H' | 'yN2H'>, protocols?: Array<string>, publicationIdentifiers?: Array<string>, publications?: Array<string>, relatedMultiomeDatasetsId?: Array<string>, relatedMultiomeDatasetsAccession?: Array<string>, releaseTimestamp?: Array<string>, revokeDetail?: Array<string>, samplesId?: Array<string>, samplesAccession?: Array<string>, samplesAliases?: Array<string>, samplesCellFateChangeTreatmentsId?: Array<string>, samplesCellFateChangeTreatmentsPurpose?: Array<'activation' | 'agonist' | 'antagonist' | 'control' | 'differentiation' | 'de-differentiation' | 'perturbation' | 'selection' | 'stimulation'>, samplesCellFateChangeTreatmentsSummary?: Array<string>, samplesCellFateChangeTreatmentsTreatmentType?: Array<'chemical' | 'protein' | 'environmental'>, samplesClassifications?: Array<'organoid' | 'gastruloid' | 'embryoid' | 'cell line' | 'differentiated cell specimen' | 'reprogrammed cell specimen' | 'pooled cell specimen'>, samplesConstructLibrarySetsId?: Array<string>, samplesConstructLibrarySetsAccession?: Array<string>, samplesConstructLibrarySetsFileSetType?: Array<'guide library' | 'reporter library' | 'expression vector library' | 'editing template library'>, samplesConstructLibrarySetsSmallScaleGeneListId?: Array<string>, samplesConstructLibrarySetsSmallScaleGeneListGeneid?: Array<string>, samplesConstructLibrarySetsSmallScaleGeneListName?: Array<string>, samplesConstructLibrarySetsSmallScaleGeneListSummary?: Array<string>, samplesConstructLibrarySetsSmallScaleGeneListSymbol?: Array<string>, samplesConstructLibrarySetsSummary?: Array<string>, samplesDiseaseTermsId?: Array<string>, samplesDiseaseTermsTermName?: Array<string>, samplesModificationsId?: Array<string>, samplesSampleTermsId?: Array<string>, samplesSampleTermsAliases?: Array<string>, samplesSampleTermsStatus?: Array<'archived' | 'deleted' | 'in progress' | 'released'>, samplesSampleTermsSummary?: Array<string>, samplesSampleTermsTermName?: Array<string>, samplesStatus?: Array<'in progress' | 'released' | 'deleted' | 'replaced' | 'revoked' | 'archived'>, samplesSummary?: Array<string>, samplesTargetedSampleTermId?: Array<string>, samplesTargetedSampleTermTermName?: Array<string>, samplesTaxa?: Array<'Homo sapiens' | 'Mus musculus'>, samplesTreatmentsId?: Array<string>, samplesTreatmentsPurpose?: Array<'activation' | 'agonist' | 'antagonist' | 'control' | 'differentiation' | 'de-differentiation' | 'perturbation' | 'selection' | 'stimulation'>, samplesTreatmentsSummary?: Array<string>, samplesTreatmentsTreatmentType?: Array<'chemical' | 'protein' | 'environmental'>, sequencingLibraryTypes?: Array<'direct RNA' | 'exome capture' | 'mRNA enriched' | 'rRNA depleted' | 'polyA depleted' | 'polyA enriched'>, status?: Array<'in progress' | 'released' | 'deleted' | 'replaced' | 'revoked' | 'archived'>, submittedById?: Array<string>, submittedByTitle?: Array<string>, submittedFilesTimestamp?: Array<string>, submitterComment?: Array<string>, summary?: Array<string>, targetedGenesId?: Array<string>, targetedGenesGeneid?: Array<string>, targetedGenesName?: Array<string>, targetedGenesSymbol?: Array<string>, targetedGenesSynonyms?: Array<string>, uuid?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: MeasurementSetResults;  }> {
        const localVarPath = this.basePath + '/measurement-sets/@@listing';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'frame' is not null or undefined
        if (frame === null || frame === undefined) {
            throw new Error('Required parameter frame was null or undefined when calling measurementSets.');
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (frame !== undefined) {
            localVarQueryParameters['frame'] = ObjectSerializer.serialize(frame, "'object'");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "Limit");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "Array<string>");
        }

        if (id !== undefined) {
            localVarQueryParameters['@id'] = ObjectSerializer.serialize(id, "Array<string>");
        }

        if (accession !== undefined) {
            localVarQueryParameters['accession'] = ObjectSerializer.serialize(accession, "Array<string>");
        }

        if (aliases !== undefined) {
            localVarQueryParameters['aliases'] = ObjectSerializer.serialize(aliases, "Array<string>");
        }

        if (alternateAccessions !== undefined) {
            localVarQueryParameters['alternate_accessions'] = ObjectSerializer.serialize(alternateAccessions, "Array<string>");
        }

        if (assayTermId !== undefined) {
            localVarQueryParameters['assay_term.@id'] = ObjectSerializer.serialize(assayTermId, "Array<string>");
        }

        if (assayTermTermName !== undefined) {
            localVarQueryParameters['assay_term.term_name'] = ObjectSerializer.serialize(assayTermTermName, "Array<string>");
        }

        if (auxiliarySetsId !== undefined) {
            localVarQueryParameters['auxiliary_sets.@id'] = ObjectSerializer.serialize(auxiliarySetsId, "Array<string>");
        }

        if (auxiliarySetsAccession !== undefined) {
            localVarQueryParameters['auxiliary_sets.accession'] = ObjectSerializer.serialize(auxiliarySetsAccession, "Array<string>");
        }

        if (auxiliarySetsAliases !== undefined) {
            localVarQueryParameters['auxiliary_sets.aliases'] = ObjectSerializer.serialize(auxiliarySetsAliases, "Array<string>");
        }

        if (auxiliarySetsFileSetType !== undefined) {
            localVarQueryParameters['auxiliary_sets.file_set_type'] = ObjectSerializer.serialize(auxiliarySetsFileSetType, "Array<'cell hashing' | 'cell sorting' | 'circularized RNA barcode detection' | 'gRNA sequencing' | 'oligo-conjugated lipids' | 'quantification DNA barcode sequencing' | 'variant sequencing'>");
        }

        if (awardId !== undefined) {
            localVarQueryParameters['award.@id'] = ObjectSerializer.serialize(awardId, "Array<string>");
        }

        if (awardComponent !== undefined) {
            localVarQueryParameters['award.component'] = ObjectSerializer.serialize(awardComponent, "Array<'affiliate' | 'data analysis' | 'data coordination' | 'functional characterization' | 'mapping' | 'networks' | 'predictive modeling'>");
        }

        if (awardContactPiId !== undefined) {
            localVarQueryParameters['award.contact_pi.@id'] = ObjectSerializer.serialize(awardContactPiId, "Array<string>");
        }

        if (awardContactPiTitle !== undefined) {
            localVarQueryParameters['award.contact_pi.title'] = ObjectSerializer.serialize(awardContactPiTitle, "Array<string>");
        }

        if (awardTitle !== undefined) {
            localVarQueryParameters['award.title'] = ObjectSerializer.serialize(awardTitle, "Array<string>");
        }

        if (collections !== undefined) {
            localVarQueryParameters['collections'] = ObjectSerializer.serialize(collections, "Array<'ClinGen' | 'ENCODE' | 'GREGoR' | 'IGVF_catalog_beta_v0.1' | 'IGVF_catalog_beta_v0.2' | 'IGVF_catalog_beta_v0.3' | 'IGVF_catalog_beta_v0.4' | 'MaveDB' | 'MPRAbase' | 'Vista'>");
        }

        if (controlFileSetsId !== undefined) {
            localVarQueryParameters['control_file_sets.@id'] = ObjectSerializer.serialize(controlFileSetsId, "Array<string>");
        }

        if (controlFileSetsAccession !== undefined) {
            localVarQueryParameters['control_file_sets.accession'] = ObjectSerializer.serialize(controlFileSetsAccession, "Array<string>");
        }

        if (controlFileSetsAliases !== undefined) {
            localVarQueryParameters['control_file_sets.aliases'] = ObjectSerializer.serialize(controlFileSetsAliases, "Array<string>");
        }

        if (controlForId !== undefined) {
            localVarQueryParameters['control_for.@id'] = ObjectSerializer.serialize(controlForId, "Array<string>");
        }

        if (controlForAccession !== undefined) {
            localVarQueryParameters['control_for.accession'] = ObjectSerializer.serialize(controlForAccession, "Array<string>");
        }

        if (controlForAliases !== undefined) {
            localVarQueryParameters['control_for.aliases'] = ObjectSerializer.serialize(controlForAliases, "Array<string>");
        }

        if (creationTimestamp !== undefined) {
            localVarQueryParameters['creation_timestamp'] = ObjectSerializer.serialize(creationTimestamp, "Array<string>");
        }

        if (dbxrefs !== undefined) {
            localVarQueryParameters['dbxrefs'] = ObjectSerializer.serialize(dbxrefs, "Array<string>");
        }

        if (description !== undefined) {
            localVarQueryParameters['description'] = ObjectSerializer.serialize(description, "Array<string>");
        }

        if (documents !== undefined) {
            localVarQueryParameters['documents'] = ObjectSerializer.serialize(documents, "Array<string>");
        }

        if (donorsId !== undefined) {
            localVarQueryParameters['donors.@id'] = ObjectSerializer.serialize(donorsId, "Array<string>");
        }

        if (donorsAccession !== undefined) {
            localVarQueryParameters['donors.accession'] = ObjectSerializer.serialize(donorsAccession, "Array<string>");
        }

        if (donorsAliases !== undefined) {
            localVarQueryParameters['donors.aliases'] = ObjectSerializer.serialize(donorsAliases, "Array<string>");
        }

        if (donorsSex !== undefined) {
            localVarQueryParameters['donors.sex'] = ObjectSerializer.serialize(donorsSex, "Array<'male' | 'female' | 'unspecified'>");
        }

        if (donorsStatus !== undefined) {
            localVarQueryParameters['donors.status'] = ObjectSerializer.serialize(donorsStatus, "Array<'in progress' | 'released' | 'deleted' | 'replaced' | 'revoked' | 'archived'>");
        }

        if (donorsTaxa !== undefined) {
            localVarQueryParameters['donors.taxa'] = ObjectSerializer.serialize(donorsTaxa, "Array<string>");
        }

        if (externalImageUrl !== undefined) {
            localVarQueryParameters['external_image_url'] = ObjectSerializer.serialize(externalImageUrl, "Array<string>");
        }

        if (fileSetType !== undefined) {
            localVarQueryParameters['file_set_type'] = ObjectSerializer.serialize(fileSetType, "Array<'experimental data'>");
        }

        if (filesId !== undefined) {
            localVarQueryParameters['files.@id'] = ObjectSerializer.serialize(filesId, "Array<string>");
        }

        if (filesAccession !== undefined) {
            localVarQueryParameters['files.accession'] = ObjectSerializer.serialize(filesAccession, "Array<string>");
        }

        if (filesAliases !== undefined) {
            localVarQueryParameters['files.aliases'] = ObjectSerializer.serialize(filesAliases, "Array<string>");
        }

        if (filesContentType !== undefined) {
            localVarQueryParameters['files.content_type'] = ObjectSerializer.serialize(filesContentType, "Array<string>");
        }

        if (filesCreationTimestamp !== undefined) {
            localVarQueryParameters['files.creation_timestamp'] = ObjectSerializer.serialize(filesCreationTimestamp, "Array<string>");
        }

        if (filesFileFormat !== undefined) {
            localVarQueryParameters['files.file_format'] = ObjectSerializer.serialize(filesFileFormat, "Array<string>");
        }

        if (filesFileSize !== undefined) {
            localVarQueryParameters['files.file_size'] = ObjectSerializer.serialize(filesFileSize, "Array<number>");
        }

        if (filesHref !== undefined) {
            localVarQueryParameters['files.href'] = ObjectSerializer.serialize(filesHref, "Array<string>");
        }

        if (filesS3Uri !== undefined) {
            localVarQueryParameters['files.s3_uri'] = ObjectSerializer.serialize(filesS3Uri, "Array<string>");
        }

        if (filesSequencingPlatformId !== undefined) {
            localVarQueryParameters['files.sequencing_platform.@id'] = ObjectSerializer.serialize(filesSequencingPlatformId, "Array<string>");
        }

        if (filesSequencingPlatformTermName !== undefined) {
            localVarQueryParameters['files.sequencing_platform.term_name'] = ObjectSerializer.serialize(filesSequencingPlatformTermName, "Array<string>");
        }

        if (filesSubmittedFileName !== undefined) {
            localVarQueryParameters['files.submitted_file_name'] = ObjectSerializer.serialize(filesSubmittedFileName, "Array<string>");
        }

        if (filesUploadStatus !== undefined) {
            localVarQueryParameters['files.upload_status'] = ObjectSerializer.serialize(filesUploadStatus, "Array<'pending' | 'file not found' | 'invalidated' | 'validated'>");
        }

        if (inputFileSetFor !== undefined) {
            localVarQueryParameters['input_file_set_for'] = ObjectSerializer.serialize(inputFileSetFor, "Array<string>");
        }

        if (labId !== undefined) {
            localVarQueryParameters['lab.@id'] = ObjectSerializer.serialize(labId, "Array<string>");
        }

        if (labTitle !== undefined) {
            localVarQueryParameters['lab.title'] = ObjectSerializer.serialize(labTitle, "Array<string>");
        }

        if (libraryConstructionPlatformId !== undefined) {
            localVarQueryParameters['library_construction_platform.@id'] = ObjectSerializer.serialize(libraryConstructionPlatformId, "Array<string>");
        }

        if (libraryConstructionPlatformTermName !== undefined) {
            localVarQueryParameters['library_construction_platform.term_name'] = ObjectSerializer.serialize(libraryConstructionPlatformTermName, "Array<string>");
        }

        if (multiomeSize !== undefined) {
            localVarQueryParameters['multiome_size'] = ObjectSerializer.serialize(multiomeSize, "Array<number>");
        }

        if (notes !== undefined) {
            localVarQueryParameters['notes'] = ObjectSerializer.serialize(notes, "Array<string>");
        }

        if (preferredAssayTitle !== undefined) {
            localVarQueryParameters['preferred_assay_title'] = ObjectSerializer.serialize(preferredAssayTitle, "Array<'10x multiome' | '10x multiome with MULTI-seq' | 'AAV-MPRA' | 'ATAC-seq' | 'CERES-seq' | 'Cell painting' | 'CRISPR FlowFISH' | 'DOGMA-seq' | 'Histone ChIP-seq' | 'Hi-C' | 'lentiMPRA' | 'MERFISH' | 'MIAA' | 'mN2H' | 'MPRA' | 'MPRA (scQer)' | 'MULTI-seq' | 'Parse SPLiT-seq' | 'Perturb-seq' | 'RNA-seq' | 'SGE' | 'scATAC-seq' | 'scNT-seq' | 'scNT-seq2' | 'scRNA-seq' | 'semi-qY2H' | 'SHARE-seq' | 'smFISH' | 'snATAC-seq' | 'snmC-Seq2' | 'snMCT-seq' | 'snM3C-seq' | 'snRNA-seq' | 'SUPERSTARR' | 'TAP-seq' | 'TF ChIP-seq' | 'VAMP-seq' | 'Variant FlowFISH' | 'Variant painting' | 'Y2H' | 'yN2H'>");
        }

        if (protocols !== undefined) {
            localVarQueryParameters['protocols'] = ObjectSerializer.serialize(protocols, "Array<string>");
        }

        if (publicationIdentifiers !== undefined) {
            localVarQueryParameters['publication_identifiers'] = ObjectSerializer.serialize(publicationIdentifiers, "Array<string>");
        }

        if (publications !== undefined) {
            localVarQueryParameters['publications'] = ObjectSerializer.serialize(publications, "Array<string>");
        }

        if (relatedMultiomeDatasetsId !== undefined) {
            localVarQueryParameters['related_multiome_datasets.@id'] = ObjectSerializer.serialize(relatedMultiomeDatasetsId, "Array<string>");
        }

        if (relatedMultiomeDatasetsAccession !== undefined) {
            localVarQueryParameters['related_multiome_datasets.accession'] = ObjectSerializer.serialize(relatedMultiomeDatasetsAccession, "Array<string>");
        }

        if (releaseTimestamp !== undefined) {
            localVarQueryParameters['release_timestamp'] = ObjectSerializer.serialize(releaseTimestamp, "Array<string>");
        }

        if (revokeDetail !== undefined) {
            localVarQueryParameters['revoke_detail'] = ObjectSerializer.serialize(revokeDetail, "Array<string>");
        }

        if (samplesId !== undefined) {
            localVarQueryParameters['samples.@id'] = ObjectSerializer.serialize(samplesId, "Array<string>");
        }

        if (samplesAccession !== undefined) {
            localVarQueryParameters['samples.accession'] = ObjectSerializer.serialize(samplesAccession, "Array<string>");
        }

        if (samplesAliases !== undefined) {
            localVarQueryParameters['samples.aliases'] = ObjectSerializer.serialize(samplesAliases, "Array<string>");
        }

        if (samplesCellFateChangeTreatmentsId !== undefined) {
            localVarQueryParameters['samples.cell_fate_change_treatments.@id'] = ObjectSerializer.serialize(samplesCellFateChangeTreatmentsId, "Array<string>");
        }

        if (samplesCellFateChangeTreatmentsPurpose !== undefined) {
            localVarQueryParameters['samples.cell_fate_change_treatments.purpose'] = ObjectSerializer.serialize(samplesCellFateChangeTreatmentsPurpose, "Array<'activation' | 'agonist' | 'antagonist' | 'control' | 'differentiation' | 'de-differentiation' | 'perturbation' | 'selection' | 'stimulation'>");
        }

        if (samplesCellFateChangeTreatmentsSummary !== undefined) {
            localVarQueryParameters['samples.cell_fate_change_treatments.summary'] = ObjectSerializer.serialize(samplesCellFateChangeTreatmentsSummary, "Array<string>");
        }

        if (samplesCellFateChangeTreatmentsTreatmentType !== undefined) {
            localVarQueryParameters['samples.cell_fate_change_treatments.treatment_type'] = ObjectSerializer.serialize(samplesCellFateChangeTreatmentsTreatmentType, "Array<'chemical' | 'protein' | 'environmental'>");
        }

        if (samplesClassifications !== undefined) {
            localVarQueryParameters['samples.classifications'] = ObjectSerializer.serialize(samplesClassifications, "Array<'organoid' | 'gastruloid' | 'embryoid' | 'cell line' | 'differentiated cell specimen' | 'reprogrammed cell specimen' | 'pooled cell specimen'>");
        }

        if (samplesConstructLibrarySetsId !== undefined) {
            localVarQueryParameters['samples.construct_library_sets.@id'] = ObjectSerializer.serialize(samplesConstructLibrarySetsId, "Array<string>");
        }

        if (samplesConstructLibrarySetsAccession !== undefined) {
            localVarQueryParameters['samples.construct_library_sets.accession'] = ObjectSerializer.serialize(samplesConstructLibrarySetsAccession, "Array<string>");
        }

        if (samplesConstructLibrarySetsFileSetType !== undefined) {
            localVarQueryParameters['samples.construct_library_sets.file_set_type'] = ObjectSerializer.serialize(samplesConstructLibrarySetsFileSetType, "Array<'guide library' | 'reporter library' | 'expression vector library' | 'editing template library'>");
        }

        if (samplesConstructLibrarySetsSmallScaleGeneListId !== undefined) {
            localVarQueryParameters['samples.construct_library_sets.small_scale_gene_list.@id'] = ObjectSerializer.serialize(samplesConstructLibrarySetsSmallScaleGeneListId, "Array<string>");
        }

        if (samplesConstructLibrarySetsSmallScaleGeneListGeneid !== undefined) {
            localVarQueryParameters['samples.construct_library_sets.small_scale_gene_list.geneid'] = ObjectSerializer.serialize(samplesConstructLibrarySetsSmallScaleGeneListGeneid, "Array<string>");
        }

        if (samplesConstructLibrarySetsSmallScaleGeneListName !== undefined) {
            localVarQueryParameters['samples.construct_library_sets.small_scale_gene_list.name'] = ObjectSerializer.serialize(samplesConstructLibrarySetsSmallScaleGeneListName, "Array<string>");
        }

        if (samplesConstructLibrarySetsSmallScaleGeneListSummary !== undefined) {
            localVarQueryParameters['samples.construct_library_sets.small_scale_gene_list.summary'] = ObjectSerializer.serialize(samplesConstructLibrarySetsSmallScaleGeneListSummary, "Array<string>");
        }

        if (samplesConstructLibrarySetsSmallScaleGeneListSymbol !== undefined) {
            localVarQueryParameters['samples.construct_library_sets.small_scale_gene_list.symbol'] = ObjectSerializer.serialize(samplesConstructLibrarySetsSmallScaleGeneListSymbol, "Array<string>");
        }

        if (samplesConstructLibrarySetsSummary !== undefined) {
            localVarQueryParameters['samples.construct_library_sets.summary'] = ObjectSerializer.serialize(samplesConstructLibrarySetsSummary, "Array<string>");
        }

        if (samplesDiseaseTermsId !== undefined) {
            localVarQueryParameters['samples.disease_terms.@id'] = ObjectSerializer.serialize(samplesDiseaseTermsId, "Array<string>");
        }

        if (samplesDiseaseTermsTermName !== undefined) {
            localVarQueryParameters['samples.disease_terms.term_name'] = ObjectSerializer.serialize(samplesDiseaseTermsTermName, "Array<string>");
        }

        if (samplesModificationsId !== undefined) {
            localVarQueryParameters['samples.modifications.@id'] = ObjectSerializer.serialize(samplesModificationsId, "Array<string>");
        }

        if (samplesSampleTermsId !== undefined) {
            localVarQueryParameters['samples.sample_terms.@id'] = ObjectSerializer.serialize(samplesSampleTermsId, "Array<string>");
        }

        if (samplesSampleTermsAliases !== undefined) {
            localVarQueryParameters['samples.sample_terms.aliases'] = ObjectSerializer.serialize(samplesSampleTermsAliases, "Array<string>");
        }

        if (samplesSampleTermsStatus !== undefined) {
            localVarQueryParameters['samples.sample_terms.status'] = ObjectSerializer.serialize(samplesSampleTermsStatus, "Array<'archived' | 'deleted' | 'in progress' | 'released'>");
        }

        if (samplesSampleTermsSummary !== undefined) {
            localVarQueryParameters['samples.sample_terms.summary'] = ObjectSerializer.serialize(samplesSampleTermsSummary, "Array<string>");
        }

        if (samplesSampleTermsTermName !== undefined) {
            localVarQueryParameters['samples.sample_terms.term_name'] = ObjectSerializer.serialize(samplesSampleTermsTermName, "Array<string>");
        }

        if (samplesStatus !== undefined) {
            localVarQueryParameters['samples.status'] = ObjectSerializer.serialize(samplesStatus, "Array<'in progress' | 'released' | 'deleted' | 'replaced' | 'revoked' | 'archived'>");
        }

        if (samplesSummary !== undefined) {
            localVarQueryParameters['samples.summary'] = ObjectSerializer.serialize(samplesSummary, "Array<string>");
        }

        if (samplesTargetedSampleTermId !== undefined) {
            localVarQueryParameters['samples.targeted_sample_term.@id'] = ObjectSerializer.serialize(samplesTargetedSampleTermId, "Array<string>");
        }

        if (samplesTargetedSampleTermTermName !== undefined) {
            localVarQueryParameters['samples.targeted_sample_term.term_name'] = ObjectSerializer.serialize(samplesTargetedSampleTermTermName, "Array<string>");
        }

        if (samplesTaxa !== undefined) {
            localVarQueryParameters['samples.taxa'] = ObjectSerializer.serialize(samplesTaxa, "Array<'Homo sapiens' | 'Mus musculus'>");
        }

        if (samplesTreatmentsId !== undefined) {
            localVarQueryParameters['samples.treatments.@id'] = ObjectSerializer.serialize(samplesTreatmentsId, "Array<string>");
        }

        if (samplesTreatmentsPurpose !== undefined) {
            localVarQueryParameters['samples.treatments.purpose'] = ObjectSerializer.serialize(samplesTreatmentsPurpose, "Array<'activation' | 'agonist' | 'antagonist' | 'control' | 'differentiation' | 'de-differentiation' | 'perturbation' | 'selection' | 'stimulation'>");
        }

        if (samplesTreatmentsSummary !== undefined) {
            localVarQueryParameters['samples.treatments.summary'] = ObjectSerializer.serialize(samplesTreatmentsSummary, "Array<string>");
        }

        if (samplesTreatmentsTreatmentType !== undefined) {
            localVarQueryParameters['samples.treatments.treatment_type'] = ObjectSerializer.serialize(samplesTreatmentsTreatmentType, "Array<'chemical' | 'protein' | 'environmental'>");
        }

        if (sequencingLibraryTypes !== undefined) {
            localVarQueryParameters['sequencing_library_types'] = ObjectSerializer.serialize(sequencingLibraryTypes, "Array<'direct RNA' | 'exome capture' | 'mRNA enriched' | 'rRNA depleted' | 'polyA depleted' | 'polyA enriched'>");
        }

        if (status !== undefined) {
            localVarQueryParameters['status'] = ObjectSerializer.serialize(status, "Array<'in progress' | 'released' | 'deleted' | 'replaced' | 'revoked' | 'archived'>");
        }

        if (submittedById !== undefined) {
            localVarQueryParameters['submitted_by.@id'] = ObjectSerializer.serialize(submittedById, "Array<string>");
        }

        if (submittedByTitle !== undefined) {
            localVarQueryParameters['submitted_by.title'] = ObjectSerializer.serialize(submittedByTitle, "Array<string>");
        }

        if (submittedFilesTimestamp !== undefined) {
            localVarQueryParameters['submitted_files_timestamp'] = ObjectSerializer.serialize(submittedFilesTimestamp, "Array<string>");
        }

        if (submitterComment !== undefined) {
            localVarQueryParameters['submitter_comment'] = ObjectSerializer.serialize(submitterComment, "Array<string>");
        }

        if (summary !== undefined) {
            localVarQueryParameters['summary'] = ObjectSerializer.serialize(summary, "Array<string>");
        }

        if (targetedGenesId !== undefined) {
            localVarQueryParameters['targeted_genes.@id'] = ObjectSerializer.serialize(targetedGenesId, "Array<string>");
        }

        if (targetedGenesGeneid !== undefined) {
            localVarQueryParameters['targeted_genes.geneid'] = ObjectSerializer.serialize(targetedGenesGeneid, "Array<string>");
        }

        if (targetedGenesName !== undefined) {
            localVarQueryParameters['targeted_genes.name'] = ObjectSerializer.serialize(targetedGenesName, "Array<string>");
        }

        if (targetedGenesSymbol !== undefined) {
            localVarQueryParameters['targeted_genes.symbol'] = ObjectSerializer.serialize(targetedGenesSymbol, "Array<string>");
        }

        if (targetedGenesSynonyms !== undefined) {
            localVarQueryParameters['targeted_genes.synonyms'] = ObjectSerializer.serialize(targetedGenesSynonyms, "Array<string>");
        }

        if (uuid !== undefined) {
            localVarQueryParameters['uuid'] = ObjectSerializer.serialize(uuid, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: MeasurementSetResults;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "MeasurementSetResults");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Collection endpoint that accepts various query parameters to filter, sort, and paginate ModelFile items. Supports filtering on fields within ModelFile items.
     * @summary List items in the ModelFile collection.
     * @param frame Constant value. Do not set.
     * @param query Query string for searching.
     * @param limit Maximum number of results to return. Default is 25. Use \&#39;all\&#39; for all results.
     * @param sort Fields to sort results by. Prefix with \&#39;-\&#39; for descending order. Can be repeated for multiple sort fields. Does not work with limit&#x3D;all.
     * @param id Filter by @id
     * @param accession Filter by accession
     * @param aliases Filter by aliases
     * @param alternateAccessions Filter by alternate_accessions
     * @param analysisStepVersion Filter by analysis_step_version
     * @param anvilUrl Filter by anvil_url
     * @param awardId Filter by award.@id
     * @param awardComponent Filter by award.component
     * @param collections Filter by collections
     * @param contentMd5sum Filter by content_md5sum
     * @param contentType Filter by content_type
     * @param controlledAccess Filter by controlled_access
     * @param creationTimestamp Filter by creation_timestamp
     * @param dbxrefs Filter by dbxrefs
     * @param derivedFrom Filter by derived_from
     * @param description Filter by description
     * @param documents Filter by documents
     * @param fileFormat Filter by file_format
     * @param fileFormatSpecifications Filter by file_format_specifications
     * @param fileSet Filter by file_set
     * @param fileSize Filter by file_size
     * @param geneListFor Filter by gene_list_for
     * @param href Filter by href
     * @param inputFileFor Filter by input_file_for
     * @param integratedIn Filter by integrated_in
     * @param labId Filter by lab.@id
     * @param labTitle Filter by lab.title
     * @param lociListFor Filter by loci_list_for
     * @param md5sum Filter by md5sum
     * @param notes Filter by notes
     * @param releaseTimestamp Filter by release_timestamp
     * @param revokeDetail Filter by revoke_detail
     * @param s3Uri Filter by s3_uri
     * @param status Filter by status
     * @param submittedById Filter by submitted_by.@id
     * @param submittedByTitle Filter by submitted_by.title
     * @param submittedFileName Filter by submitted_file_name
     * @param submitterComment Filter by submitter_comment
     * @param summary Filter by summary
     * @param uploadStatus Filter by upload_status
     * @param uuid Filter by uuid
     * @param validationErrorDetail Filter by validation_error_detail
     */
    public async modelFiles (frame: 'object', query?: string, limit?: Limit, sort?: Array<string>, id?: Array<string>, accession?: Array<string>, aliases?: Array<string>, alternateAccessions?: Array<string>, analysisStepVersion?: Array<string>, anvilUrl?: Array<string>, awardId?: Array<string>, awardComponent?: Array<'affiliate' | 'data analysis' | 'data coordination' | 'functional characterization' | 'mapping' | 'networks' | 'predictive modeling'>, collections?: Array<'ClinGen' | 'ENCODE' | 'GREGoR' | 'IGVF_catalog_beta_v0.1' | 'IGVF_catalog_beta_v0.2' | 'IGVF_catalog_beta_v0.3' | 'IGVF_catalog_beta_v0.4' | 'MaveDB' | 'MPRAbase' | 'Vista'>, contentMd5sum?: Array<string>, contentType?: Array<string>, controlledAccess?: Array<boolean>, creationTimestamp?: Array<string>, dbxrefs?: Array<string>, derivedFrom?: Array<string>, description?: Array<string>, documents?: Array<string>, fileFormat?: Array<'hdf5' | 'json' | 'tar' | 'tsv'>, fileFormatSpecifications?: Array<string>, fileSet?: Array<string>, fileSize?: Array<number>, geneListFor?: Array<string>, href?: Array<string>, inputFileFor?: Array<string>, integratedIn?: Array<string>, labId?: Array<string>, labTitle?: Array<string>, lociListFor?: Array<string>, md5sum?: Array<string>, notes?: Array<string>, releaseTimestamp?: Array<string>, revokeDetail?: Array<string>, s3Uri?: Array<string>, status?: Array<'in progress' | 'released' | 'deleted' | 'replaced' | 'revoked' | 'archived'>, submittedById?: Array<string>, submittedByTitle?: Array<string>, submittedFileName?: Array<string>, submitterComment?: Array<string>, summary?: Array<string>, uploadStatus?: Array<'pending' | 'file not found' | 'invalidated' | 'validated'>, uuid?: Array<string>, validationErrorDetail?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: ModelFileResults;  }> {
        const localVarPath = this.basePath + '/model-files/@@listing';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'frame' is not null or undefined
        if (frame === null || frame === undefined) {
            throw new Error('Required parameter frame was null or undefined when calling modelFiles.');
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (frame !== undefined) {
            localVarQueryParameters['frame'] = ObjectSerializer.serialize(frame, "'object'");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "Limit");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "Array<string>");
        }

        if (id !== undefined) {
            localVarQueryParameters['@id'] = ObjectSerializer.serialize(id, "Array<string>");
        }

        if (accession !== undefined) {
            localVarQueryParameters['accession'] = ObjectSerializer.serialize(accession, "Array<string>");
        }

        if (aliases !== undefined) {
            localVarQueryParameters['aliases'] = ObjectSerializer.serialize(aliases, "Array<string>");
        }

        if (alternateAccessions !== undefined) {
            localVarQueryParameters['alternate_accessions'] = ObjectSerializer.serialize(alternateAccessions, "Array<string>");
        }

        if (analysisStepVersion !== undefined) {
            localVarQueryParameters['analysis_step_version'] = ObjectSerializer.serialize(analysisStepVersion, "Array<string>");
        }

        if (anvilUrl !== undefined) {
            localVarQueryParameters['anvil_url'] = ObjectSerializer.serialize(anvilUrl, "Array<string>");
        }

        if (awardId !== undefined) {
            localVarQueryParameters['award.@id'] = ObjectSerializer.serialize(awardId, "Array<string>");
        }

        if (awardComponent !== undefined) {
            localVarQueryParameters['award.component'] = ObjectSerializer.serialize(awardComponent, "Array<'affiliate' | 'data analysis' | 'data coordination' | 'functional characterization' | 'mapping' | 'networks' | 'predictive modeling'>");
        }

        if (collections !== undefined) {
            localVarQueryParameters['collections'] = ObjectSerializer.serialize(collections, "Array<'ClinGen' | 'ENCODE' | 'GREGoR' | 'IGVF_catalog_beta_v0.1' | 'IGVF_catalog_beta_v0.2' | 'IGVF_catalog_beta_v0.3' | 'IGVF_catalog_beta_v0.4' | 'MaveDB' | 'MPRAbase' | 'Vista'>");
        }

        if (contentMd5sum !== undefined) {
            localVarQueryParameters['content_md5sum'] = ObjectSerializer.serialize(contentMd5sum, "Array<string>");
        }

        if (contentType !== undefined) {
            localVarQueryParameters['content_type'] = ObjectSerializer.serialize(contentType, "Array<string>");
        }

        if (controlledAccess !== undefined) {
            localVarQueryParameters['controlled_access'] = ObjectSerializer.serialize(controlledAccess, "Array<boolean>");
        }

        if (creationTimestamp !== undefined) {
            localVarQueryParameters['creation_timestamp'] = ObjectSerializer.serialize(creationTimestamp, "Array<string>");
        }

        if (dbxrefs !== undefined) {
            localVarQueryParameters['dbxrefs'] = ObjectSerializer.serialize(dbxrefs, "Array<string>");
        }

        if (derivedFrom !== undefined) {
            localVarQueryParameters['derived_from'] = ObjectSerializer.serialize(derivedFrom, "Array<string>");
        }

        if (description !== undefined) {
            localVarQueryParameters['description'] = ObjectSerializer.serialize(description, "Array<string>");
        }

        if (documents !== undefined) {
            localVarQueryParameters['documents'] = ObjectSerializer.serialize(documents, "Array<string>");
        }

        if (fileFormat !== undefined) {
            localVarQueryParameters['file_format'] = ObjectSerializer.serialize(fileFormat, "Array<'hdf5' | 'json' | 'tar' | 'tsv'>");
        }

        if (fileFormatSpecifications !== undefined) {
            localVarQueryParameters['file_format_specifications'] = ObjectSerializer.serialize(fileFormatSpecifications, "Array<string>");
        }

        if (fileSet !== undefined) {
            localVarQueryParameters['file_set'] = ObjectSerializer.serialize(fileSet, "Array<string>");
        }

        if (fileSize !== undefined) {
            localVarQueryParameters['file_size'] = ObjectSerializer.serialize(fileSize, "Array<number>");
        }

        if (geneListFor !== undefined) {
            localVarQueryParameters['gene_list_for'] = ObjectSerializer.serialize(geneListFor, "Array<string>");
        }

        if (href !== undefined) {
            localVarQueryParameters['href'] = ObjectSerializer.serialize(href, "Array<string>");
        }

        if (inputFileFor !== undefined) {
            localVarQueryParameters['input_file_for'] = ObjectSerializer.serialize(inputFileFor, "Array<string>");
        }

        if (integratedIn !== undefined) {
            localVarQueryParameters['integrated_in'] = ObjectSerializer.serialize(integratedIn, "Array<string>");
        }

        if (labId !== undefined) {
            localVarQueryParameters['lab.@id'] = ObjectSerializer.serialize(labId, "Array<string>");
        }

        if (labTitle !== undefined) {
            localVarQueryParameters['lab.title'] = ObjectSerializer.serialize(labTitle, "Array<string>");
        }

        if (lociListFor !== undefined) {
            localVarQueryParameters['loci_list_for'] = ObjectSerializer.serialize(lociListFor, "Array<string>");
        }

        if (md5sum !== undefined) {
            localVarQueryParameters['md5sum'] = ObjectSerializer.serialize(md5sum, "Array<string>");
        }

        if (notes !== undefined) {
            localVarQueryParameters['notes'] = ObjectSerializer.serialize(notes, "Array<string>");
        }

        if (releaseTimestamp !== undefined) {
            localVarQueryParameters['release_timestamp'] = ObjectSerializer.serialize(releaseTimestamp, "Array<string>");
        }

        if (revokeDetail !== undefined) {
            localVarQueryParameters['revoke_detail'] = ObjectSerializer.serialize(revokeDetail, "Array<string>");
        }

        if (s3Uri !== undefined) {
            localVarQueryParameters['s3_uri'] = ObjectSerializer.serialize(s3Uri, "Array<string>");
        }

        if (status !== undefined) {
            localVarQueryParameters['status'] = ObjectSerializer.serialize(status, "Array<'in progress' | 'released' | 'deleted' | 'replaced' | 'revoked' | 'archived'>");
        }

        if (submittedById !== undefined) {
            localVarQueryParameters['submitted_by.@id'] = ObjectSerializer.serialize(submittedById, "Array<string>");
        }

        if (submittedByTitle !== undefined) {
            localVarQueryParameters['submitted_by.title'] = ObjectSerializer.serialize(submittedByTitle, "Array<string>");
        }

        if (submittedFileName !== undefined) {
            localVarQueryParameters['submitted_file_name'] = ObjectSerializer.serialize(submittedFileName, "Array<string>");
        }

        if (submitterComment !== undefined) {
            localVarQueryParameters['submitter_comment'] = ObjectSerializer.serialize(submitterComment, "Array<string>");
        }

        if (summary !== undefined) {
            localVarQueryParameters['summary'] = ObjectSerializer.serialize(summary, "Array<string>");
        }

        if (uploadStatus !== undefined) {
            localVarQueryParameters['upload_status'] = ObjectSerializer.serialize(uploadStatus, "Array<'pending' | 'file not found' | 'invalidated' | 'validated'>");
        }

        if (uuid !== undefined) {
            localVarQueryParameters['uuid'] = ObjectSerializer.serialize(uuid, "Array<string>");
        }

        if (validationErrorDetail !== undefined) {
            localVarQueryParameters['validation_error_detail'] = ObjectSerializer.serialize(validationErrorDetail, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: ModelFileResults;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "ModelFileResults");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Collection endpoint that accepts various query parameters to filter, sort, and paginate ModelSet items. Supports filtering on fields within ModelSet items.
     * @summary List items in the ModelSet collection.
     * @param frame Constant value. Do not set.
     * @param query Query string for searching.
     * @param limit Maximum number of results to return. Default is 25. Use \&#39;all\&#39; for all results.
     * @param sort Fields to sort results by. Prefix with \&#39;-\&#39; for descending order. Can be repeated for multiple sort fields. Does not work with limit&#x3D;all.
     * @param id Filter by @id
     * @param accession Filter by accession
     * @param aliases Filter by aliases
     * @param alternateAccessions Filter by alternate_accessions
     * @param assessedGenes Filter by assessed_genes
     * @param awardId Filter by award.@id
     * @param awardComponent Filter by award.component
     * @param awardContactPiId Filter by award.contact_pi.@id
     * @param awardContactPiTitle Filter by award.contact_pi.title
     * @param awardTitle Filter by award.title
     * @param collections Filter by collections
     * @param controlForId Filter by control_for.@id
     * @param controlForAccession Filter by control_for.accession
     * @param controlForAliases Filter by control_for.aliases
     * @param creationTimestamp Filter by creation_timestamp
     * @param dbxrefs Filter by dbxrefs
     * @param description Filter by description
     * @param documents Filter by documents
     * @param donorsId Filter by donors.@id
     * @param donorsAccession Filter by donors.accession
     * @param donorsAliases Filter by donors.aliases
     * @param donorsSex Filter by donors.sex
     * @param donorsStatus Filter by donors.status
     * @param donorsTaxa Filter by donors.taxa
     * @param fileSetType Filter by file_set_type
     * @param filesId Filter by files.@id
     * @param filesAccession Filter by files.accession
     * @param filesAliases Filter by files.aliases
     * @param filesContentType Filter by files.content_type
     * @param filesCreationTimestamp Filter by files.creation_timestamp
     * @param filesFileFormat Filter by files.file_format
     * @param filesFileSize Filter by files.file_size
     * @param filesHref Filter by files.href
     * @param filesS3Uri Filter by files.s3_uri
     * @param filesSequencingPlatform Filter by files.sequencing_platform
     * @param filesSubmittedFileName Filter by files.submitted_file_name
     * @param filesUploadStatus Filter by files.upload_status
     * @param inputFileSetFor Filter by input_file_set_for
     * @param inputFileSetsId Filter by input_file_sets.@id
     * @param inputFileSetsAccession Filter by input_file_sets.accession
     * @param inputFileSetsAliases Filter by input_file_sets.aliases
     * @param labId Filter by lab.@id
     * @param labTitle Filter by lab.title
     * @param modelName Filter by model_name
     * @param modelVersion Filter by model_version
     * @param modelZooLocation Filter by model_zoo_location
     * @param notes Filter by notes
     * @param predictionObjects Filter by prediction_objects
     * @param publicationIdentifiers Filter by publication_identifiers
     * @param publications Filter by publications
     * @param releaseTimestamp Filter by release_timestamp
     * @param revokeDetail Filter by revoke_detail
     * @param samplesId Filter by samples.@id
     * @param samplesAccession Filter by samples.accession
     * @param samplesAliases Filter by samples.aliases
     * @param samplesCellFateChangeTreatments Filter by samples.cell_fate_change_treatments
     * @param samplesClassifications Filter by samples.classifications
     * @param samplesConstructLibrarySets Filter by samples.construct_library_sets
     * @param samplesDiseaseTermsId Filter by samples.disease_terms.@id
     * @param samplesDiseaseTermsTermName Filter by samples.disease_terms.term_name
     * @param samplesModifications Filter by samples.modifications
     * @param samplesSampleTermsId Filter by samples.sample_terms.@id
     * @param samplesSampleTermsAliases Filter by samples.sample_terms.aliases
     * @param samplesSampleTermsStatus Filter by samples.sample_terms.status
     * @param samplesSampleTermsSummary Filter by samples.sample_terms.summary
     * @param samplesSampleTermsTermName Filter by samples.sample_terms.term_name
     * @param samplesStatus Filter by samples.status
     * @param samplesSummary Filter by samples.summary
     * @param samplesTargetedSampleTermId Filter by samples.targeted_sample_term.@id
     * @param samplesTargetedSampleTermTermName Filter by samples.targeted_sample_term.term_name
     * @param samplesTaxa Filter by samples.taxa
     * @param samplesTreatments Filter by samples.treatments
     * @param softwareVersion Filter by software_version
     * @param status Filter by status
     * @param submittedById Filter by submitted_by.@id
     * @param submittedByTitle Filter by submitted_by.title
     * @param submittedFilesTimestamp Filter by submitted_files_timestamp
     * @param submitterComment Filter by submitter_comment
     * @param summary Filter by summary
     * @param url Filter by url
     * @param uuid Filter by uuid
     */
    public async modelSets (frame: 'object', query?: string, limit?: Limit, sort?: Array<string>, id?: Array<string>, accession?: Array<string>, aliases?: Array<string>, alternateAccessions?: Array<string>, assessedGenes?: Array<string>, awardId?: Array<string>, awardComponent?: Array<'affiliate' | 'data analysis' | 'data coordination' | 'functional characterization' | 'mapping' | 'networks' | 'predictive modeling'>, awardContactPiId?: Array<string>, awardContactPiTitle?: Array<string>, awardTitle?: Array<string>, collections?: Array<'ClinGen' | 'ENCODE' | 'GREGoR' | 'IGVF_catalog_beta_v0.1' | 'IGVF_catalog_beta_v0.2' | 'IGVF_catalog_beta_v0.3' | 'IGVF_catalog_beta_v0.4' | 'MaveDB' | 'MPRAbase' | 'Vista'>, controlForId?: Array<string>, controlForAccession?: Array<string>, controlForAliases?: Array<string>, creationTimestamp?: Array<string>, dbxrefs?: Array<string>, description?: Array<string>, documents?: Array<string>, donorsId?: Array<string>, donorsAccession?: Array<string>, donorsAliases?: Array<string>, donorsSex?: Array<'male' | 'female' | 'unspecified'>, donorsStatus?: Array<'in progress' | 'released' | 'deleted' | 'replaced' | 'revoked' | 'archived'>, donorsTaxa?: Array<string>, fileSetType?: Array<'neural network' | 'random forest' | 'decision tree' | 'support vector machine' | 'variant binding effect'>, filesId?: Array<string>, filesAccession?: Array<string>, filesAliases?: Array<string>, filesContentType?: Array<string>, filesCreationTimestamp?: Array<string>, filesFileFormat?: Array<string>, filesFileSize?: Array<number>, filesHref?: Array<string>, filesS3Uri?: Array<string>, filesSequencingPlatform?: Array<string>, filesSubmittedFileName?: Array<string>, filesUploadStatus?: Array<'pending' | 'file not found' | 'invalidated' | 'validated'>, inputFileSetFor?: Array<string>, inputFileSetsId?: Array<string>, inputFileSetsAccession?: Array<string>, inputFileSetsAliases?: Array<string>, labId?: Array<string>, labTitle?: Array<string>, modelName?: Array<string>, modelVersion?: Array<string>, modelZooLocation?: Array<string>, notes?: Array<string>, predictionObjects?: Array<'coding variants' | 'non-coding variants' | 'all variants' | 'regulatory elements' | 'genes'>, publicationIdentifiers?: Array<string>, publications?: Array<string>, releaseTimestamp?: Array<string>, revokeDetail?: Array<string>, samplesId?: Array<string>, samplesAccession?: Array<string>, samplesAliases?: Array<string>, samplesCellFateChangeTreatments?: Array<string>, samplesClassifications?: Array<'organoid' | 'gastruloid' | 'embryoid' | 'cell line' | 'differentiated cell specimen' | 'reprogrammed cell specimen' | 'pooled cell specimen'>, samplesConstructLibrarySets?: Array<string>, samplesDiseaseTermsId?: Array<string>, samplesDiseaseTermsTermName?: Array<string>, samplesModifications?: Array<string>, samplesSampleTermsId?: Array<string>, samplesSampleTermsAliases?: Array<string>, samplesSampleTermsStatus?: Array<'archived' | 'deleted' | 'in progress' | 'released'>, samplesSampleTermsSummary?: Array<string>, samplesSampleTermsTermName?: Array<string>, samplesStatus?: Array<'in progress' | 'released' | 'deleted' | 'replaced' | 'revoked' | 'archived'>, samplesSummary?: Array<string>, samplesTargetedSampleTermId?: Array<string>, samplesTargetedSampleTermTermName?: Array<string>, samplesTaxa?: Array<'Homo sapiens' | 'Mus musculus'>, samplesTreatments?: Array<string>, softwareVersion?: Array<string>, status?: Array<'in progress' | 'released' | 'deleted' | 'replaced' | 'revoked' | 'archived'>, submittedById?: Array<string>, submittedByTitle?: Array<string>, submittedFilesTimestamp?: Array<string>, submitterComment?: Array<string>, summary?: Array<string>, url?: Array<string>, uuid?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: ModelSetResults;  }> {
        const localVarPath = this.basePath + '/model-sets/@@listing';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'frame' is not null or undefined
        if (frame === null || frame === undefined) {
            throw new Error('Required parameter frame was null or undefined when calling modelSets.');
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (frame !== undefined) {
            localVarQueryParameters['frame'] = ObjectSerializer.serialize(frame, "'object'");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "Limit");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "Array<string>");
        }

        if (id !== undefined) {
            localVarQueryParameters['@id'] = ObjectSerializer.serialize(id, "Array<string>");
        }

        if (accession !== undefined) {
            localVarQueryParameters['accession'] = ObjectSerializer.serialize(accession, "Array<string>");
        }

        if (aliases !== undefined) {
            localVarQueryParameters['aliases'] = ObjectSerializer.serialize(aliases, "Array<string>");
        }

        if (alternateAccessions !== undefined) {
            localVarQueryParameters['alternate_accessions'] = ObjectSerializer.serialize(alternateAccessions, "Array<string>");
        }

        if (assessedGenes !== undefined) {
            localVarQueryParameters['assessed_genes'] = ObjectSerializer.serialize(assessedGenes, "Array<string>");
        }

        if (awardId !== undefined) {
            localVarQueryParameters['award.@id'] = ObjectSerializer.serialize(awardId, "Array<string>");
        }

        if (awardComponent !== undefined) {
            localVarQueryParameters['award.component'] = ObjectSerializer.serialize(awardComponent, "Array<'affiliate' | 'data analysis' | 'data coordination' | 'functional characterization' | 'mapping' | 'networks' | 'predictive modeling'>");
        }

        if (awardContactPiId !== undefined) {
            localVarQueryParameters['award.contact_pi.@id'] = ObjectSerializer.serialize(awardContactPiId, "Array<string>");
        }

        if (awardContactPiTitle !== undefined) {
            localVarQueryParameters['award.contact_pi.title'] = ObjectSerializer.serialize(awardContactPiTitle, "Array<string>");
        }

        if (awardTitle !== undefined) {
            localVarQueryParameters['award.title'] = ObjectSerializer.serialize(awardTitle, "Array<string>");
        }

        if (collections !== undefined) {
            localVarQueryParameters['collections'] = ObjectSerializer.serialize(collections, "Array<'ClinGen' | 'ENCODE' | 'GREGoR' | 'IGVF_catalog_beta_v0.1' | 'IGVF_catalog_beta_v0.2' | 'IGVF_catalog_beta_v0.3' | 'IGVF_catalog_beta_v0.4' | 'MaveDB' | 'MPRAbase' | 'Vista'>");
        }

        if (controlForId !== undefined) {
            localVarQueryParameters['control_for.@id'] = ObjectSerializer.serialize(controlForId, "Array<string>");
        }

        if (controlForAccession !== undefined) {
            localVarQueryParameters['control_for.accession'] = ObjectSerializer.serialize(controlForAccession, "Array<string>");
        }

        if (controlForAliases !== undefined) {
            localVarQueryParameters['control_for.aliases'] = ObjectSerializer.serialize(controlForAliases, "Array<string>");
        }

        if (creationTimestamp !== undefined) {
            localVarQueryParameters['creation_timestamp'] = ObjectSerializer.serialize(creationTimestamp, "Array<string>");
        }

        if (dbxrefs !== undefined) {
            localVarQueryParameters['dbxrefs'] = ObjectSerializer.serialize(dbxrefs, "Array<string>");
        }

        if (description !== undefined) {
            localVarQueryParameters['description'] = ObjectSerializer.serialize(description, "Array<string>");
        }

        if (documents !== undefined) {
            localVarQueryParameters['documents'] = ObjectSerializer.serialize(documents, "Array<string>");
        }

        if (donorsId !== undefined) {
            localVarQueryParameters['donors.@id'] = ObjectSerializer.serialize(donorsId, "Array<string>");
        }

        if (donorsAccession !== undefined) {
            localVarQueryParameters['donors.accession'] = ObjectSerializer.serialize(donorsAccession, "Array<string>");
        }

        if (donorsAliases !== undefined) {
            localVarQueryParameters['donors.aliases'] = ObjectSerializer.serialize(donorsAliases, "Array<string>");
        }

        if (donorsSex !== undefined) {
            localVarQueryParameters['donors.sex'] = ObjectSerializer.serialize(donorsSex, "Array<'male' | 'female' | 'unspecified'>");
        }

        if (donorsStatus !== undefined) {
            localVarQueryParameters['donors.status'] = ObjectSerializer.serialize(donorsStatus, "Array<'in progress' | 'released' | 'deleted' | 'replaced' | 'revoked' | 'archived'>");
        }

        if (donorsTaxa !== undefined) {
            localVarQueryParameters['donors.taxa'] = ObjectSerializer.serialize(donorsTaxa, "Array<string>");
        }

        if (fileSetType !== undefined) {
            localVarQueryParameters['file_set_type'] = ObjectSerializer.serialize(fileSetType, "Array<'neural network' | 'random forest' | 'decision tree' | 'support vector machine' | 'variant binding effect'>");
        }

        if (filesId !== undefined) {
            localVarQueryParameters['files.@id'] = ObjectSerializer.serialize(filesId, "Array<string>");
        }

        if (filesAccession !== undefined) {
            localVarQueryParameters['files.accession'] = ObjectSerializer.serialize(filesAccession, "Array<string>");
        }

        if (filesAliases !== undefined) {
            localVarQueryParameters['files.aliases'] = ObjectSerializer.serialize(filesAliases, "Array<string>");
        }

        if (filesContentType !== undefined) {
            localVarQueryParameters['files.content_type'] = ObjectSerializer.serialize(filesContentType, "Array<string>");
        }

        if (filesCreationTimestamp !== undefined) {
            localVarQueryParameters['files.creation_timestamp'] = ObjectSerializer.serialize(filesCreationTimestamp, "Array<string>");
        }

        if (filesFileFormat !== undefined) {
            localVarQueryParameters['files.file_format'] = ObjectSerializer.serialize(filesFileFormat, "Array<string>");
        }

        if (filesFileSize !== undefined) {
            localVarQueryParameters['files.file_size'] = ObjectSerializer.serialize(filesFileSize, "Array<number>");
        }

        if (filesHref !== undefined) {
            localVarQueryParameters['files.href'] = ObjectSerializer.serialize(filesHref, "Array<string>");
        }

        if (filesS3Uri !== undefined) {
            localVarQueryParameters['files.s3_uri'] = ObjectSerializer.serialize(filesS3Uri, "Array<string>");
        }

        if (filesSequencingPlatform !== undefined) {
            localVarQueryParameters['files.sequencing_platform'] = ObjectSerializer.serialize(filesSequencingPlatform, "Array<string>");
        }

        if (filesSubmittedFileName !== undefined) {
            localVarQueryParameters['files.submitted_file_name'] = ObjectSerializer.serialize(filesSubmittedFileName, "Array<string>");
        }

        if (filesUploadStatus !== undefined) {
            localVarQueryParameters['files.upload_status'] = ObjectSerializer.serialize(filesUploadStatus, "Array<'pending' | 'file not found' | 'invalidated' | 'validated'>");
        }

        if (inputFileSetFor !== undefined) {
            localVarQueryParameters['input_file_set_for'] = ObjectSerializer.serialize(inputFileSetFor, "Array<string>");
        }

        if (inputFileSetsId !== undefined) {
            localVarQueryParameters['input_file_sets.@id'] = ObjectSerializer.serialize(inputFileSetsId, "Array<string>");
        }

        if (inputFileSetsAccession !== undefined) {
            localVarQueryParameters['input_file_sets.accession'] = ObjectSerializer.serialize(inputFileSetsAccession, "Array<string>");
        }

        if (inputFileSetsAliases !== undefined) {
            localVarQueryParameters['input_file_sets.aliases'] = ObjectSerializer.serialize(inputFileSetsAliases, "Array<string>");
        }

        if (labId !== undefined) {
            localVarQueryParameters['lab.@id'] = ObjectSerializer.serialize(labId, "Array<string>");
        }

        if (labTitle !== undefined) {
            localVarQueryParameters['lab.title'] = ObjectSerializer.serialize(labTitle, "Array<string>");
        }

        if (modelName !== undefined) {
            localVarQueryParameters['model_name'] = ObjectSerializer.serialize(modelName, "Array<string>");
        }

        if (modelVersion !== undefined) {
            localVarQueryParameters['model_version'] = ObjectSerializer.serialize(modelVersion, "Array<string>");
        }

        if (modelZooLocation !== undefined) {
            localVarQueryParameters['model_zoo_location'] = ObjectSerializer.serialize(modelZooLocation, "Array<string>");
        }

        if (notes !== undefined) {
            localVarQueryParameters['notes'] = ObjectSerializer.serialize(notes, "Array<string>");
        }

        if (predictionObjects !== undefined) {
            localVarQueryParameters['prediction_objects'] = ObjectSerializer.serialize(predictionObjects, "Array<'coding variants' | 'non-coding variants' | 'all variants' | 'regulatory elements' | 'genes'>");
        }

        if (publicationIdentifiers !== undefined) {
            localVarQueryParameters['publication_identifiers'] = ObjectSerializer.serialize(publicationIdentifiers, "Array<string>");
        }

        if (publications !== undefined) {
            localVarQueryParameters['publications'] = ObjectSerializer.serialize(publications, "Array<string>");
        }

        if (releaseTimestamp !== undefined) {
            localVarQueryParameters['release_timestamp'] = ObjectSerializer.serialize(releaseTimestamp, "Array<string>");
        }

        if (revokeDetail !== undefined) {
            localVarQueryParameters['revoke_detail'] = ObjectSerializer.serialize(revokeDetail, "Array<string>");
        }

        if (samplesId !== undefined) {
            localVarQueryParameters['samples.@id'] = ObjectSerializer.serialize(samplesId, "Array<string>");
        }

        if (samplesAccession !== undefined) {
            localVarQueryParameters['samples.accession'] = ObjectSerializer.serialize(samplesAccession, "Array<string>");
        }

        if (samplesAliases !== undefined) {
            localVarQueryParameters['samples.aliases'] = ObjectSerializer.serialize(samplesAliases, "Array<string>");
        }

        if (samplesCellFateChangeTreatments !== undefined) {
            localVarQueryParameters['samples.cell_fate_change_treatments'] = ObjectSerializer.serialize(samplesCellFateChangeTreatments, "Array<string>");
        }

        if (samplesClassifications !== undefined) {
            localVarQueryParameters['samples.classifications'] = ObjectSerializer.serialize(samplesClassifications, "Array<'organoid' | 'gastruloid' | 'embryoid' | 'cell line' | 'differentiated cell specimen' | 'reprogrammed cell specimen' | 'pooled cell specimen'>");
        }

        if (samplesConstructLibrarySets !== undefined) {
            localVarQueryParameters['samples.construct_library_sets'] = ObjectSerializer.serialize(samplesConstructLibrarySets, "Array<string>");
        }

        if (samplesDiseaseTermsId !== undefined) {
            localVarQueryParameters['samples.disease_terms.@id'] = ObjectSerializer.serialize(samplesDiseaseTermsId, "Array<string>");
        }

        if (samplesDiseaseTermsTermName !== undefined) {
            localVarQueryParameters['samples.disease_terms.term_name'] = ObjectSerializer.serialize(samplesDiseaseTermsTermName, "Array<string>");
        }

        if (samplesModifications !== undefined) {
            localVarQueryParameters['samples.modifications'] = ObjectSerializer.serialize(samplesModifications, "Array<string>");
        }

        if (samplesSampleTermsId !== undefined) {
            localVarQueryParameters['samples.sample_terms.@id'] = ObjectSerializer.serialize(samplesSampleTermsId, "Array<string>");
        }

        if (samplesSampleTermsAliases !== undefined) {
            localVarQueryParameters['samples.sample_terms.aliases'] = ObjectSerializer.serialize(samplesSampleTermsAliases, "Array<string>");
        }

        if (samplesSampleTermsStatus !== undefined) {
            localVarQueryParameters['samples.sample_terms.status'] = ObjectSerializer.serialize(samplesSampleTermsStatus, "Array<'archived' | 'deleted' | 'in progress' | 'released'>");
        }

        if (samplesSampleTermsSummary !== undefined) {
            localVarQueryParameters['samples.sample_terms.summary'] = ObjectSerializer.serialize(samplesSampleTermsSummary, "Array<string>");
        }

        if (samplesSampleTermsTermName !== undefined) {
            localVarQueryParameters['samples.sample_terms.term_name'] = ObjectSerializer.serialize(samplesSampleTermsTermName, "Array<string>");
        }

        if (samplesStatus !== undefined) {
            localVarQueryParameters['samples.status'] = ObjectSerializer.serialize(samplesStatus, "Array<'in progress' | 'released' | 'deleted' | 'replaced' | 'revoked' | 'archived'>");
        }

        if (samplesSummary !== undefined) {
            localVarQueryParameters['samples.summary'] = ObjectSerializer.serialize(samplesSummary, "Array<string>");
        }

        if (samplesTargetedSampleTermId !== undefined) {
            localVarQueryParameters['samples.targeted_sample_term.@id'] = ObjectSerializer.serialize(samplesTargetedSampleTermId, "Array<string>");
        }

        if (samplesTargetedSampleTermTermName !== undefined) {
            localVarQueryParameters['samples.targeted_sample_term.term_name'] = ObjectSerializer.serialize(samplesTargetedSampleTermTermName, "Array<string>");
        }

        if (samplesTaxa !== undefined) {
            localVarQueryParameters['samples.taxa'] = ObjectSerializer.serialize(samplesTaxa, "Array<'Homo sapiens' | 'Mus musculus'>");
        }

        if (samplesTreatments !== undefined) {
            localVarQueryParameters['samples.treatments'] = ObjectSerializer.serialize(samplesTreatments, "Array<string>");
        }

        if (softwareVersion !== undefined) {
            localVarQueryParameters['software_version'] = ObjectSerializer.serialize(softwareVersion, "Array<string>");
        }

        if (status !== undefined) {
            localVarQueryParameters['status'] = ObjectSerializer.serialize(status, "Array<'in progress' | 'released' | 'deleted' | 'replaced' | 'revoked' | 'archived'>");
        }

        if (submittedById !== undefined) {
            localVarQueryParameters['submitted_by.@id'] = ObjectSerializer.serialize(submittedById, "Array<string>");
        }

        if (submittedByTitle !== undefined) {
            localVarQueryParameters['submitted_by.title'] = ObjectSerializer.serialize(submittedByTitle, "Array<string>");
        }

        if (submittedFilesTimestamp !== undefined) {
            localVarQueryParameters['submitted_files_timestamp'] = ObjectSerializer.serialize(submittedFilesTimestamp, "Array<string>");
        }

        if (submitterComment !== undefined) {
            localVarQueryParameters['submitter_comment'] = ObjectSerializer.serialize(submitterComment, "Array<string>");
        }

        if (summary !== undefined) {
            localVarQueryParameters['summary'] = ObjectSerializer.serialize(summary, "Array<string>");
        }

        if (url !== undefined) {
            localVarQueryParameters['url'] = ObjectSerializer.serialize(url, "Array<string>");
        }

        if (uuid !== undefined) {
            localVarQueryParameters['uuid'] = ObjectSerializer.serialize(uuid, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: ModelSetResults;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "ModelSetResults");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Collection endpoint that accepts various query parameters to filter, sort, and paginate MultiplexedSample items. Supports filtering on fields within MultiplexedSample items.
     * @summary List items in the MultiplexedSample collection.
     * @param frame Constant value. Do not set.
     * @param query Query string for searching.
     * @param limit Maximum number of results to return. Default is 25. Use \&#39;all\&#39; for all results.
     * @param sort Fields to sort results by. Prefix with \&#39;-\&#39; for descending order. Can be repeated for multiple sort fields. Does not work with limit&#x3D;all.
     * @param id Filter by @id
     * @param accession Filter by accession
     * @param aliases Filter by aliases
     * @param alternateAccessions Filter by alternate_accessions
     * @param awardId Filter by award.@id
     * @param awardComponent Filter by award.component
     * @param barcodeSampleMap Filter by barcode_sample_map
     * @param biomarkers Filter by biomarkers
     * @param cellularSubPool Filter by cellular_sub_pool
     * @param classifications Filter by classifications
     * @param collections Filter by collections
     * @param constructLibrarySetsId Filter by construct_library_sets.@id
     * @param constructLibrarySetsAccession Filter by construct_library_sets.accession
     * @param creationTimestamp Filter by creation_timestamp
     * @param dateObtained Filter by date_obtained
     * @param dbxrefs Filter by dbxrefs
     * @param description Filter by description
     * @param diseaseTermsId Filter by disease_terms.@id
     * @param diseaseTermsTermName Filter by disease_terms.term_name
     * @param documents Filter by documents
     * @param donors Filter by donors
     * @param fileSetsId Filter by file_sets.@id
     * @param fileSetsAccession Filter by file_sets.accession
     * @param fileSetsAliases Filter by file_sets.aliases
     * @param fileSetsAssayTermTermName Filter by file_sets.assay_term.term_name
     * @param fileSetsLabTitle Filter by file_sets.lab.title
     * @param fileSetsStatus Filter by file_sets.status
     * @param fileSetsSummary Filter by file_sets.summary
     * @param institutionalCertificates Filter by institutional_certificates
     * @param labId Filter by lab.@id
     * @param labTitle Filter by lab.title
     * @param modificationsId Filter by modifications.@id
     * @param modificationsStatus Filter by modifications.status
     * @param modificationsSummary Filter by modifications.summary
     * @param moi Filter by moi
     * @param multiplexedInId Filter by multiplexed_in.@id
     * @param multiplexedInAccession Filter by multiplexed_in.accession
     * @param multiplexedSamplesId Filter by multiplexed_samples.@id
     * @param multiplexedSamplesAccession Filter by multiplexed_samples.accession
     * @param multiplexedSamplesConstructLibrarySets Filter by multiplexed_samples.construct_library_sets
     * @param multiplexedSamplesDiseaseTermsId Filter by multiplexed_samples.disease_terms.@id
     * @param multiplexedSamplesDiseaseTermsTermName Filter by multiplexed_samples.disease_terms.term_name
     * @param multiplexedSamplesDonorsId Filter by multiplexed_samples.donors.@id
     * @param multiplexedSamplesDonorsAccession Filter by multiplexed_samples.donors.accession
     * @param multiplexedSamplesSampleTermsId Filter by multiplexed_samples.sample_terms.@id
     * @param multiplexedSamplesSampleTermsTermName Filter by multiplexed_samples.sample_terms.term_name
     * @param multiplexedSamplesStatus Filter by multiplexed_samples.status
     * @param multiplexedSamplesSummary Filter by multiplexed_samples.summary
     * @param notes Filter by notes
     * @param nucleicAcidDelivery Filter by nucleic_acid_delivery
     * @param originOf Filter by origin_of
     * @param protocols Filter by protocols
     * @param publicationIdentifiers Filter by publication_identifiers
     * @param publications Filter by publications
     * @param releaseTimestamp Filter by release_timestamp
     * @param revokeDetail Filter by revoke_detail
     * @param sampleTermsId Filter by sample_terms.@id
     * @param sampleTermsTermName Filter by sample_terms.term_name
     * @param sortedFractions Filter by sorted_fractions
     * @param sortedFromId Filter by sorted_from.@id
     * @param sortedFromAccession Filter by sorted_from.accession
     * @param sortedFromDetail Filter by sorted_from_detail
     * @param sourcesId Filter by sources.@id
     * @param startingAmount Filter by starting_amount
     * @param startingAmountUnits Filter by starting_amount_units
     * @param status Filter by status
     * @param submittedById Filter by submitted_by.@id
     * @param submittedByTitle Filter by submitted_by.title
     * @param submitterComment Filter by submitter_comment
     * @param summary Filter by summary
     * @param timePostLibraryDelivery Filter by time_post_library_delivery
     * @param timePostLibraryDeliveryUnits Filter by time_post_library_delivery_units
     * @param treatmentsId Filter by treatments.@id
     * @param treatmentsPurpose Filter by treatments.purpose
     * @param treatmentsStatus Filter by treatments.status
     * @param treatmentsSummary Filter by treatments.summary
     * @param treatmentsTreatmentType Filter by treatments.treatment_type
     * @param url Filter by url
     * @param uuid Filter by uuid
     * @param virtual Filter by virtual
     */
    public async multiplexedSamples (frame: 'object', query?: string, limit?: Limit, sort?: Array<string>, id?: Array<string>, accession?: Array<string>, aliases?: Array<string>, alternateAccessions?: Array<string>, awardId?: Array<string>, awardComponent?: Array<'affiliate' | 'data analysis' | 'data coordination' | 'functional characterization' | 'mapping' | 'networks' | 'predictive modeling'>, barcodeSampleMap?: Array<string>, biomarkers?: Array<string>, cellularSubPool?: Array<string>, classifications?: Array<string>, collections?: Array<'ClinGen' | 'ENCODE' | 'GREGoR' | 'IGVF_catalog_beta_v0.1' | 'IGVF_catalog_beta_v0.2' | 'IGVF_catalog_beta_v0.3' | 'IGVF_catalog_beta_v0.4' | 'MaveDB' | 'MPRAbase' | 'Vista'>, constructLibrarySetsId?: Array<string>, constructLibrarySetsAccession?: Array<string>, creationTimestamp?: Array<string>, dateObtained?: Array<string>, dbxrefs?: Array<string>, description?: Array<string>, diseaseTermsId?: Array<string>, diseaseTermsTermName?: Array<string>, documents?: Array<string>, donors?: Array<string>, fileSetsId?: Array<string>, fileSetsAccession?: Array<string>, fileSetsAliases?: Array<string>, fileSetsAssayTermTermName?: Array<string>, fileSetsLabTitle?: Array<string>, fileSetsStatus?: Array<'in progress' | 'released' | 'deleted' | 'replaced' | 'revoked' | 'archived'>, fileSetsSummary?: Array<string>, institutionalCertificates?: Array<string>, labId?: Array<string>, labTitle?: Array<string>, modificationsId?: Array<string>, modificationsStatus?: Array<'archived' | 'deleted' | 'in progress' | 'released'>, modificationsSummary?: Array<string>, moi?: Array<number>, multiplexedInId?: Array<string>, multiplexedInAccession?: Array<string>, multiplexedSamplesId?: Array<string>, multiplexedSamplesAccession?: Array<string>, multiplexedSamplesConstructLibrarySets?: Array<string>, multiplexedSamplesDiseaseTermsId?: Array<string>, multiplexedSamplesDiseaseTermsTermName?: Array<string>, multiplexedSamplesDonorsId?: Array<string>, multiplexedSamplesDonorsAccession?: Array<string>, multiplexedSamplesSampleTermsId?: Array<string>, multiplexedSamplesSampleTermsTermName?: Array<string>, multiplexedSamplesStatus?: Array<'in progress' | 'released' | 'deleted' | 'replaced' | 'revoked' | 'archived'>, multiplexedSamplesSummary?: Array<string>, notes?: Array<string>, nucleicAcidDelivery?: Array<'transfection' | 'adenoviral transduction' | 'lentiviral transduction'>, originOf?: Array<string>, protocols?: Array<string>, publicationIdentifiers?: Array<string>, publications?: Array<string>, releaseTimestamp?: Array<string>, revokeDetail?: Array<string>, sampleTermsId?: Array<string>, sampleTermsTermName?: Array<string>, sortedFractions?: Array<string>, sortedFromId?: Array<string>, sortedFromAccession?: Array<string>, sortedFromDetail?: Array<string>, sourcesId?: Array<string>, startingAmount?: Array<number>, startingAmountUnits?: Array<'cells' | 'cells/ml' | 'g' | 'items' | 'mg' | 'whole animals' | 'whole embryos' | 'μg' | 'ng'>, status?: Array<'in progress' | 'released' | 'deleted' | 'replaced' | 'revoked' | 'archived'>, submittedById?: Array<string>, submittedByTitle?: Array<string>, submitterComment?: Array<string>, summary?: Array<string>, timePostLibraryDelivery?: Array<number>, timePostLibraryDeliveryUnits?: Array<'minute' | 'hour' | 'day' | 'week' | 'month'>, treatmentsId?: Array<string>, treatmentsPurpose?: Array<'activation' | 'agonist' | 'antagonist' | 'control' | 'differentiation' | 'de-differentiation' | 'perturbation' | 'selection' | 'stimulation'>, treatmentsStatus?: Array<'archived' | 'deleted' | 'in progress' | 'released'>, treatmentsSummary?: Array<string>, treatmentsTreatmentType?: Array<'chemical' | 'protein' | 'environmental'>, url?: Array<string>, uuid?: Array<string>, virtual?: Array<boolean>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: MultiplexedSampleResults;  }> {
        const localVarPath = this.basePath + '/multiplexed-samples/@@listing';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'frame' is not null or undefined
        if (frame === null || frame === undefined) {
            throw new Error('Required parameter frame was null or undefined when calling multiplexedSamples.');
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (frame !== undefined) {
            localVarQueryParameters['frame'] = ObjectSerializer.serialize(frame, "'object'");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "Limit");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "Array<string>");
        }

        if (id !== undefined) {
            localVarQueryParameters['@id'] = ObjectSerializer.serialize(id, "Array<string>");
        }

        if (accession !== undefined) {
            localVarQueryParameters['accession'] = ObjectSerializer.serialize(accession, "Array<string>");
        }

        if (aliases !== undefined) {
            localVarQueryParameters['aliases'] = ObjectSerializer.serialize(aliases, "Array<string>");
        }

        if (alternateAccessions !== undefined) {
            localVarQueryParameters['alternate_accessions'] = ObjectSerializer.serialize(alternateAccessions, "Array<string>");
        }

        if (awardId !== undefined) {
            localVarQueryParameters['award.@id'] = ObjectSerializer.serialize(awardId, "Array<string>");
        }

        if (awardComponent !== undefined) {
            localVarQueryParameters['award.component'] = ObjectSerializer.serialize(awardComponent, "Array<'affiliate' | 'data analysis' | 'data coordination' | 'functional characterization' | 'mapping' | 'networks' | 'predictive modeling'>");
        }

        if (barcodeSampleMap !== undefined) {
            localVarQueryParameters['barcode_sample_map'] = ObjectSerializer.serialize(barcodeSampleMap, "Array<string>");
        }

        if (biomarkers !== undefined) {
            localVarQueryParameters['biomarkers'] = ObjectSerializer.serialize(biomarkers, "Array<string>");
        }

        if (cellularSubPool !== undefined) {
            localVarQueryParameters['cellular_sub_pool'] = ObjectSerializer.serialize(cellularSubPool, "Array<string>");
        }

        if (classifications !== undefined) {
            localVarQueryParameters['classifications'] = ObjectSerializer.serialize(classifications, "Array<string>");
        }

        if (collections !== undefined) {
            localVarQueryParameters['collections'] = ObjectSerializer.serialize(collections, "Array<'ClinGen' | 'ENCODE' | 'GREGoR' | 'IGVF_catalog_beta_v0.1' | 'IGVF_catalog_beta_v0.2' | 'IGVF_catalog_beta_v0.3' | 'IGVF_catalog_beta_v0.4' | 'MaveDB' | 'MPRAbase' | 'Vista'>");
        }

        if (constructLibrarySetsId !== undefined) {
            localVarQueryParameters['construct_library_sets.@id'] = ObjectSerializer.serialize(constructLibrarySetsId, "Array<string>");
        }

        if (constructLibrarySetsAccession !== undefined) {
            localVarQueryParameters['construct_library_sets.accession'] = ObjectSerializer.serialize(constructLibrarySetsAccession, "Array<string>");
        }

        if (creationTimestamp !== undefined) {
            localVarQueryParameters['creation_timestamp'] = ObjectSerializer.serialize(creationTimestamp, "Array<string>");
        }

        if (dateObtained !== undefined) {
            localVarQueryParameters['date_obtained'] = ObjectSerializer.serialize(dateObtained, "Array<string>");
        }

        if (dbxrefs !== undefined) {
            localVarQueryParameters['dbxrefs'] = ObjectSerializer.serialize(dbxrefs, "Array<string>");
        }

        if (description !== undefined) {
            localVarQueryParameters['description'] = ObjectSerializer.serialize(description, "Array<string>");
        }

        if (diseaseTermsId !== undefined) {
            localVarQueryParameters['disease_terms.@id'] = ObjectSerializer.serialize(diseaseTermsId, "Array<string>");
        }

        if (diseaseTermsTermName !== undefined) {
            localVarQueryParameters['disease_terms.term_name'] = ObjectSerializer.serialize(diseaseTermsTermName, "Array<string>");
        }

        if (documents !== undefined) {
            localVarQueryParameters['documents'] = ObjectSerializer.serialize(documents, "Array<string>");
        }

        if (donors !== undefined) {
            localVarQueryParameters['donors'] = ObjectSerializer.serialize(donors, "Array<string>");
        }

        if (fileSetsId !== undefined) {
            localVarQueryParameters['file_sets.@id'] = ObjectSerializer.serialize(fileSetsId, "Array<string>");
        }

        if (fileSetsAccession !== undefined) {
            localVarQueryParameters['file_sets.accession'] = ObjectSerializer.serialize(fileSetsAccession, "Array<string>");
        }

        if (fileSetsAliases !== undefined) {
            localVarQueryParameters['file_sets.aliases'] = ObjectSerializer.serialize(fileSetsAliases, "Array<string>");
        }

        if (fileSetsAssayTermTermName !== undefined) {
            localVarQueryParameters['file_sets.assay_term.term_name'] = ObjectSerializer.serialize(fileSetsAssayTermTermName, "Array<string>");
        }

        if (fileSetsLabTitle !== undefined) {
            localVarQueryParameters['file_sets.lab.title'] = ObjectSerializer.serialize(fileSetsLabTitle, "Array<string>");
        }

        if (fileSetsStatus !== undefined) {
            localVarQueryParameters['file_sets.status'] = ObjectSerializer.serialize(fileSetsStatus, "Array<'in progress' | 'released' | 'deleted' | 'replaced' | 'revoked' | 'archived'>");
        }

        if (fileSetsSummary !== undefined) {
            localVarQueryParameters['file_sets.summary'] = ObjectSerializer.serialize(fileSetsSummary, "Array<string>");
        }

        if (institutionalCertificates !== undefined) {
            localVarQueryParameters['institutional_certificates'] = ObjectSerializer.serialize(institutionalCertificates, "Array<string>");
        }

        if (labId !== undefined) {
            localVarQueryParameters['lab.@id'] = ObjectSerializer.serialize(labId, "Array<string>");
        }

        if (labTitle !== undefined) {
            localVarQueryParameters['lab.title'] = ObjectSerializer.serialize(labTitle, "Array<string>");
        }

        if (modificationsId !== undefined) {
            localVarQueryParameters['modifications.@id'] = ObjectSerializer.serialize(modificationsId, "Array<string>");
        }

        if (modificationsStatus !== undefined) {
            localVarQueryParameters['modifications.status'] = ObjectSerializer.serialize(modificationsStatus, "Array<'archived' | 'deleted' | 'in progress' | 'released'>");
        }

        if (modificationsSummary !== undefined) {
            localVarQueryParameters['modifications.summary'] = ObjectSerializer.serialize(modificationsSummary, "Array<string>");
        }

        if (moi !== undefined) {
            localVarQueryParameters['moi'] = ObjectSerializer.serialize(moi, "Array<number>");
        }

        if (multiplexedInId !== undefined) {
            localVarQueryParameters['multiplexed_in.@id'] = ObjectSerializer.serialize(multiplexedInId, "Array<string>");
        }

        if (multiplexedInAccession !== undefined) {
            localVarQueryParameters['multiplexed_in.accession'] = ObjectSerializer.serialize(multiplexedInAccession, "Array<string>");
        }

        if (multiplexedSamplesId !== undefined) {
            localVarQueryParameters['multiplexed_samples.@id'] = ObjectSerializer.serialize(multiplexedSamplesId, "Array<string>");
        }

        if (multiplexedSamplesAccession !== undefined) {
            localVarQueryParameters['multiplexed_samples.accession'] = ObjectSerializer.serialize(multiplexedSamplesAccession, "Array<string>");
        }

        if (multiplexedSamplesConstructLibrarySets !== undefined) {
            localVarQueryParameters['multiplexed_samples.construct_library_sets'] = ObjectSerializer.serialize(multiplexedSamplesConstructLibrarySets, "Array<string>");
        }

        if (multiplexedSamplesDiseaseTermsId !== undefined) {
            localVarQueryParameters['multiplexed_samples.disease_terms.@id'] = ObjectSerializer.serialize(multiplexedSamplesDiseaseTermsId, "Array<string>");
        }

        if (multiplexedSamplesDiseaseTermsTermName !== undefined) {
            localVarQueryParameters['multiplexed_samples.disease_terms.term_name'] = ObjectSerializer.serialize(multiplexedSamplesDiseaseTermsTermName, "Array<string>");
        }

        if (multiplexedSamplesDonorsId !== undefined) {
            localVarQueryParameters['multiplexed_samples.donors.@id'] = ObjectSerializer.serialize(multiplexedSamplesDonorsId, "Array<string>");
        }

        if (multiplexedSamplesDonorsAccession !== undefined) {
            localVarQueryParameters['multiplexed_samples.donors.accession'] = ObjectSerializer.serialize(multiplexedSamplesDonorsAccession, "Array<string>");
        }

        if (multiplexedSamplesSampleTermsId !== undefined) {
            localVarQueryParameters['multiplexed_samples.sample_terms.@id'] = ObjectSerializer.serialize(multiplexedSamplesSampleTermsId, "Array<string>");
        }

        if (multiplexedSamplesSampleTermsTermName !== undefined) {
            localVarQueryParameters['multiplexed_samples.sample_terms.term_name'] = ObjectSerializer.serialize(multiplexedSamplesSampleTermsTermName, "Array<string>");
        }

        if (multiplexedSamplesStatus !== undefined) {
            localVarQueryParameters['multiplexed_samples.status'] = ObjectSerializer.serialize(multiplexedSamplesStatus, "Array<'in progress' | 'released' | 'deleted' | 'replaced' | 'revoked' | 'archived'>");
        }

        if (multiplexedSamplesSummary !== undefined) {
            localVarQueryParameters['multiplexed_samples.summary'] = ObjectSerializer.serialize(multiplexedSamplesSummary, "Array<string>");
        }

        if (notes !== undefined) {
            localVarQueryParameters['notes'] = ObjectSerializer.serialize(notes, "Array<string>");
        }

        if (nucleicAcidDelivery !== undefined) {
            localVarQueryParameters['nucleic_acid_delivery'] = ObjectSerializer.serialize(nucleicAcidDelivery, "Array<'transfection' | 'adenoviral transduction' | 'lentiviral transduction'>");
        }

        if (originOf !== undefined) {
            localVarQueryParameters['origin_of'] = ObjectSerializer.serialize(originOf, "Array<string>");
        }

        if (protocols !== undefined) {
            localVarQueryParameters['protocols'] = ObjectSerializer.serialize(protocols, "Array<string>");
        }

        if (publicationIdentifiers !== undefined) {
            localVarQueryParameters['publication_identifiers'] = ObjectSerializer.serialize(publicationIdentifiers, "Array<string>");
        }

        if (publications !== undefined) {
            localVarQueryParameters['publications'] = ObjectSerializer.serialize(publications, "Array<string>");
        }

        if (releaseTimestamp !== undefined) {
            localVarQueryParameters['release_timestamp'] = ObjectSerializer.serialize(releaseTimestamp, "Array<string>");
        }

        if (revokeDetail !== undefined) {
            localVarQueryParameters['revoke_detail'] = ObjectSerializer.serialize(revokeDetail, "Array<string>");
        }

        if (sampleTermsId !== undefined) {
            localVarQueryParameters['sample_terms.@id'] = ObjectSerializer.serialize(sampleTermsId, "Array<string>");
        }

        if (sampleTermsTermName !== undefined) {
            localVarQueryParameters['sample_terms.term_name'] = ObjectSerializer.serialize(sampleTermsTermName, "Array<string>");
        }

        if (sortedFractions !== undefined) {
            localVarQueryParameters['sorted_fractions'] = ObjectSerializer.serialize(sortedFractions, "Array<string>");
        }

        if (sortedFromId !== undefined) {
            localVarQueryParameters['sorted_from.@id'] = ObjectSerializer.serialize(sortedFromId, "Array<string>");
        }

        if (sortedFromAccession !== undefined) {
            localVarQueryParameters['sorted_from.accession'] = ObjectSerializer.serialize(sortedFromAccession, "Array<string>");
        }

        if (sortedFromDetail !== undefined) {
            localVarQueryParameters['sorted_from_detail'] = ObjectSerializer.serialize(sortedFromDetail, "Array<string>");
        }

        if (sourcesId !== undefined) {
            localVarQueryParameters['sources.@id'] = ObjectSerializer.serialize(sourcesId, "Array<string>");
        }

        if (startingAmount !== undefined) {
            localVarQueryParameters['starting_amount'] = ObjectSerializer.serialize(startingAmount, "Array<number>");
        }

        if (startingAmountUnits !== undefined) {
            localVarQueryParameters['starting_amount_units'] = ObjectSerializer.serialize(startingAmountUnits, "Array<'cells' | 'cells/ml' | 'g' | 'items' | 'mg' | 'whole animals' | 'whole embryos' | 'μg' | 'ng'>");
        }

        if (status !== undefined) {
            localVarQueryParameters['status'] = ObjectSerializer.serialize(status, "Array<'in progress' | 'released' | 'deleted' | 'replaced' | 'revoked' | 'archived'>");
        }

        if (submittedById !== undefined) {
            localVarQueryParameters['submitted_by.@id'] = ObjectSerializer.serialize(submittedById, "Array<string>");
        }

        if (submittedByTitle !== undefined) {
            localVarQueryParameters['submitted_by.title'] = ObjectSerializer.serialize(submittedByTitle, "Array<string>");
        }

        if (submitterComment !== undefined) {
            localVarQueryParameters['submitter_comment'] = ObjectSerializer.serialize(submitterComment, "Array<string>");
        }

        if (summary !== undefined) {
            localVarQueryParameters['summary'] = ObjectSerializer.serialize(summary, "Array<string>");
        }

        if (timePostLibraryDelivery !== undefined) {
            localVarQueryParameters['time_post_library_delivery'] = ObjectSerializer.serialize(timePostLibraryDelivery, "Array<number>");
        }

        if (timePostLibraryDeliveryUnits !== undefined) {
            localVarQueryParameters['time_post_library_delivery_units'] = ObjectSerializer.serialize(timePostLibraryDeliveryUnits, "Array<'minute' | 'hour' | 'day' | 'week' | 'month'>");
        }

        if (treatmentsId !== undefined) {
            localVarQueryParameters['treatments.@id'] = ObjectSerializer.serialize(treatmentsId, "Array<string>");
        }

        if (treatmentsPurpose !== undefined) {
            localVarQueryParameters['treatments.purpose'] = ObjectSerializer.serialize(treatmentsPurpose, "Array<'activation' | 'agonist' | 'antagonist' | 'control' | 'differentiation' | 'de-differentiation' | 'perturbation' | 'selection' | 'stimulation'>");
        }

        if (treatmentsStatus !== undefined) {
            localVarQueryParameters['treatments.status'] = ObjectSerializer.serialize(treatmentsStatus, "Array<'archived' | 'deleted' | 'in progress' | 'released'>");
        }

        if (treatmentsSummary !== undefined) {
            localVarQueryParameters['treatments.summary'] = ObjectSerializer.serialize(treatmentsSummary, "Array<string>");
        }

        if (treatmentsTreatmentType !== undefined) {
            localVarQueryParameters['treatments.treatment_type'] = ObjectSerializer.serialize(treatmentsTreatmentType, "Array<'chemical' | 'protein' | 'environmental'>");
        }

        if (url !== undefined) {
            localVarQueryParameters['url'] = ObjectSerializer.serialize(url, "Array<string>");
        }

        if (uuid !== undefined) {
            localVarQueryParameters['uuid'] = ObjectSerializer.serialize(uuid, "Array<string>");
        }

        if (virtual !== undefined) {
            localVarQueryParameters['virtual'] = ObjectSerializer.serialize(virtual, "Array<boolean>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: MultiplexedSampleResults;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "MultiplexedSampleResults");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Collection endpoint that accepts various query parameters to filter, sort, and paginate OpenReadingFrame items. Supports filtering on fields within OpenReadingFrame items.
     * @summary List items in the OpenReadingFrame collection.
     * @param frame Constant value. Do not set.
     * @param query Query string for searching.
     * @param limit Maximum number of results to return. Default is 25. Use \&#39;all\&#39; for all results.
     * @param sort Fields to sort results by. Prefix with \&#39;-\&#39; for descending order. Can be repeated for multiple sort fields. Does not work with limit&#x3D;all.
     * @param id Filter by @id
     * @param aliases Filter by aliases
     * @param award Filter by award
     * @param creationTimestamp Filter by creation_timestamp
     * @param dbxrefs Filter by dbxrefs
     * @param description Filter by description
     * @param geneId Filter by gene.@id
     * @param geneGeneid Filter by gene.geneid
     * @param geneSymbol Filter by gene.symbol
     * @param lab Filter by lab
     * @param notes Filter by notes
     * @param orfId Filter by orf_id
     * @param pctCoverageOrf Filter by pct_coverage_orf
     * @param pctCoverageProtein Filter by pct_coverage_protein
     * @param pctIdenticalProtein Filter by pct_identical_protein
     * @param proteinId Filter by protein_id
     * @param releaseTimestamp Filter by release_timestamp
     * @param status Filter by status
     * @param submittedBy Filter by submitted_by
     * @param submitterComment Filter by submitter_comment
     * @param summary Filter by summary
     * @param uuid Filter by uuid
     */
    public async openReadingFrames (frame: 'object', query?: string, limit?: Limit, sort?: Array<string>, id?: Array<string>, aliases?: Array<string>, award?: Array<string>, creationTimestamp?: Array<string>, dbxrefs?: Array<string>, description?: Array<string>, geneId?: Array<string>, geneGeneid?: Array<string>, geneSymbol?: Array<string>, lab?: Array<string>, notes?: Array<string>, orfId?: Array<string>, pctCoverageOrf?: Array<number>, pctCoverageProtein?: Array<number>, pctIdenticalProtein?: Array<number>, proteinId?: Array<string>, releaseTimestamp?: Array<string>, status?: Array<'archived' | 'deleted' | 'in progress' | 'released'>, submittedBy?: Array<string>, submitterComment?: Array<string>, summary?: Array<string>, uuid?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: OpenReadingFrameResults;  }> {
        const localVarPath = this.basePath + '/open-reading-frames/@@listing';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'frame' is not null or undefined
        if (frame === null || frame === undefined) {
            throw new Error('Required parameter frame was null or undefined when calling openReadingFrames.');
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (frame !== undefined) {
            localVarQueryParameters['frame'] = ObjectSerializer.serialize(frame, "'object'");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "Limit");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "Array<string>");
        }

        if (id !== undefined) {
            localVarQueryParameters['@id'] = ObjectSerializer.serialize(id, "Array<string>");
        }

        if (aliases !== undefined) {
            localVarQueryParameters['aliases'] = ObjectSerializer.serialize(aliases, "Array<string>");
        }

        if (award !== undefined) {
            localVarQueryParameters['award'] = ObjectSerializer.serialize(award, "Array<string>");
        }

        if (creationTimestamp !== undefined) {
            localVarQueryParameters['creation_timestamp'] = ObjectSerializer.serialize(creationTimestamp, "Array<string>");
        }

        if (dbxrefs !== undefined) {
            localVarQueryParameters['dbxrefs'] = ObjectSerializer.serialize(dbxrefs, "Array<string>");
        }

        if (description !== undefined) {
            localVarQueryParameters['description'] = ObjectSerializer.serialize(description, "Array<string>");
        }

        if (geneId !== undefined) {
            localVarQueryParameters['gene.@id'] = ObjectSerializer.serialize(geneId, "Array<string>");
        }

        if (geneGeneid !== undefined) {
            localVarQueryParameters['gene.geneid'] = ObjectSerializer.serialize(geneGeneid, "Array<string>");
        }

        if (geneSymbol !== undefined) {
            localVarQueryParameters['gene.symbol'] = ObjectSerializer.serialize(geneSymbol, "Array<string>");
        }

        if (lab !== undefined) {
            localVarQueryParameters['lab'] = ObjectSerializer.serialize(lab, "Array<string>");
        }

        if (notes !== undefined) {
            localVarQueryParameters['notes'] = ObjectSerializer.serialize(notes, "Array<string>");
        }

        if (orfId !== undefined) {
            localVarQueryParameters['orf_id'] = ObjectSerializer.serialize(orfId, "Array<string>");
        }

        if (pctCoverageOrf !== undefined) {
            localVarQueryParameters['pct_coverage_orf'] = ObjectSerializer.serialize(pctCoverageOrf, "Array<number>");
        }

        if (pctCoverageProtein !== undefined) {
            localVarQueryParameters['pct_coverage_protein'] = ObjectSerializer.serialize(pctCoverageProtein, "Array<number>");
        }

        if (pctIdenticalProtein !== undefined) {
            localVarQueryParameters['pct_identical_protein'] = ObjectSerializer.serialize(pctIdenticalProtein, "Array<number>");
        }

        if (proteinId !== undefined) {
            localVarQueryParameters['protein_id'] = ObjectSerializer.serialize(proteinId, "Array<string>");
        }

        if (releaseTimestamp !== undefined) {
            localVarQueryParameters['release_timestamp'] = ObjectSerializer.serialize(releaseTimestamp, "Array<string>");
        }

        if (status !== undefined) {
            localVarQueryParameters['status'] = ObjectSerializer.serialize(status, "Array<'archived' | 'deleted' | 'in progress' | 'released'>");
        }

        if (submittedBy !== undefined) {
            localVarQueryParameters['submitted_by'] = ObjectSerializer.serialize(submittedBy, "Array<string>");
        }

        if (submitterComment !== undefined) {
            localVarQueryParameters['submitter_comment'] = ObjectSerializer.serialize(submitterComment, "Array<string>");
        }

        if (summary !== undefined) {
            localVarQueryParameters['summary'] = ObjectSerializer.serialize(summary, "Array<string>");
        }

        if (uuid !== undefined) {
            localVarQueryParameters['uuid'] = ObjectSerializer.serialize(uuid, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: OpenReadingFrameResults;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "OpenReadingFrameResults");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Collection endpoint that accepts various query parameters to filter, sort, and paginate Page items. Supports filtering on fields within Page items.
     * @summary List items in the Page collection.
     * @param frame Constant value. Do not set.
     * @param query Query string for searching.
     * @param limit Maximum number of results to return. Default is 25. Use \&#39;all\&#39; for all results.
     * @param sort Fields to sort results by. Prefix with \&#39;-\&#39; for descending order. Can be repeated for multiple sort fields. Does not work with limit&#x3D;all.
     * @param id Filter by @id
     * @param aliases Filter by aliases
     * @param award Filter by award
     * @param canonicalUri Filter by canonical_uri
     * @param creationTimestamp Filter by creation_timestamp
     * @param description Filter by description
     * @param lab Filter by lab
     * @param name Filter by name
     * @param notes Filter by notes
     * @param parent Filter by parent
     * @param releaseTimestamp Filter by release_timestamp
     * @param status Filter by status
     * @param submittedById Filter by submitted_by.@id
     * @param submittedByTitle Filter by submitted_by.title
     * @param submitterComment Filter by submitter_comment
     * @param summary Filter by summary
     * @param title Filter by title
     * @param uuid Filter by uuid
     */
    public async pages (frame: 'object', query?: string, limit?: Limit, sort?: Array<string>, id?: Array<string>, aliases?: Array<string>, award?: Array<string>, canonicalUri?: Array<string>, creationTimestamp?: Array<string>, description?: Array<string>, lab?: Array<string>, name?: Array<string>, notes?: Array<string>, parent?: Array<string>, releaseTimestamp?: Array<string>, status?: Array<'archived' | 'deleted' | 'in progress' | 'released'>, submittedById?: Array<string>, submittedByTitle?: Array<string>, submitterComment?: Array<string>, summary?: Array<string>, title?: Array<string>, uuid?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: PageResults;  }> {
        const localVarPath = this.basePath + '/pages/@@listing';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'frame' is not null or undefined
        if (frame === null || frame === undefined) {
            throw new Error('Required parameter frame was null or undefined when calling pages.');
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (frame !== undefined) {
            localVarQueryParameters['frame'] = ObjectSerializer.serialize(frame, "'object'");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "Limit");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "Array<string>");
        }

        if (id !== undefined) {
            localVarQueryParameters['@id'] = ObjectSerializer.serialize(id, "Array<string>");
        }

        if (aliases !== undefined) {
            localVarQueryParameters['aliases'] = ObjectSerializer.serialize(aliases, "Array<string>");
        }

        if (award !== undefined) {
            localVarQueryParameters['award'] = ObjectSerializer.serialize(award, "Array<string>");
        }

        if (canonicalUri !== undefined) {
            localVarQueryParameters['canonical_uri'] = ObjectSerializer.serialize(canonicalUri, "Array<string>");
        }

        if (creationTimestamp !== undefined) {
            localVarQueryParameters['creation_timestamp'] = ObjectSerializer.serialize(creationTimestamp, "Array<string>");
        }

        if (description !== undefined) {
            localVarQueryParameters['description'] = ObjectSerializer.serialize(description, "Array<string>");
        }

        if (lab !== undefined) {
            localVarQueryParameters['lab'] = ObjectSerializer.serialize(lab, "Array<string>");
        }

        if (name !== undefined) {
            localVarQueryParameters['name'] = ObjectSerializer.serialize(name, "Array<string>");
        }

        if (notes !== undefined) {
            localVarQueryParameters['notes'] = ObjectSerializer.serialize(notes, "Array<string>");
        }

        if (parent !== undefined) {
            localVarQueryParameters['parent'] = ObjectSerializer.serialize(parent, "Array<string>");
        }

        if (releaseTimestamp !== undefined) {
            localVarQueryParameters['release_timestamp'] = ObjectSerializer.serialize(releaseTimestamp, "Array<string>");
        }

        if (status !== undefined) {
            localVarQueryParameters['status'] = ObjectSerializer.serialize(status, "Array<'archived' | 'deleted' | 'in progress' | 'released'>");
        }

        if (submittedById !== undefined) {
            localVarQueryParameters['submitted_by.@id'] = ObjectSerializer.serialize(submittedById, "Array<string>");
        }

        if (submittedByTitle !== undefined) {
            localVarQueryParameters['submitted_by.title'] = ObjectSerializer.serialize(submittedByTitle, "Array<string>");
        }

        if (submitterComment !== undefined) {
            localVarQueryParameters['submitter_comment'] = ObjectSerializer.serialize(submitterComment, "Array<string>");
        }

        if (summary !== undefined) {
            localVarQueryParameters['summary'] = ObjectSerializer.serialize(summary, "Array<string>");
        }

        if (title !== undefined) {
            localVarQueryParameters['title'] = ObjectSerializer.serialize(title, "Array<string>");
        }

        if (uuid !== undefined) {
            localVarQueryParameters['uuid'] = ObjectSerializer.serialize(uuid, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: PageResults;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "PageResults");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Collection endpoint that accepts various query parameters to filter, sort, and paginate PhenotypeTerm items. Supports filtering on fields within PhenotypeTerm items.
     * @summary List items in the PhenotypeTerm collection.
     * @param frame Constant value. Do not set.
     * @param query Query string for searching.
     * @param limit Maximum number of results to return. Default is 25. Use \&#39;all\&#39; for all results.
     * @param sort Fields to sort results by. Prefix with \&#39;-\&#39; for descending order. Can be repeated for multiple sort fields. Does not work with limit&#x3D;all.
     * @param id Filter by @id
     * @param aliases Filter by aliases
     * @param ancestors Filter by ancestors
     * @param creationTimestamp Filter by creation_timestamp
     * @param deprecatedNtrTerms Filter by deprecated_ntr_terms
     * @param description Filter by description
     * @param isA Filter by is_a
     * @param name Filter by name
     * @param notes Filter by notes
     * @param ontology Filter by ontology
     * @param releaseTimestamp Filter by release_timestamp
     * @param status Filter by status
     * @param submittedById Filter by submitted_by.@id
     * @param submittedByTitle Filter by submitted_by.title
     * @param submitterComment Filter by submitter_comment
     * @param summary Filter by summary
     * @param synonyms Filter by synonyms
     * @param termId Filter by term_id
     * @param termName Filter by term_name
     * @param uuid Filter by uuid
     */
    public async phenotypeTerms (frame: 'object', query?: string, limit?: Limit, sort?: Array<string>, id?: Array<string>, aliases?: Array<string>, ancestors?: Array<string>, creationTimestamp?: Array<string>, deprecatedNtrTerms?: Array<string>, description?: Array<string>, isA?: Array<string>, name?: Array<string>, notes?: Array<string>, ontology?: Array<string>, releaseTimestamp?: Array<string>, status?: Array<'archived' | 'deleted' | 'in progress' | 'released'>, submittedById?: Array<string>, submittedByTitle?: Array<string>, submitterComment?: Array<string>, summary?: Array<string>, synonyms?: Array<string>, termId?: Array<string>, termName?: Array<string>, uuid?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: PhenotypeTermResults;  }> {
        const localVarPath = this.basePath + '/phenotype-terms/@@listing';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'frame' is not null or undefined
        if (frame === null || frame === undefined) {
            throw new Error('Required parameter frame was null or undefined when calling phenotypeTerms.');
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (frame !== undefined) {
            localVarQueryParameters['frame'] = ObjectSerializer.serialize(frame, "'object'");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "Limit");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "Array<string>");
        }

        if (id !== undefined) {
            localVarQueryParameters['@id'] = ObjectSerializer.serialize(id, "Array<string>");
        }

        if (aliases !== undefined) {
            localVarQueryParameters['aliases'] = ObjectSerializer.serialize(aliases, "Array<string>");
        }

        if (ancestors !== undefined) {
            localVarQueryParameters['ancestors'] = ObjectSerializer.serialize(ancestors, "Array<string>");
        }

        if (creationTimestamp !== undefined) {
            localVarQueryParameters['creation_timestamp'] = ObjectSerializer.serialize(creationTimestamp, "Array<string>");
        }

        if (deprecatedNtrTerms !== undefined) {
            localVarQueryParameters['deprecated_ntr_terms'] = ObjectSerializer.serialize(deprecatedNtrTerms, "Array<string>");
        }

        if (description !== undefined) {
            localVarQueryParameters['description'] = ObjectSerializer.serialize(description, "Array<string>");
        }

        if (isA !== undefined) {
            localVarQueryParameters['is_a'] = ObjectSerializer.serialize(isA, "Array<string>");
        }

        if (name !== undefined) {
            localVarQueryParameters['name'] = ObjectSerializer.serialize(name, "Array<string>");
        }

        if (notes !== undefined) {
            localVarQueryParameters['notes'] = ObjectSerializer.serialize(notes, "Array<string>");
        }

        if (ontology !== undefined) {
            localVarQueryParameters['ontology'] = ObjectSerializer.serialize(ontology, "Array<string>");
        }

        if (releaseTimestamp !== undefined) {
            localVarQueryParameters['release_timestamp'] = ObjectSerializer.serialize(releaseTimestamp, "Array<string>");
        }

        if (status !== undefined) {
            localVarQueryParameters['status'] = ObjectSerializer.serialize(status, "Array<'archived' | 'deleted' | 'in progress' | 'released'>");
        }

        if (submittedById !== undefined) {
            localVarQueryParameters['submitted_by.@id'] = ObjectSerializer.serialize(submittedById, "Array<string>");
        }

        if (submittedByTitle !== undefined) {
            localVarQueryParameters['submitted_by.title'] = ObjectSerializer.serialize(submittedByTitle, "Array<string>");
        }

        if (submitterComment !== undefined) {
            localVarQueryParameters['submitter_comment'] = ObjectSerializer.serialize(submitterComment, "Array<string>");
        }

        if (summary !== undefined) {
            localVarQueryParameters['summary'] = ObjectSerializer.serialize(summary, "Array<string>");
        }

        if (synonyms !== undefined) {
            localVarQueryParameters['synonyms'] = ObjectSerializer.serialize(synonyms, "Array<string>");
        }

        if (termId !== undefined) {
            localVarQueryParameters['term_id'] = ObjectSerializer.serialize(termId, "Array<string>");
        }

        if (termName !== undefined) {
            localVarQueryParameters['term_name'] = ObjectSerializer.serialize(termName, "Array<string>");
        }

        if (uuid !== undefined) {
            localVarQueryParameters['uuid'] = ObjectSerializer.serialize(uuid, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: PhenotypeTermResults;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "PhenotypeTermResults");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Collection endpoint that accepts various query parameters to filter, sort, and paginate PhenotypicFeature items. Supports filtering on fields within PhenotypicFeature items.
     * @summary List items in the PhenotypicFeature collection.
     * @param frame Constant value. Do not set.
     * @param query Query string for searching.
     * @param limit Maximum number of results to return. Default is 25. Use \&#39;all\&#39; for all results.
     * @param sort Fields to sort results by. Prefix with \&#39;-\&#39; for descending order. Can be repeated for multiple sort fields. Does not work with limit&#x3D;all.
     * @param id Filter by @id
     * @param aliases Filter by aliases
     * @param awardId Filter by award.@id
     * @param awardComponent Filter by award.component
     * @param creationTimestamp Filter by creation_timestamp
     * @param description Filter by description
     * @param featureId Filter by feature.@id
     * @param featureTermId Filter by feature.term_id
     * @param featureTermName Filter by feature.term_name
     * @param labId Filter by lab.@id
     * @param labTitle Filter by lab.title
     * @param notes Filter by notes
     * @param observationDate Filter by observation_date
     * @param quantity Filter by quantity
     * @param quantityUnits Filter by quantity_units
     * @param releaseTimestamp Filter by release_timestamp
     * @param status Filter by status
     * @param submittedById Filter by submitted_by.@id
     * @param submittedByTitle Filter by submitted_by.title
     * @param submitterComment Filter by submitter_comment
     * @param summary Filter by summary
     * @param uuid Filter by uuid
     */
    public async phenotypicFeatures (frame: 'object', query?: string, limit?: Limit, sort?: Array<string>, id?: Array<string>, aliases?: Array<string>, awardId?: Array<string>, awardComponent?: Array<'affiliate' | 'data analysis' | 'data coordination' | 'functional characterization' | 'mapping' | 'networks' | 'predictive modeling'>, creationTimestamp?: Array<string>, description?: Array<string>, featureId?: Array<string>, featureTermId?: Array<string>, featureTermName?: Array<string>, labId?: Array<string>, labTitle?: Array<string>, notes?: Array<string>, observationDate?: Array<string>, quantity?: Array<number>, quantityUnits?: Array<'meter' | 'micromole' | 'nanogram' | 'microgram' | 'milligram' | 'gram' | 'kilogram' | 'milli-International Unit per milliliter' | 'picogram per milliliter' | 'nanogram per milliliter' | 'milligram per deciliter'>, releaseTimestamp?: Array<string>, status?: Array<'archived' | 'deleted' | 'in progress' | 'released'>, submittedById?: Array<string>, submittedByTitle?: Array<string>, submitterComment?: Array<string>, summary?: Array<string>, uuid?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: PhenotypicFeatureResults;  }> {
        const localVarPath = this.basePath + '/phenotypic-features/@@listing';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'frame' is not null or undefined
        if (frame === null || frame === undefined) {
            throw new Error('Required parameter frame was null or undefined when calling phenotypicFeatures.');
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (frame !== undefined) {
            localVarQueryParameters['frame'] = ObjectSerializer.serialize(frame, "'object'");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "Limit");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "Array<string>");
        }

        if (id !== undefined) {
            localVarQueryParameters['@id'] = ObjectSerializer.serialize(id, "Array<string>");
        }

        if (aliases !== undefined) {
            localVarQueryParameters['aliases'] = ObjectSerializer.serialize(aliases, "Array<string>");
        }

        if (awardId !== undefined) {
            localVarQueryParameters['award.@id'] = ObjectSerializer.serialize(awardId, "Array<string>");
        }

        if (awardComponent !== undefined) {
            localVarQueryParameters['award.component'] = ObjectSerializer.serialize(awardComponent, "Array<'affiliate' | 'data analysis' | 'data coordination' | 'functional characterization' | 'mapping' | 'networks' | 'predictive modeling'>");
        }

        if (creationTimestamp !== undefined) {
            localVarQueryParameters['creation_timestamp'] = ObjectSerializer.serialize(creationTimestamp, "Array<string>");
        }

        if (description !== undefined) {
            localVarQueryParameters['description'] = ObjectSerializer.serialize(description, "Array<string>");
        }

        if (featureId !== undefined) {
            localVarQueryParameters['feature.@id'] = ObjectSerializer.serialize(featureId, "Array<string>");
        }

        if (featureTermId !== undefined) {
            localVarQueryParameters['feature.term_id'] = ObjectSerializer.serialize(featureTermId, "Array<string>");
        }

        if (featureTermName !== undefined) {
            localVarQueryParameters['feature.term_name'] = ObjectSerializer.serialize(featureTermName, "Array<string>");
        }

        if (labId !== undefined) {
            localVarQueryParameters['lab.@id'] = ObjectSerializer.serialize(labId, "Array<string>");
        }

        if (labTitle !== undefined) {
            localVarQueryParameters['lab.title'] = ObjectSerializer.serialize(labTitle, "Array<string>");
        }

        if (notes !== undefined) {
            localVarQueryParameters['notes'] = ObjectSerializer.serialize(notes, "Array<string>");
        }

        if (observationDate !== undefined) {
            localVarQueryParameters['observation_date'] = ObjectSerializer.serialize(observationDate, "Array<string>");
        }

        if (quantity !== undefined) {
            localVarQueryParameters['quantity'] = ObjectSerializer.serialize(quantity, "Array<number>");
        }

        if (quantityUnits !== undefined) {
            localVarQueryParameters['quantity_units'] = ObjectSerializer.serialize(quantityUnits, "Array<'meter' | 'micromole' | 'nanogram' | 'microgram' | 'milligram' | 'gram' | 'kilogram' | 'milli-International Unit per milliliter' | 'picogram per milliliter' | 'nanogram per milliliter' | 'milligram per deciliter'>");
        }

        if (releaseTimestamp !== undefined) {
            localVarQueryParameters['release_timestamp'] = ObjectSerializer.serialize(releaseTimestamp, "Array<string>");
        }

        if (status !== undefined) {
            localVarQueryParameters['status'] = ObjectSerializer.serialize(status, "Array<'archived' | 'deleted' | 'in progress' | 'released'>");
        }

        if (submittedById !== undefined) {
            localVarQueryParameters['submitted_by.@id'] = ObjectSerializer.serialize(submittedById, "Array<string>");
        }

        if (submittedByTitle !== undefined) {
            localVarQueryParameters['submitted_by.title'] = ObjectSerializer.serialize(submittedByTitle, "Array<string>");
        }

        if (submitterComment !== undefined) {
            localVarQueryParameters['submitter_comment'] = ObjectSerializer.serialize(submitterComment, "Array<string>");
        }

        if (summary !== undefined) {
            localVarQueryParameters['summary'] = ObjectSerializer.serialize(summary, "Array<string>");
        }

        if (uuid !== undefined) {
            localVarQueryParameters['uuid'] = ObjectSerializer.serialize(uuid, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: PhenotypicFeatureResults;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "PhenotypicFeatureResults");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Collection endpoint that accepts various query parameters to filter, sort, and paginate PlatformTerm items. Supports filtering on fields within PlatformTerm items.
     * @summary List items in the PlatformTerm collection.
     * @param frame Constant value. Do not set.
     * @param query Query string for searching.
     * @param limit Maximum number of results to return. Default is 25. Use \&#39;all\&#39; for all results.
     * @param sort Fields to sort results by. Prefix with \&#39;-\&#39; for descending order. Can be repeated for multiple sort fields. Does not work with limit&#x3D;all.
     * @param id Filter by @id
     * @param aliases Filter by aliases
     * @param ancestors Filter by ancestors
     * @param company Filter by company
     * @param creationTimestamp Filter by creation_timestamp
     * @param deprecatedNtrTerms Filter by deprecated_ntr_terms
     * @param description Filter by description
     * @param isA Filter by is_a
     * @param name Filter by name
     * @param notes Filter by notes
     * @param ontology Filter by ontology
     * @param releaseTimestamp Filter by release_timestamp
     * @param sequencingKits Filter by sequencing_kits
     * @param status Filter by status
     * @param submittedById Filter by submitted_by.@id
     * @param submittedByTitle Filter by submitted_by.title
     * @param submitterComment Filter by submitter_comment
     * @param summary Filter by summary
     * @param synonyms Filter by synonyms
     * @param termId Filter by term_id
     * @param termName Filter by term_name
     * @param uuid Filter by uuid
     */
    public async platformTerms (frame: 'object', query?: string, limit?: Limit, sort?: Array<string>, id?: Array<string>, aliases?: Array<string>, ancestors?: Array<string>, company?: Array<'10X Genomics' | 'Illumina' | 'Life Technologies' | 'Oxford Nanopore Technologies' | 'Pacific Biosciences' | 'Parse Biosciences' | 'Roche'>, creationTimestamp?: Array<string>, deprecatedNtrTerms?: Array<string>, description?: Array<string>, isA?: Array<string>, name?: Array<string>, notes?: Array<string>, ontology?: Array<string>, releaseTimestamp?: Array<string>, sequencingKits?: Array<'HiSeq SBS Kit v4' | 'HiSeq SR Cluster Kit v4-cBot-HS' | 'HiSeq PE Cluster Kit v4-cBot-HS' | 'HiSeq SR Rapid Cluster Kit v2' | 'HiSeq PE Rapid Cluster Kit v2' | 'HiSeq Rapid SBS Kit v2' | 'HiSeq 3000/4000 SBS Kit' | 'HiSeq 3000/4000 SR Cluster Kit' | 'HiSeq 3000/4000 PE Cluster Kit' | 'MiSeq Reagent Kit v2' | 'NextSeq 500 Mid Output Kit' | 'NextSeq 500 High Output Kit' | 'NextSeq 500 Mid Output v2 Kit' | 'NextSeq 500 High Output v2 Kit' | 'NextSeq 500/550 Mid-Output v2.5 Kit' | 'NextSeq 500/550 High-Output v2.5 Kit' | 'TG NextSeq 500/550 Mid-Output Kit v2.5' | 'TG NextSeq 500/550 High-Output Kit v2.5' | 'NextSeq 1000/2000 P1 Reagent Kit' | 'NextSeq 1000/2000 P2 Reagent Kit' | 'NextSeq 1000/2000 P3 Reagent Kit' | 'NextSeq 1000/2000 P1 XLEAP-SBS Reagent Kit' | 'NextSeq 1000/2000 P2 XLEAP-SBS Reagent Kit' | 'NextSeq 2000 P3 XLEAP-SBS Reagent Kit' | 'NextSeq 2000 P4 XLEAP-SBS Reagent Kit' | 'NovaSeq 6000 SP Reagent Kit v1.5' | 'NovaSeq 6000 S1 Reagent Kit v1.5' | 'NovaSeq 6000 S2 Reagent Kit v1.5' | 'NovaSeq 6000 S4 Reagent Kit v1.5' | 'NovaSeq X Series 10B Reagent Kit' | 'ONT Ligation Sequencing Kit V14' | 'Sequel sequencing kit 3.0' | 'Sequel II sequencing kit 2.0'>, status?: Array<'archived' | 'deleted' | 'in progress' | 'released'>, submittedById?: Array<string>, submittedByTitle?: Array<string>, submitterComment?: Array<string>, summary?: Array<string>, synonyms?: Array<string>, termId?: Array<string>, termName?: Array<string>, uuid?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: PlatformTermResults;  }> {
        const localVarPath = this.basePath + '/platform-terms/@@listing';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'frame' is not null or undefined
        if (frame === null || frame === undefined) {
            throw new Error('Required parameter frame was null or undefined when calling platformTerms.');
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (frame !== undefined) {
            localVarQueryParameters['frame'] = ObjectSerializer.serialize(frame, "'object'");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "Limit");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "Array<string>");
        }

        if (id !== undefined) {
            localVarQueryParameters['@id'] = ObjectSerializer.serialize(id, "Array<string>");
        }

        if (aliases !== undefined) {
            localVarQueryParameters['aliases'] = ObjectSerializer.serialize(aliases, "Array<string>");
        }

        if (ancestors !== undefined) {
            localVarQueryParameters['ancestors'] = ObjectSerializer.serialize(ancestors, "Array<string>");
        }

        if (company !== undefined) {
            localVarQueryParameters['company'] = ObjectSerializer.serialize(company, "Array<'10X Genomics' | 'Illumina' | 'Life Technologies' | 'Oxford Nanopore Technologies' | 'Pacific Biosciences' | 'Parse Biosciences' | 'Roche'>");
        }

        if (creationTimestamp !== undefined) {
            localVarQueryParameters['creation_timestamp'] = ObjectSerializer.serialize(creationTimestamp, "Array<string>");
        }

        if (deprecatedNtrTerms !== undefined) {
            localVarQueryParameters['deprecated_ntr_terms'] = ObjectSerializer.serialize(deprecatedNtrTerms, "Array<string>");
        }

        if (description !== undefined) {
            localVarQueryParameters['description'] = ObjectSerializer.serialize(description, "Array<string>");
        }

        if (isA !== undefined) {
            localVarQueryParameters['is_a'] = ObjectSerializer.serialize(isA, "Array<string>");
        }

        if (name !== undefined) {
            localVarQueryParameters['name'] = ObjectSerializer.serialize(name, "Array<string>");
        }

        if (notes !== undefined) {
            localVarQueryParameters['notes'] = ObjectSerializer.serialize(notes, "Array<string>");
        }

        if (ontology !== undefined) {
            localVarQueryParameters['ontology'] = ObjectSerializer.serialize(ontology, "Array<string>");
        }

        if (releaseTimestamp !== undefined) {
            localVarQueryParameters['release_timestamp'] = ObjectSerializer.serialize(releaseTimestamp, "Array<string>");
        }

        if (sequencingKits !== undefined) {
            localVarQueryParameters['sequencing_kits'] = ObjectSerializer.serialize(sequencingKits, "Array<'HiSeq SBS Kit v4' | 'HiSeq SR Cluster Kit v4-cBot-HS' | 'HiSeq PE Cluster Kit v4-cBot-HS' | 'HiSeq SR Rapid Cluster Kit v2' | 'HiSeq PE Rapid Cluster Kit v2' | 'HiSeq Rapid SBS Kit v2' | 'HiSeq 3000/4000 SBS Kit' | 'HiSeq 3000/4000 SR Cluster Kit' | 'HiSeq 3000/4000 PE Cluster Kit' | 'MiSeq Reagent Kit v2' | 'NextSeq 500 Mid Output Kit' | 'NextSeq 500 High Output Kit' | 'NextSeq 500 Mid Output v2 Kit' | 'NextSeq 500 High Output v2 Kit' | 'NextSeq 500/550 Mid-Output v2.5 Kit' | 'NextSeq 500/550 High-Output v2.5 Kit' | 'TG NextSeq 500/550 Mid-Output Kit v2.5' | 'TG NextSeq 500/550 High-Output Kit v2.5' | 'NextSeq 1000/2000 P1 Reagent Kit' | 'NextSeq 1000/2000 P2 Reagent Kit' | 'NextSeq 1000/2000 P3 Reagent Kit' | 'NextSeq 1000/2000 P1 XLEAP-SBS Reagent Kit' | 'NextSeq 1000/2000 P2 XLEAP-SBS Reagent Kit' | 'NextSeq 2000 P3 XLEAP-SBS Reagent Kit' | 'NextSeq 2000 P4 XLEAP-SBS Reagent Kit' | 'NovaSeq 6000 SP Reagent Kit v1.5' | 'NovaSeq 6000 S1 Reagent Kit v1.5' | 'NovaSeq 6000 S2 Reagent Kit v1.5' | 'NovaSeq 6000 S4 Reagent Kit v1.5' | 'NovaSeq X Series 10B Reagent Kit' | 'ONT Ligation Sequencing Kit V14' | 'Sequel sequencing kit 3.0' | 'Sequel II sequencing kit 2.0'>");
        }

        if (status !== undefined) {
            localVarQueryParameters['status'] = ObjectSerializer.serialize(status, "Array<'archived' | 'deleted' | 'in progress' | 'released'>");
        }

        if (submittedById !== undefined) {
            localVarQueryParameters['submitted_by.@id'] = ObjectSerializer.serialize(submittedById, "Array<string>");
        }

        if (submittedByTitle !== undefined) {
            localVarQueryParameters['submitted_by.title'] = ObjectSerializer.serialize(submittedByTitle, "Array<string>");
        }

        if (submitterComment !== undefined) {
            localVarQueryParameters['submitter_comment'] = ObjectSerializer.serialize(submitterComment, "Array<string>");
        }

        if (summary !== undefined) {
            localVarQueryParameters['summary'] = ObjectSerializer.serialize(summary, "Array<string>");
        }

        if (synonyms !== undefined) {
            localVarQueryParameters['synonyms'] = ObjectSerializer.serialize(synonyms, "Array<string>");
        }

        if (termId !== undefined) {
            localVarQueryParameters['term_id'] = ObjectSerializer.serialize(termId, "Array<string>");
        }

        if (termName !== undefined) {
            localVarQueryParameters['term_name'] = ObjectSerializer.serialize(termName, "Array<string>");
        }

        if (uuid !== undefined) {
            localVarQueryParameters['uuid'] = ObjectSerializer.serialize(uuid, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: PlatformTermResults;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "PlatformTermResults");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Collection endpoint that accepts various query parameters to filter, sort, and paginate PredictionSet items. Supports filtering on fields within PredictionSet items.
     * @summary List items in the PredictionSet collection.
     * @param frame Constant value. Do not set.
     * @param query Query string for searching.
     * @param limit Maximum number of results to return. Default is 25. Use \&#39;all\&#39; for all results.
     * @param sort Fields to sort results by. Prefix with \&#39;-\&#39; for descending order. Can be repeated for multiple sort fields. Does not work with limit&#x3D;all.
     * @param id Filter by @id
     * @param accession Filter by accession
     * @param aliases Filter by aliases
     * @param alternateAccessions Filter by alternate_accessions
     * @param awardId Filter by award.@id
     * @param awardComponent Filter by award.component
     * @param awardContactPiId Filter by award.contact_pi.@id
     * @param awardContactPiTitle Filter by award.contact_pi.title
     * @param awardTitle Filter by award.title
     * @param collections Filter by collections
     * @param controlForId Filter by control_for.@id
     * @param controlForAccession Filter by control_for.accession
     * @param controlForAliases Filter by control_for.aliases
     * @param creationTimestamp Filter by creation_timestamp
     * @param dbxrefs Filter by dbxrefs
     * @param description Filter by description
     * @param documents Filter by documents
     * @param donorsId Filter by donors.@id
     * @param donorsAccession Filter by donors.accession
     * @param donorsAliases Filter by donors.aliases
     * @param donorsSex Filter by donors.sex
     * @param donorsStatus Filter by donors.status
     * @param donorsTaxa Filter by donors.taxa
     * @param fileSetType Filter by file_set_type
     * @param filesId Filter by files.@id
     * @param filesAccession Filter by files.accession
     * @param filesAliases Filter by files.aliases
     * @param filesContentType Filter by files.content_type
     * @param filesCreationTimestamp Filter by files.creation_timestamp
     * @param filesFileFormat Filter by files.file_format
     * @param filesFileSize Filter by files.file_size
     * @param filesHref Filter by files.href
     * @param filesS3Uri Filter by files.s3_uri
     * @param filesSequencingPlatform Filter by files.sequencing_platform
     * @param filesSubmittedFileName Filter by files.submitted_file_name
     * @param filesUploadStatus Filter by files.upload_status
     * @param inputFileSetFor Filter by input_file_set_for
     * @param inputFileSets Filter by input_file_sets
     * @param labId Filter by lab.@id
     * @param labTitle Filter by lab.title
     * @param largeScaleGeneListId Filter by large_scale_gene_list.@id
     * @param largeScaleGeneListAccession Filter by large_scale_gene_list.accession
     * @param largeScaleGeneListAliases Filter by large_scale_gene_list.aliases
     * @param largeScaleLociListId Filter by large_scale_loci_list.@id
     * @param largeScaleLociListAccession Filter by large_scale_loci_list.accession
     * @param largeScaleLociListAliases Filter by large_scale_loci_list.aliases
     * @param notes Filter by notes
     * @param publicationIdentifiers Filter by publication_identifiers
     * @param publications Filter by publications
     * @param releaseTimestamp Filter by release_timestamp
     * @param revokeDetail Filter by revoke_detail
     * @param samplesId Filter by samples.@id
     * @param samplesAccession Filter by samples.accession
     * @param samplesAliases Filter by samples.aliases
     * @param samplesCellFateChangeTreatments Filter by samples.cell_fate_change_treatments
     * @param samplesClassifications Filter by samples.classifications
     * @param samplesConstructLibrarySetsId Filter by samples.construct_library_sets.@id
     * @param samplesConstructLibrarySetsAccession Filter by samples.construct_library_sets.accession
     * @param samplesConstructLibrarySetsSummary Filter by samples.construct_library_sets.summary
     * @param samplesDiseaseTermsId Filter by samples.disease_terms.@id
     * @param samplesDiseaseTermsTermName Filter by samples.disease_terms.term_name
     * @param samplesModifications Filter by samples.modifications
     * @param samplesSampleTermsId Filter by samples.sample_terms.@id
     * @param samplesSampleTermsAliases Filter by samples.sample_terms.aliases
     * @param samplesSampleTermsStatus Filter by samples.sample_terms.status
     * @param samplesSampleTermsSummary Filter by samples.sample_terms.summary
     * @param samplesSampleTermsTermName Filter by samples.sample_terms.term_name
     * @param samplesStatus Filter by samples.status
     * @param samplesSummary Filter by samples.summary
     * @param samplesTargetedSampleTermId Filter by samples.targeted_sample_term.@id
     * @param samplesTargetedSampleTermTermName Filter by samples.targeted_sample_term.term_name
     * @param samplesTaxa Filter by samples.taxa
     * @param samplesTreatments Filter by samples.treatments
     * @param scope Filter by scope
     * @param smallScaleGeneListId Filter by small_scale_gene_list.@id
     * @param smallScaleGeneListGeneid Filter by small_scale_gene_list.geneid
     * @param smallScaleGeneListName Filter by small_scale_gene_list.name
     * @param smallScaleGeneListSymbol Filter by small_scale_gene_list.symbol
     * @param smallScaleGeneListSynonyms Filter by small_scale_gene_list.synonyms
     * @param smallScaleLociList Filter by small_scale_loci_list
     * @param status Filter by status
     * @param submittedById Filter by submitted_by.@id
     * @param submittedByTitle Filter by submitted_by.title
     * @param submittedFilesTimestamp Filter by submitted_files_timestamp
     * @param submitterComment Filter by submitter_comment
     * @param summary Filter by summary
     * @param url Filter by url
     * @param uuid Filter by uuid
     */
    public async predictionSets (frame: 'object', query?: string, limit?: Limit, sort?: Array<string>, id?: Array<string>, accession?: Array<string>, aliases?: Array<string>, alternateAccessions?: Array<string>, awardId?: Array<string>, awardComponent?: Array<'affiliate' | 'data analysis' | 'data coordination' | 'functional characterization' | 'mapping' | 'networks' | 'predictive modeling'>, awardContactPiId?: Array<string>, awardContactPiTitle?: Array<string>, awardTitle?: Array<string>, collections?: Array<'ClinGen' | 'ENCODE' | 'GREGoR' | 'IGVF_catalog_beta_v0.1' | 'IGVF_catalog_beta_v0.2' | 'IGVF_catalog_beta_v0.3' | 'IGVF_catalog_beta_v0.4' | 'MaveDB' | 'MPRAbase' | 'Vista'>, controlForId?: Array<string>, controlForAccession?: Array<string>, controlForAliases?: Array<string>, creationTimestamp?: Array<string>, dbxrefs?: Array<string>, description?: Array<string>, documents?: Array<string>, donorsId?: Array<string>, donorsAccession?: Array<string>, donorsAliases?: Array<string>, donorsSex?: Array<'male' | 'female' | 'unspecified'>, donorsStatus?: Array<'in progress' | 'released' | 'deleted' | 'replaced' | 'revoked' | 'archived'>, donorsTaxa?: Array<string>, fileSetType?: Array<'pathogenicity' | 'functional effect' | 'protein stability' | 'activity level' | 'binding effect'>, filesId?: Array<string>, filesAccession?: Array<string>, filesAliases?: Array<string>, filesContentType?: Array<string>, filesCreationTimestamp?: Array<string>, filesFileFormat?: Array<string>, filesFileSize?: Array<number>, filesHref?: Array<string>, filesS3Uri?: Array<string>, filesSequencingPlatform?: Array<string>, filesSubmittedFileName?: Array<string>, filesUploadStatus?: Array<'pending' | 'file not found' | 'invalidated' | 'validated'>, inputFileSetFor?: Array<string>, inputFileSets?: Array<string>, labId?: Array<string>, labTitle?: Array<string>, largeScaleGeneListId?: Array<string>, largeScaleGeneListAccession?: Array<string>, largeScaleGeneListAliases?: Array<string>, largeScaleLociListId?: Array<string>, largeScaleLociListAccession?: Array<string>, largeScaleLociListAliases?: Array<string>, notes?: Array<string>, publicationIdentifiers?: Array<string>, publications?: Array<string>, releaseTimestamp?: Array<string>, revokeDetail?: Array<string>, samplesId?: Array<string>, samplesAccession?: Array<string>, samplesAliases?: Array<string>, samplesCellFateChangeTreatments?: Array<string>, samplesClassifications?: Array<'organoid' | 'gastruloid' | 'embryoid' | 'cell line' | 'differentiated cell specimen' | 'reprogrammed cell specimen' | 'pooled cell specimen'>, samplesConstructLibrarySetsId?: Array<string>, samplesConstructLibrarySetsAccession?: Array<string>, samplesConstructLibrarySetsSummary?: Array<string>, samplesDiseaseTermsId?: Array<string>, samplesDiseaseTermsTermName?: Array<string>, samplesModifications?: Array<string>, samplesSampleTermsId?: Array<string>, samplesSampleTermsAliases?: Array<string>, samplesSampleTermsStatus?: Array<'archived' | 'deleted' | 'in progress' | 'released'>, samplesSampleTermsSummary?: Array<string>, samplesSampleTermsTermName?: Array<string>, samplesStatus?: Array<'in progress' | 'released' | 'deleted' | 'replaced' | 'revoked' | 'archived'>, samplesSummary?: Array<string>, samplesTargetedSampleTermId?: Array<string>, samplesTargetedSampleTermTermName?: Array<string>, samplesTaxa?: Array<'Homo sapiens' | 'Mus musculus'>, samplesTreatments?: Array<string>, scope?: Array<'genes' | 'loci' | 'genome-wide'>, smallScaleGeneListId?: Array<string>, smallScaleGeneListGeneid?: Array<string>, smallScaleGeneListName?: Array<string>, smallScaleGeneListSymbol?: Array<string>, smallScaleGeneListSynonyms?: Array<string>, smallScaleLociList?: Array<Locus>, status?: Array<'in progress' | 'released' | 'deleted' | 'replaced' | 'revoked' | 'archived'>, submittedById?: Array<string>, submittedByTitle?: Array<string>, submittedFilesTimestamp?: Array<string>, submitterComment?: Array<string>, summary?: Array<string>, url?: Array<string>, uuid?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: PredictionSetResults;  }> {
        const localVarPath = this.basePath + '/prediction-sets/@@listing';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'frame' is not null or undefined
        if (frame === null || frame === undefined) {
            throw new Error('Required parameter frame was null or undefined when calling predictionSets.');
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (frame !== undefined) {
            localVarQueryParameters['frame'] = ObjectSerializer.serialize(frame, "'object'");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "Limit");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "Array<string>");
        }

        if (id !== undefined) {
            localVarQueryParameters['@id'] = ObjectSerializer.serialize(id, "Array<string>");
        }

        if (accession !== undefined) {
            localVarQueryParameters['accession'] = ObjectSerializer.serialize(accession, "Array<string>");
        }

        if (aliases !== undefined) {
            localVarQueryParameters['aliases'] = ObjectSerializer.serialize(aliases, "Array<string>");
        }

        if (alternateAccessions !== undefined) {
            localVarQueryParameters['alternate_accessions'] = ObjectSerializer.serialize(alternateAccessions, "Array<string>");
        }

        if (awardId !== undefined) {
            localVarQueryParameters['award.@id'] = ObjectSerializer.serialize(awardId, "Array<string>");
        }

        if (awardComponent !== undefined) {
            localVarQueryParameters['award.component'] = ObjectSerializer.serialize(awardComponent, "Array<'affiliate' | 'data analysis' | 'data coordination' | 'functional characterization' | 'mapping' | 'networks' | 'predictive modeling'>");
        }

        if (awardContactPiId !== undefined) {
            localVarQueryParameters['award.contact_pi.@id'] = ObjectSerializer.serialize(awardContactPiId, "Array<string>");
        }

        if (awardContactPiTitle !== undefined) {
            localVarQueryParameters['award.contact_pi.title'] = ObjectSerializer.serialize(awardContactPiTitle, "Array<string>");
        }

        if (awardTitle !== undefined) {
            localVarQueryParameters['award.title'] = ObjectSerializer.serialize(awardTitle, "Array<string>");
        }

        if (collections !== undefined) {
            localVarQueryParameters['collections'] = ObjectSerializer.serialize(collections, "Array<'ClinGen' | 'ENCODE' | 'GREGoR' | 'IGVF_catalog_beta_v0.1' | 'IGVF_catalog_beta_v0.2' | 'IGVF_catalog_beta_v0.3' | 'IGVF_catalog_beta_v0.4' | 'MaveDB' | 'MPRAbase' | 'Vista'>");
        }

        if (controlForId !== undefined) {
            localVarQueryParameters['control_for.@id'] = ObjectSerializer.serialize(controlForId, "Array<string>");
        }

        if (controlForAccession !== undefined) {
            localVarQueryParameters['control_for.accession'] = ObjectSerializer.serialize(controlForAccession, "Array<string>");
        }

        if (controlForAliases !== undefined) {
            localVarQueryParameters['control_for.aliases'] = ObjectSerializer.serialize(controlForAliases, "Array<string>");
        }

        if (creationTimestamp !== undefined) {
            localVarQueryParameters['creation_timestamp'] = ObjectSerializer.serialize(creationTimestamp, "Array<string>");
        }

        if (dbxrefs !== undefined) {
            localVarQueryParameters['dbxrefs'] = ObjectSerializer.serialize(dbxrefs, "Array<string>");
        }

        if (description !== undefined) {
            localVarQueryParameters['description'] = ObjectSerializer.serialize(description, "Array<string>");
        }

        if (documents !== undefined) {
            localVarQueryParameters['documents'] = ObjectSerializer.serialize(documents, "Array<string>");
        }

        if (donorsId !== undefined) {
            localVarQueryParameters['donors.@id'] = ObjectSerializer.serialize(donorsId, "Array<string>");
        }

        if (donorsAccession !== undefined) {
            localVarQueryParameters['donors.accession'] = ObjectSerializer.serialize(donorsAccession, "Array<string>");
        }

        if (donorsAliases !== undefined) {
            localVarQueryParameters['donors.aliases'] = ObjectSerializer.serialize(donorsAliases, "Array<string>");
        }

        if (donorsSex !== undefined) {
            localVarQueryParameters['donors.sex'] = ObjectSerializer.serialize(donorsSex, "Array<'male' | 'female' | 'unspecified'>");
        }

        if (donorsStatus !== undefined) {
            localVarQueryParameters['donors.status'] = ObjectSerializer.serialize(donorsStatus, "Array<'in progress' | 'released' | 'deleted' | 'replaced' | 'revoked' | 'archived'>");
        }

        if (donorsTaxa !== undefined) {
            localVarQueryParameters['donors.taxa'] = ObjectSerializer.serialize(donorsTaxa, "Array<string>");
        }

        if (fileSetType !== undefined) {
            localVarQueryParameters['file_set_type'] = ObjectSerializer.serialize(fileSetType, "Array<'pathogenicity' | 'functional effect' | 'protein stability' | 'activity level' | 'binding effect'>");
        }

        if (filesId !== undefined) {
            localVarQueryParameters['files.@id'] = ObjectSerializer.serialize(filesId, "Array<string>");
        }

        if (filesAccession !== undefined) {
            localVarQueryParameters['files.accession'] = ObjectSerializer.serialize(filesAccession, "Array<string>");
        }

        if (filesAliases !== undefined) {
            localVarQueryParameters['files.aliases'] = ObjectSerializer.serialize(filesAliases, "Array<string>");
        }

        if (filesContentType !== undefined) {
            localVarQueryParameters['files.content_type'] = ObjectSerializer.serialize(filesContentType, "Array<string>");
        }

        if (filesCreationTimestamp !== undefined) {
            localVarQueryParameters['files.creation_timestamp'] = ObjectSerializer.serialize(filesCreationTimestamp, "Array<string>");
        }

        if (filesFileFormat !== undefined) {
            localVarQueryParameters['files.file_format'] = ObjectSerializer.serialize(filesFileFormat, "Array<string>");
        }

        if (filesFileSize !== undefined) {
            localVarQueryParameters['files.file_size'] = ObjectSerializer.serialize(filesFileSize, "Array<number>");
        }

        if (filesHref !== undefined) {
            localVarQueryParameters['files.href'] = ObjectSerializer.serialize(filesHref, "Array<string>");
        }

        if (filesS3Uri !== undefined) {
            localVarQueryParameters['files.s3_uri'] = ObjectSerializer.serialize(filesS3Uri, "Array<string>");
        }

        if (filesSequencingPlatform !== undefined) {
            localVarQueryParameters['files.sequencing_platform'] = ObjectSerializer.serialize(filesSequencingPlatform, "Array<string>");
        }

        if (filesSubmittedFileName !== undefined) {
            localVarQueryParameters['files.submitted_file_name'] = ObjectSerializer.serialize(filesSubmittedFileName, "Array<string>");
        }

        if (filesUploadStatus !== undefined) {
            localVarQueryParameters['files.upload_status'] = ObjectSerializer.serialize(filesUploadStatus, "Array<'pending' | 'file not found' | 'invalidated' | 'validated'>");
        }

        if (inputFileSetFor !== undefined) {
            localVarQueryParameters['input_file_set_for'] = ObjectSerializer.serialize(inputFileSetFor, "Array<string>");
        }

        if (inputFileSets !== undefined) {
            localVarQueryParameters['input_file_sets'] = ObjectSerializer.serialize(inputFileSets, "Array<string>");
        }

        if (labId !== undefined) {
            localVarQueryParameters['lab.@id'] = ObjectSerializer.serialize(labId, "Array<string>");
        }

        if (labTitle !== undefined) {
            localVarQueryParameters['lab.title'] = ObjectSerializer.serialize(labTitle, "Array<string>");
        }

        if (largeScaleGeneListId !== undefined) {
            localVarQueryParameters['large_scale_gene_list.@id'] = ObjectSerializer.serialize(largeScaleGeneListId, "Array<string>");
        }

        if (largeScaleGeneListAccession !== undefined) {
            localVarQueryParameters['large_scale_gene_list.accession'] = ObjectSerializer.serialize(largeScaleGeneListAccession, "Array<string>");
        }

        if (largeScaleGeneListAliases !== undefined) {
            localVarQueryParameters['large_scale_gene_list.aliases'] = ObjectSerializer.serialize(largeScaleGeneListAliases, "Array<string>");
        }

        if (largeScaleLociListId !== undefined) {
            localVarQueryParameters['large_scale_loci_list.@id'] = ObjectSerializer.serialize(largeScaleLociListId, "Array<string>");
        }

        if (largeScaleLociListAccession !== undefined) {
            localVarQueryParameters['large_scale_loci_list.accession'] = ObjectSerializer.serialize(largeScaleLociListAccession, "Array<string>");
        }

        if (largeScaleLociListAliases !== undefined) {
            localVarQueryParameters['large_scale_loci_list.aliases'] = ObjectSerializer.serialize(largeScaleLociListAliases, "Array<string>");
        }

        if (notes !== undefined) {
            localVarQueryParameters['notes'] = ObjectSerializer.serialize(notes, "Array<string>");
        }

        if (publicationIdentifiers !== undefined) {
            localVarQueryParameters['publication_identifiers'] = ObjectSerializer.serialize(publicationIdentifiers, "Array<string>");
        }

        if (publications !== undefined) {
            localVarQueryParameters['publications'] = ObjectSerializer.serialize(publications, "Array<string>");
        }

        if (releaseTimestamp !== undefined) {
            localVarQueryParameters['release_timestamp'] = ObjectSerializer.serialize(releaseTimestamp, "Array<string>");
        }

        if (revokeDetail !== undefined) {
            localVarQueryParameters['revoke_detail'] = ObjectSerializer.serialize(revokeDetail, "Array<string>");
        }

        if (samplesId !== undefined) {
            localVarQueryParameters['samples.@id'] = ObjectSerializer.serialize(samplesId, "Array<string>");
        }

        if (samplesAccession !== undefined) {
            localVarQueryParameters['samples.accession'] = ObjectSerializer.serialize(samplesAccession, "Array<string>");
        }

        if (samplesAliases !== undefined) {
            localVarQueryParameters['samples.aliases'] = ObjectSerializer.serialize(samplesAliases, "Array<string>");
        }

        if (samplesCellFateChangeTreatments !== undefined) {
            localVarQueryParameters['samples.cell_fate_change_treatments'] = ObjectSerializer.serialize(samplesCellFateChangeTreatments, "Array<string>");
        }

        if (samplesClassifications !== undefined) {
            localVarQueryParameters['samples.classifications'] = ObjectSerializer.serialize(samplesClassifications, "Array<'organoid' | 'gastruloid' | 'embryoid' | 'cell line' | 'differentiated cell specimen' | 'reprogrammed cell specimen' | 'pooled cell specimen'>");
        }

        if (samplesConstructLibrarySetsId !== undefined) {
            localVarQueryParameters['samples.construct_library_sets.@id'] = ObjectSerializer.serialize(samplesConstructLibrarySetsId, "Array<string>");
        }

        if (samplesConstructLibrarySetsAccession !== undefined) {
            localVarQueryParameters['samples.construct_library_sets.accession'] = ObjectSerializer.serialize(samplesConstructLibrarySetsAccession, "Array<string>");
        }

        if (samplesConstructLibrarySetsSummary !== undefined) {
            localVarQueryParameters['samples.construct_library_sets.summary'] = ObjectSerializer.serialize(samplesConstructLibrarySetsSummary, "Array<string>");
        }

        if (samplesDiseaseTermsId !== undefined) {
            localVarQueryParameters['samples.disease_terms.@id'] = ObjectSerializer.serialize(samplesDiseaseTermsId, "Array<string>");
        }

        if (samplesDiseaseTermsTermName !== undefined) {
            localVarQueryParameters['samples.disease_terms.term_name'] = ObjectSerializer.serialize(samplesDiseaseTermsTermName, "Array<string>");
        }

        if (samplesModifications !== undefined) {
            localVarQueryParameters['samples.modifications'] = ObjectSerializer.serialize(samplesModifications, "Array<string>");
        }

        if (samplesSampleTermsId !== undefined) {
            localVarQueryParameters['samples.sample_terms.@id'] = ObjectSerializer.serialize(samplesSampleTermsId, "Array<string>");
        }

        if (samplesSampleTermsAliases !== undefined) {
            localVarQueryParameters['samples.sample_terms.aliases'] = ObjectSerializer.serialize(samplesSampleTermsAliases, "Array<string>");
        }

        if (samplesSampleTermsStatus !== undefined) {
            localVarQueryParameters['samples.sample_terms.status'] = ObjectSerializer.serialize(samplesSampleTermsStatus, "Array<'archived' | 'deleted' | 'in progress' | 'released'>");
        }

        if (samplesSampleTermsSummary !== undefined) {
            localVarQueryParameters['samples.sample_terms.summary'] = ObjectSerializer.serialize(samplesSampleTermsSummary, "Array<string>");
        }

        if (samplesSampleTermsTermName !== undefined) {
            localVarQueryParameters['samples.sample_terms.term_name'] = ObjectSerializer.serialize(samplesSampleTermsTermName, "Array<string>");
        }

        if (samplesStatus !== undefined) {
            localVarQueryParameters['samples.status'] = ObjectSerializer.serialize(samplesStatus, "Array<'in progress' | 'released' | 'deleted' | 'replaced' | 'revoked' | 'archived'>");
        }

        if (samplesSummary !== undefined) {
            localVarQueryParameters['samples.summary'] = ObjectSerializer.serialize(samplesSummary, "Array<string>");
        }

        if (samplesTargetedSampleTermId !== undefined) {
            localVarQueryParameters['samples.targeted_sample_term.@id'] = ObjectSerializer.serialize(samplesTargetedSampleTermId, "Array<string>");
        }

        if (samplesTargetedSampleTermTermName !== undefined) {
            localVarQueryParameters['samples.targeted_sample_term.term_name'] = ObjectSerializer.serialize(samplesTargetedSampleTermTermName, "Array<string>");
        }

        if (samplesTaxa !== undefined) {
            localVarQueryParameters['samples.taxa'] = ObjectSerializer.serialize(samplesTaxa, "Array<'Homo sapiens' | 'Mus musculus'>");
        }

        if (samplesTreatments !== undefined) {
            localVarQueryParameters['samples.treatments'] = ObjectSerializer.serialize(samplesTreatments, "Array<string>");
        }

        if (scope !== undefined) {
            localVarQueryParameters['scope'] = ObjectSerializer.serialize(scope, "Array<'genes' | 'loci' | 'genome-wide'>");
        }

        if (smallScaleGeneListId !== undefined) {
            localVarQueryParameters['small_scale_gene_list.@id'] = ObjectSerializer.serialize(smallScaleGeneListId, "Array<string>");
        }

        if (smallScaleGeneListGeneid !== undefined) {
            localVarQueryParameters['small_scale_gene_list.geneid'] = ObjectSerializer.serialize(smallScaleGeneListGeneid, "Array<string>");
        }

        if (smallScaleGeneListName !== undefined) {
            localVarQueryParameters['small_scale_gene_list.name'] = ObjectSerializer.serialize(smallScaleGeneListName, "Array<string>");
        }

        if (smallScaleGeneListSymbol !== undefined) {
            localVarQueryParameters['small_scale_gene_list.symbol'] = ObjectSerializer.serialize(smallScaleGeneListSymbol, "Array<string>");
        }

        if (smallScaleGeneListSynonyms !== undefined) {
            localVarQueryParameters['small_scale_gene_list.synonyms'] = ObjectSerializer.serialize(smallScaleGeneListSynonyms, "Array<string>");
        }

        if (smallScaleLociList !== undefined) {
            localVarQueryParameters['small_scale_loci_list'] = ObjectSerializer.serialize(smallScaleLociList, "Array<Locus>");
        }

        if (status !== undefined) {
            localVarQueryParameters['status'] = ObjectSerializer.serialize(status, "Array<'in progress' | 'released' | 'deleted' | 'replaced' | 'revoked' | 'archived'>");
        }

        if (submittedById !== undefined) {
            localVarQueryParameters['submitted_by.@id'] = ObjectSerializer.serialize(submittedById, "Array<string>");
        }

        if (submittedByTitle !== undefined) {
            localVarQueryParameters['submitted_by.title'] = ObjectSerializer.serialize(submittedByTitle, "Array<string>");
        }

        if (submittedFilesTimestamp !== undefined) {
            localVarQueryParameters['submitted_files_timestamp'] = ObjectSerializer.serialize(submittedFilesTimestamp, "Array<string>");
        }

        if (submitterComment !== undefined) {
            localVarQueryParameters['submitter_comment'] = ObjectSerializer.serialize(submitterComment, "Array<string>");
        }

        if (summary !== undefined) {
            localVarQueryParameters['summary'] = ObjectSerializer.serialize(summary, "Array<string>");
        }

        if (url !== undefined) {
            localVarQueryParameters['url'] = ObjectSerializer.serialize(url, "Array<string>");
        }

        if (uuid !== undefined) {
            localVarQueryParameters['uuid'] = ObjectSerializer.serialize(uuid, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: PredictionSetResults;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "PredictionSetResults");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Collection endpoint that accepts various query parameters to filter, sort, and paginate PrimaryCell items. Supports filtering on fields within PrimaryCell items.
     * @summary List items in the PrimaryCell collection.
     * @param frame Constant value. Do not set.
     * @param query Query string for searching.
     * @param limit Maximum number of results to return. Default is 25. Use \&#39;all\&#39; for all results.
     * @param sort Fields to sort results by. Prefix with \&#39;-\&#39; for descending order. Can be repeated for multiple sort fields. Does not work with limit&#x3D;all.
     * @param id Filter by @id
     * @param accession Filter by accession
     * @param age Filter by age
     * @param ageUnits Filter by age_units
     * @param aliases Filter by aliases
     * @param alternateAccessions Filter by alternate_accessions
     * @param awardId Filter by award.@id
     * @param awardComponent Filter by award.component
     * @param biomarkers Filter by biomarkers
     * @param cellularSubPool Filter by cellular_sub_pool
     * @param classifications Filter by classifications
     * @param collections Filter by collections
     * @param constructLibrarySets Filter by construct_library_sets
     * @param creationTimestamp Filter by creation_timestamp
     * @param dateObtained Filter by date_obtained
     * @param dbxrefs Filter by dbxrefs
     * @param description Filter by description
     * @param diseaseTermsId Filter by disease_terms.@id
     * @param diseaseTermsTermName Filter by disease_terms.term_name
     * @param documents Filter by documents
     * @param donors Filter by donors
     * @param embryonic Filter by embryonic
     * @param fileSetsId Filter by file_sets.@id
     * @param fileSetsAccession Filter by file_sets.accession
     * @param fileSetsAliases Filter by file_sets.aliases
     * @param fileSetsAssayTermTermName Filter by file_sets.assay_term.term_name
     * @param fileSetsLabTitle Filter by file_sets.lab.title
     * @param fileSetsStatus Filter by file_sets.status
     * @param fileSetsSummary Filter by file_sets.summary
     * @param institutionalCertificatesId Filter by institutional_certificates.@id
     * @param institutionalCertificatesCertificateIdentifier Filter by institutional_certificates.certificate_identifier
     * @param labId Filter by lab.@id
     * @param labTitle Filter by lab.title
     * @param lotId Filter by lot_id
     * @param lowerBoundAge Filter by lower_bound_age
     * @param lowerBoundAgeInHours Filter by lower_bound_age_in_hours
     * @param modificationsId Filter by modifications.@id
     * @param modificationsStatus Filter by modifications.status
     * @param modificationsSummary Filter by modifications.summary
     * @param moi Filter by moi
     * @param multiplexedInId Filter by multiplexed_in.@id
     * @param multiplexedInAccession Filter by multiplexed_in.accession
     * @param notes Filter by notes
     * @param nucleicAcidDelivery Filter by nucleic_acid_delivery
     * @param originOf Filter by origin_of
     * @param originatedFrom Filter by originated_from
     * @param partOf Filter by part_of
     * @param parts Filter by parts
     * @param passageNumber Filter by passage_number
     * @param pooledFrom Filter by pooled_from
     * @param pooledIn Filter by pooled_in
     * @param productId Filter by product_id
     * @param protocols Filter by protocols
     * @param publicationIdentifiers Filter by publication_identifiers
     * @param publications Filter by publications
     * @param releaseTimestamp Filter by release_timestamp
     * @param revokeDetail Filter by revoke_detail
     * @param sampleTermsId Filter by sample_terms.@id
     * @param sampleTermsTermName Filter by sample_terms.term_name
     * @param sex Filter by sex
     * @param sortedFractions Filter by sorted_fractions
     * @param sortedFromId Filter by sorted_from.@id
     * @param sortedFromAccession Filter by sorted_from.accession
     * @param sortedFromDetail Filter by sorted_from_detail
     * @param sourcesId Filter by sources.@id
     * @param startingAmount Filter by starting_amount
     * @param startingAmountUnits Filter by starting_amount_units
     * @param status Filter by status
     * @param submittedById Filter by submitted_by.@id
     * @param submittedByTitle Filter by submitted_by.title
     * @param submitterComment Filter by submitter_comment
     * @param summary Filter by summary
     * @param taxa Filter by taxa
     * @param timePostLibraryDelivery Filter by time_post_library_delivery
     * @param timePostLibraryDeliveryUnits Filter by time_post_library_delivery_units
     * @param treatmentsId Filter by treatments.@id
     * @param treatmentsPurpose Filter by treatments.purpose
     * @param treatmentsStatus Filter by treatments.status
     * @param treatmentsSummary Filter by treatments.summary
     * @param treatmentsTreatmentType Filter by treatments.treatment_type
     * @param upperBoundAge Filter by upper_bound_age
     * @param upperBoundAgeInHours Filter by upper_bound_age_in_hours
     * @param url Filter by url
     * @param uuid Filter by uuid
     * @param virtual Filter by virtual
     */
    public async primaryCells (frame: 'object', query?: string, limit?: Limit, sort?: Array<string>, id?: Array<string>, accession?: Array<string>, age?: Array<string>, ageUnits?: Array<'minute' | 'hour' | 'day' | 'week' | 'month' | 'year'>, aliases?: Array<string>, alternateAccessions?: Array<string>, awardId?: Array<string>, awardComponent?: Array<'affiliate' | 'data analysis' | 'data coordination' | 'functional characterization' | 'mapping' | 'networks' | 'predictive modeling'>, biomarkers?: Array<string>, cellularSubPool?: Array<string>, classifications?: Array<string>, collections?: Array<'ClinGen' | 'ENCODE' | 'GREGoR' | 'IGVF_catalog_beta_v0.1' | 'IGVF_catalog_beta_v0.2' | 'IGVF_catalog_beta_v0.3' | 'IGVF_catalog_beta_v0.4' | 'MaveDB' | 'MPRAbase' | 'Vista'>, constructLibrarySets?: Array<string>, creationTimestamp?: Array<string>, dateObtained?: Array<string>, dbxrefs?: Array<string>, description?: Array<string>, diseaseTermsId?: Array<string>, diseaseTermsTermName?: Array<string>, documents?: Array<string>, donors?: Array<string>, embryonic?: Array<boolean>, fileSetsId?: Array<string>, fileSetsAccession?: Array<string>, fileSetsAliases?: Array<string>, fileSetsAssayTermTermName?: Array<string>, fileSetsLabTitle?: Array<string>, fileSetsStatus?: Array<'in progress' | 'released' | 'deleted' | 'replaced' | 'revoked' | 'archived'>, fileSetsSummary?: Array<string>, institutionalCertificatesId?: Array<string>, institutionalCertificatesCertificateIdentifier?: Array<string>, labId?: Array<string>, labTitle?: Array<string>, lotId?: Array<string>, lowerBoundAge?: Array<number>, lowerBoundAgeInHours?: Array<number>, modificationsId?: Array<string>, modificationsStatus?: Array<'archived' | 'deleted' | 'in progress' | 'released'>, modificationsSummary?: Array<string>, moi?: Array<number>, multiplexedInId?: Array<string>, multiplexedInAccession?: Array<string>, notes?: Array<string>, nucleicAcidDelivery?: Array<'transfection' | 'adenoviral transduction' | 'lentiviral transduction'>, originOf?: Array<string>, originatedFrom?: Array<string>, partOf?: Array<string>, parts?: Array<string>, passageNumber?: Array<number>, pooledFrom?: Array<string>, pooledIn?: Array<string>, productId?: Array<string>, protocols?: Array<string>, publicationIdentifiers?: Array<string>, publications?: Array<string>, releaseTimestamp?: Array<string>, revokeDetail?: Array<string>, sampleTermsId?: Array<string>, sampleTermsTermName?: Array<string>, sex?: Array<'female' | 'male' | 'mixed' | 'unspecified'>, sortedFractions?: Array<string>, sortedFromId?: Array<string>, sortedFromAccession?: Array<string>, sortedFromDetail?: Array<string>, sourcesId?: Array<string>, startingAmount?: Array<number>, startingAmountUnits?: Array<'cells' | 'cells/ml' | 'g' | 'items' | 'mg' | 'whole animals' | 'whole embryos' | 'μg' | 'ng'>, status?: Array<'in progress' | 'released' | 'deleted' | 'replaced' | 'revoked' | 'archived'>, submittedById?: Array<string>, submittedByTitle?: Array<string>, submitterComment?: Array<string>, summary?: Array<string>, taxa?: Array<'Homo sapiens' | 'Mus musculus'>, timePostLibraryDelivery?: Array<number>, timePostLibraryDeliveryUnits?: Array<'minute' | 'hour' | 'day' | 'week' | 'month'>, treatmentsId?: Array<string>, treatmentsPurpose?: Array<'activation' | 'agonist' | 'antagonist' | 'control' | 'differentiation' | 'de-differentiation' | 'perturbation' | 'selection' | 'stimulation'>, treatmentsStatus?: Array<'archived' | 'deleted' | 'in progress' | 'released'>, treatmentsSummary?: Array<string>, treatmentsTreatmentType?: Array<'chemical' | 'protein' | 'environmental'>, upperBoundAge?: Array<number>, upperBoundAgeInHours?: Array<number>, url?: Array<string>, uuid?: Array<string>, virtual?: Array<boolean>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: PrimaryCellResults;  }> {
        const localVarPath = this.basePath + '/primary-cells/@@listing';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'frame' is not null or undefined
        if (frame === null || frame === undefined) {
            throw new Error('Required parameter frame was null or undefined when calling primaryCells.');
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (frame !== undefined) {
            localVarQueryParameters['frame'] = ObjectSerializer.serialize(frame, "'object'");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "Limit");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "Array<string>");
        }

        if (id !== undefined) {
            localVarQueryParameters['@id'] = ObjectSerializer.serialize(id, "Array<string>");
        }

        if (accession !== undefined) {
            localVarQueryParameters['accession'] = ObjectSerializer.serialize(accession, "Array<string>");
        }

        if (age !== undefined) {
            localVarQueryParameters['age'] = ObjectSerializer.serialize(age, "Array<string>");
        }

        if (ageUnits !== undefined) {
            localVarQueryParameters['age_units'] = ObjectSerializer.serialize(ageUnits, "Array<'minute' | 'hour' | 'day' | 'week' | 'month' | 'year'>");
        }

        if (aliases !== undefined) {
            localVarQueryParameters['aliases'] = ObjectSerializer.serialize(aliases, "Array<string>");
        }

        if (alternateAccessions !== undefined) {
            localVarQueryParameters['alternate_accessions'] = ObjectSerializer.serialize(alternateAccessions, "Array<string>");
        }

        if (awardId !== undefined) {
            localVarQueryParameters['award.@id'] = ObjectSerializer.serialize(awardId, "Array<string>");
        }

        if (awardComponent !== undefined) {
            localVarQueryParameters['award.component'] = ObjectSerializer.serialize(awardComponent, "Array<'affiliate' | 'data analysis' | 'data coordination' | 'functional characterization' | 'mapping' | 'networks' | 'predictive modeling'>");
        }

        if (biomarkers !== undefined) {
            localVarQueryParameters['biomarkers'] = ObjectSerializer.serialize(biomarkers, "Array<string>");
        }

        if (cellularSubPool !== undefined) {
            localVarQueryParameters['cellular_sub_pool'] = ObjectSerializer.serialize(cellularSubPool, "Array<string>");
        }

        if (classifications !== undefined) {
            localVarQueryParameters['classifications'] = ObjectSerializer.serialize(classifications, "Array<string>");
        }

        if (collections !== undefined) {
            localVarQueryParameters['collections'] = ObjectSerializer.serialize(collections, "Array<'ClinGen' | 'ENCODE' | 'GREGoR' | 'IGVF_catalog_beta_v0.1' | 'IGVF_catalog_beta_v0.2' | 'IGVF_catalog_beta_v0.3' | 'IGVF_catalog_beta_v0.4' | 'MaveDB' | 'MPRAbase' | 'Vista'>");
        }

        if (constructLibrarySets !== undefined) {
            localVarQueryParameters['construct_library_sets'] = ObjectSerializer.serialize(constructLibrarySets, "Array<string>");
        }

        if (creationTimestamp !== undefined) {
            localVarQueryParameters['creation_timestamp'] = ObjectSerializer.serialize(creationTimestamp, "Array<string>");
        }

        if (dateObtained !== undefined) {
            localVarQueryParameters['date_obtained'] = ObjectSerializer.serialize(dateObtained, "Array<string>");
        }

        if (dbxrefs !== undefined) {
            localVarQueryParameters['dbxrefs'] = ObjectSerializer.serialize(dbxrefs, "Array<string>");
        }

        if (description !== undefined) {
            localVarQueryParameters['description'] = ObjectSerializer.serialize(description, "Array<string>");
        }

        if (diseaseTermsId !== undefined) {
            localVarQueryParameters['disease_terms.@id'] = ObjectSerializer.serialize(diseaseTermsId, "Array<string>");
        }

        if (diseaseTermsTermName !== undefined) {
            localVarQueryParameters['disease_terms.term_name'] = ObjectSerializer.serialize(diseaseTermsTermName, "Array<string>");
        }

        if (documents !== undefined) {
            localVarQueryParameters['documents'] = ObjectSerializer.serialize(documents, "Array<string>");
        }

        if (donors !== undefined) {
            localVarQueryParameters['donors'] = ObjectSerializer.serialize(donors, "Array<string>");
        }

        if (embryonic !== undefined) {
            localVarQueryParameters['embryonic'] = ObjectSerializer.serialize(embryonic, "Array<boolean>");
        }

        if (fileSetsId !== undefined) {
            localVarQueryParameters['file_sets.@id'] = ObjectSerializer.serialize(fileSetsId, "Array<string>");
        }

        if (fileSetsAccession !== undefined) {
            localVarQueryParameters['file_sets.accession'] = ObjectSerializer.serialize(fileSetsAccession, "Array<string>");
        }

        if (fileSetsAliases !== undefined) {
            localVarQueryParameters['file_sets.aliases'] = ObjectSerializer.serialize(fileSetsAliases, "Array<string>");
        }

        if (fileSetsAssayTermTermName !== undefined) {
            localVarQueryParameters['file_sets.assay_term.term_name'] = ObjectSerializer.serialize(fileSetsAssayTermTermName, "Array<string>");
        }

        if (fileSetsLabTitle !== undefined) {
            localVarQueryParameters['file_sets.lab.title'] = ObjectSerializer.serialize(fileSetsLabTitle, "Array<string>");
        }

        if (fileSetsStatus !== undefined) {
            localVarQueryParameters['file_sets.status'] = ObjectSerializer.serialize(fileSetsStatus, "Array<'in progress' | 'released' | 'deleted' | 'replaced' | 'revoked' | 'archived'>");
        }

        if (fileSetsSummary !== undefined) {
            localVarQueryParameters['file_sets.summary'] = ObjectSerializer.serialize(fileSetsSummary, "Array<string>");
        }

        if (institutionalCertificatesId !== undefined) {
            localVarQueryParameters['institutional_certificates.@id'] = ObjectSerializer.serialize(institutionalCertificatesId, "Array<string>");
        }

        if (institutionalCertificatesCertificateIdentifier !== undefined) {
            localVarQueryParameters['institutional_certificates.certificate_identifier'] = ObjectSerializer.serialize(institutionalCertificatesCertificateIdentifier, "Array<string>");
        }

        if (labId !== undefined) {
            localVarQueryParameters['lab.@id'] = ObjectSerializer.serialize(labId, "Array<string>");
        }

        if (labTitle !== undefined) {
            localVarQueryParameters['lab.title'] = ObjectSerializer.serialize(labTitle, "Array<string>");
        }

        if (lotId !== undefined) {
            localVarQueryParameters['lot_id'] = ObjectSerializer.serialize(lotId, "Array<string>");
        }

        if (lowerBoundAge !== undefined) {
            localVarQueryParameters['lower_bound_age'] = ObjectSerializer.serialize(lowerBoundAge, "Array<number>");
        }

        if (lowerBoundAgeInHours !== undefined) {
            localVarQueryParameters['lower_bound_age_in_hours'] = ObjectSerializer.serialize(lowerBoundAgeInHours, "Array<number>");
        }

        if (modificationsId !== undefined) {
            localVarQueryParameters['modifications.@id'] = ObjectSerializer.serialize(modificationsId, "Array<string>");
        }

        if (modificationsStatus !== undefined) {
            localVarQueryParameters['modifications.status'] = ObjectSerializer.serialize(modificationsStatus, "Array<'archived' | 'deleted' | 'in progress' | 'released'>");
        }

        if (modificationsSummary !== undefined) {
            localVarQueryParameters['modifications.summary'] = ObjectSerializer.serialize(modificationsSummary, "Array<string>");
        }

        if (moi !== undefined) {
            localVarQueryParameters['moi'] = ObjectSerializer.serialize(moi, "Array<number>");
        }

        if (multiplexedInId !== undefined) {
            localVarQueryParameters['multiplexed_in.@id'] = ObjectSerializer.serialize(multiplexedInId, "Array<string>");
        }

        if (multiplexedInAccession !== undefined) {
            localVarQueryParameters['multiplexed_in.accession'] = ObjectSerializer.serialize(multiplexedInAccession, "Array<string>");
        }

        if (notes !== undefined) {
            localVarQueryParameters['notes'] = ObjectSerializer.serialize(notes, "Array<string>");
        }

        if (nucleicAcidDelivery !== undefined) {
            localVarQueryParameters['nucleic_acid_delivery'] = ObjectSerializer.serialize(nucleicAcidDelivery, "Array<'transfection' | 'adenoviral transduction' | 'lentiviral transduction'>");
        }

        if (originOf !== undefined) {
            localVarQueryParameters['origin_of'] = ObjectSerializer.serialize(originOf, "Array<string>");
        }

        if (originatedFrom !== undefined) {
            localVarQueryParameters['originated_from'] = ObjectSerializer.serialize(originatedFrom, "Array<string>");
        }

        if (partOf !== undefined) {
            localVarQueryParameters['part_of'] = ObjectSerializer.serialize(partOf, "Array<string>");
        }

        if (parts !== undefined) {
            localVarQueryParameters['parts'] = ObjectSerializer.serialize(parts, "Array<string>");
        }

        if (passageNumber !== undefined) {
            localVarQueryParameters['passage_number'] = ObjectSerializer.serialize(passageNumber, "Array<number>");
        }

        if (pooledFrom !== undefined) {
            localVarQueryParameters['pooled_from'] = ObjectSerializer.serialize(pooledFrom, "Array<string>");
        }

        if (pooledIn !== undefined) {
            localVarQueryParameters['pooled_in'] = ObjectSerializer.serialize(pooledIn, "Array<string>");
        }

        if (productId !== undefined) {
            localVarQueryParameters['product_id'] = ObjectSerializer.serialize(productId, "Array<string>");
        }

        if (protocols !== undefined) {
            localVarQueryParameters['protocols'] = ObjectSerializer.serialize(protocols, "Array<string>");
        }

        if (publicationIdentifiers !== undefined) {
            localVarQueryParameters['publication_identifiers'] = ObjectSerializer.serialize(publicationIdentifiers, "Array<string>");
        }

        if (publications !== undefined) {
            localVarQueryParameters['publications'] = ObjectSerializer.serialize(publications, "Array<string>");
        }

        if (releaseTimestamp !== undefined) {
            localVarQueryParameters['release_timestamp'] = ObjectSerializer.serialize(releaseTimestamp, "Array<string>");
        }

        if (revokeDetail !== undefined) {
            localVarQueryParameters['revoke_detail'] = ObjectSerializer.serialize(revokeDetail, "Array<string>");
        }

        if (sampleTermsId !== undefined) {
            localVarQueryParameters['sample_terms.@id'] = ObjectSerializer.serialize(sampleTermsId, "Array<string>");
        }

        if (sampleTermsTermName !== undefined) {
            localVarQueryParameters['sample_terms.term_name'] = ObjectSerializer.serialize(sampleTermsTermName, "Array<string>");
        }

        if (sex !== undefined) {
            localVarQueryParameters['sex'] = ObjectSerializer.serialize(sex, "Array<'female' | 'male' | 'mixed' | 'unspecified'>");
        }

        if (sortedFractions !== undefined) {
            localVarQueryParameters['sorted_fractions'] = ObjectSerializer.serialize(sortedFractions, "Array<string>");
        }

        if (sortedFromId !== undefined) {
            localVarQueryParameters['sorted_from.@id'] = ObjectSerializer.serialize(sortedFromId, "Array<string>");
        }

        if (sortedFromAccession !== undefined) {
            localVarQueryParameters['sorted_from.accession'] = ObjectSerializer.serialize(sortedFromAccession, "Array<string>");
        }

        if (sortedFromDetail !== undefined) {
            localVarQueryParameters['sorted_from_detail'] = ObjectSerializer.serialize(sortedFromDetail, "Array<string>");
        }

        if (sourcesId !== undefined) {
            localVarQueryParameters['sources.@id'] = ObjectSerializer.serialize(sourcesId, "Array<string>");
        }

        if (startingAmount !== undefined) {
            localVarQueryParameters['starting_amount'] = ObjectSerializer.serialize(startingAmount, "Array<number>");
        }

        if (startingAmountUnits !== undefined) {
            localVarQueryParameters['starting_amount_units'] = ObjectSerializer.serialize(startingAmountUnits, "Array<'cells' | 'cells/ml' | 'g' | 'items' | 'mg' | 'whole animals' | 'whole embryos' | 'μg' | 'ng'>");
        }

        if (status !== undefined) {
            localVarQueryParameters['status'] = ObjectSerializer.serialize(status, "Array<'in progress' | 'released' | 'deleted' | 'replaced' | 'revoked' | 'archived'>");
        }

        if (submittedById !== undefined) {
            localVarQueryParameters['submitted_by.@id'] = ObjectSerializer.serialize(submittedById, "Array<string>");
        }

        if (submittedByTitle !== undefined) {
            localVarQueryParameters['submitted_by.title'] = ObjectSerializer.serialize(submittedByTitle, "Array<string>");
        }

        if (submitterComment !== undefined) {
            localVarQueryParameters['submitter_comment'] = ObjectSerializer.serialize(submitterComment, "Array<string>");
        }

        if (summary !== undefined) {
            localVarQueryParameters['summary'] = ObjectSerializer.serialize(summary, "Array<string>");
        }

        if (taxa !== undefined) {
            localVarQueryParameters['taxa'] = ObjectSerializer.serialize(taxa, "Array<'Homo sapiens' | 'Mus musculus'>");
        }

        if (timePostLibraryDelivery !== undefined) {
            localVarQueryParameters['time_post_library_delivery'] = ObjectSerializer.serialize(timePostLibraryDelivery, "Array<number>");
        }

        if (timePostLibraryDeliveryUnits !== undefined) {
            localVarQueryParameters['time_post_library_delivery_units'] = ObjectSerializer.serialize(timePostLibraryDeliveryUnits, "Array<'minute' | 'hour' | 'day' | 'week' | 'month'>");
        }

        if (treatmentsId !== undefined) {
            localVarQueryParameters['treatments.@id'] = ObjectSerializer.serialize(treatmentsId, "Array<string>");
        }

        if (treatmentsPurpose !== undefined) {
            localVarQueryParameters['treatments.purpose'] = ObjectSerializer.serialize(treatmentsPurpose, "Array<'activation' | 'agonist' | 'antagonist' | 'control' | 'differentiation' | 'de-differentiation' | 'perturbation' | 'selection' | 'stimulation'>");
        }

        if (treatmentsStatus !== undefined) {
            localVarQueryParameters['treatments.status'] = ObjectSerializer.serialize(treatmentsStatus, "Array<'archived' | 'deleted' | 'in progress' | 'released'>");
        }

        if (treatmentsSummary !== undefined) {
            localVarQueryParameters['treatments.summary'] = ObjectSerializer.serialize(treatmentsSummary, "Array<string>");
        }

        if (treatmentsTreatmentType !== undefined) {
            localVarQueryParameters['treatments.treatment_type'] = ObjectSerializer.serialize(treatmentsTreatmentType, "Array<'chemical' | 'protein' | 'environmental'>");
        }

        if (upperBoundAge !== undefined) {
            localVarQueryParameters['upper_bound_age'] = ObjectSerializer.serialize(upperBoundAge, "Array<number>");
        }

        if (upperBoundAgeInHours !== undefined) {
            localVarQueryParameters['upper_bound_age_in_hours'] = ObjectSerializer.serialize(upperBoundAgeInHours, "Array<number>");
        }

        if (url !== undefined) {
            localVarQueryParameters['url'] = ObjectSerializer.serialize(url, "Array<string>");
        }

        if (uuid !== undefined) {
            localVarQueryParameters['uuid'] = ObjectSerializer.serialize(uuid, "Array<string>");
        }

        if (virtual !== undefined) {
            localVarQueryParameters['virtual'] = ObjectSerializer.serialize(virtual, "Array<boolean>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: PrimaryCellResults;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "PrimaryCellResults");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Collection endpoint that accepts various query parameters to filter, sort, and paginate Publication items. Supports filtering on fields within Publication items.
     * @summary List items in the Publication collection.
     * @param frame Constant value. Do not set.
     * @param query Query string for searching.
     * @param limit Maximum number of results to return. Default is 25. Use \&#39;all\&#39; for all results.
     * @param sort Fields to sort results by. Prefix with \&#39;-\&#39; for descending order. Can be repeated for multiple sort fields. Does not work with limit&#x3D;all.
     * @param id Filter by @id
     * @param _abstract Filter by abstract
     * @param aliases Filter by aliases
     * @param authors Filter by authors
     * @param awardId Filter by award.@id
     * @param awardComponent Filter by award.component
     * @param creationTimestamp Filter by creation_timestamp
     * @param datePublished Filter by date_published
     * @param dateRevised Filter by date_revised
     * @param description Filter by description
     * @param donors Filter by donors
     * @param fileSets Filter by file_sets
     * @param issue Filter by issue
     * @param journal Filter by journal
     * @param labId Filter by lab.@id
     * @param labTitle Filter by lab.title
     * @param notes Filter by notes
     * @param page Filter by page
     * @param publicationIdentifiers Filter by publication_identifiers
     * @param publicationYear Filter by publication_year
     * @param publishedBy Filter by published_by
     * @param releaseTimestamp Filter by release_timestamp
     * @param samples Filter by samples
     * @param software Filter by software
     * @param softwareVersions Filter by software_versions
     * @param status Filter by status
     * @param submittedById Filter by submitted_by.@id
     * @param submittedByTitle Filter by submitted_by.title
     * @param submitterComment Filter by submitter_comment
     * @param summary Filter by summary
     * @param title Filter by title
     * @param uuid Filter by uuid
     * @param volume Filter by volume
     * @param workflows Filter by workflows
     */
    public async publications (frame: 'object', query?: string, limit?: Limit, sort?: Array<string>, id?: Array<string>, _abstract?: Array<string>, aliases?: Array<string>, authors?: Array<string>, awardId?: Array<string>, awardComponent?: Array<'affiliate' | 'data analysis' | 'data coordination' | 'functional characterization' | 'mapping' | 'networks' | 'predictive modeling'>, creationTimestamp?: Array<string>, datePublished?: Array<string>, dateRevised?: Array<string>, description?: Array<string>, donors?: Array<string>, fileSets?: Array<string>, issue?: Array<string>, journal?: Array<string>, labId?: Array<string>, labTitle?: Array<string>, notes?: Array<string>, page?: Array<string>, publicationIdentifiers?: Array<string>, publicationYear?: Array<number>, publishedBy?: Array<'community' | 'IGVF' | 'ENCODE'>, releaseTimestamp?: Array<string>, samples?: Array<string>, software?: Array<string>, softwareVersions?: Array<string>, status?: Array<'archived' | 'deleted' | 'in progress' | 'released'>, submittedById?: Array<string>, submittedByTitle?: Array<string>, submitterComment?: Array<string>, summary?: Array<string>, title?: Array<string>, uuid?: Array<string>, volume?: Array<string>, workflows?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: PublicationResults;  }> {
        const localVarPath = this.basePath + '/publications/@@listing';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'frame' is not null or undefined
        if (frame === null || frame === undefined) {
            throw new Error('Required parameter frame was null or undefined when calling publications.');
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (frame !== undefined) {
            localVarQueryParameters['frame'] = ObjectSerializer.serialize(frame, "'object'");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "Limit");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "Array<string>");
        }

        if (id !== undefined) {
            localVarQueryParameters['@id'] = ObjectSerializer.serialize(id, "Array<string>");
        }

        if (_abstract !== undefined) {
            localVarQueryParameters['abstract'] = ObjectSerializer.serialize(_abstract, "Array<string>");
        }

        if (aliases !== undefined) {
            localVarQueryParameters['aliases'] = ObjectSerializer.serialize(aliases, "Array<string>");
        }

        if (authors !== undefined) {
            localVarQueryParameters['authors'] = ObjectSerializer.serialize(authors, "Array<string>");
        }

        if (awardId !== undefined) {
            localVarQueryParameters['award.@id'] = ObjectSerializer.serialize(awardId, "Array<string>");
        }

        if (awardComponent !== undefined) {
            localVarQueryParameters['award.component'] = ObjectSerializer.serialize(awardComponent, "Array<'affiliate' | 'data analysis' | 'data coordination' | 'functional characterization' | 'mapping' | 'networks' | 'predictive modeling'>");
        }

        if (creationTimestamp !== undefined) {
            localVarQueryParameters['creation_timestamp'] = ObjectSerializer.serialize(creationTimestamp, "Array<string>");
        }

        if (datePublished !== undefined) {
            localVarQueryParameters['date_published'] = ObjectSerializer.serialize(datePublished, "Array<string>");
        }

        if (dateRevised !== undefined) {
            localVarQueryParameters['date_revised'] = ObjectSerializer.serialize(dateRevised, "Array<string>");
        }

        if (description !== undefined) {
            localVarQueryParameters['description'] = ObjectSerializer.serialize(description, "Array<string>");
        }

        if (donors !== undefined) {
            localVarQueryParameters['donors'] = ObjectSerializer.serialize(donors, "Array<string>");
        }

        if (fileSets !== undefined) {
            localVarQueryParameters['file_sets'] = ObjectSerializer.serialize(fileSets, "Array<string>");
        }

        if (issue !== undefined) {
            localVarQueryParameters['issue'] = ObjectSerializer.serialize(issue, "Array<string>");
        }

        if (journal !== undefined) {
            localVarQueryParameters['journal'] = ObjectSerializer.serialize(journal, "Array<string>");
        }

        if (labId !== undefined) {
            localVarQueryParameters['lab.@id'] = ObjectSerializer.serialize(labId, "Array<string>");
        }

        if (labTitle !== undefined) {
            localVarQueryParameters['lab.title'] = ObjectSerializer.serialize(labTitle, "Array<string>");
        }

        if (notes !== undefined) {
            localVarQueryParameters['notes'] = ObjectSerializer.serialize(notes, "Array<string>");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "Array<string>");
        }

        if (publicationIdentifiers !== undefined) {
            localVarQueryParameters['publication_identifiers'] = ObjectSerializer.serialize(publicationIdentifiers, "Array<string>");
        }

        if (publicationYear !== undefined) {
            localVarQueryParameters['publication_year'] = ObjectSerializer.serialize(publicationYear, "Array<number>");
        }

        if (publishedBy !== undefined) {
            localVarQueryParameters['published_by'] = ObjectSerializer.serialize(publishedBy, "Array<'community' | 'IGVF' | 'ENCODE'>");
        }

        if (releaseTimestamp !== undefined) {
            localVarQueryParameters['release_timestamp'] = ObjectSerializer.serialize(releaseTimestamp, "Array<string>");
        }

        if (samples !== undefined) {
            localVarQueryParameters['samples'] = ObjectSerializer.serialize(samples, "Array<string>");
        }

        if (software !== undefined) {
            localVarQueryParameters['software'] = ObjectSerializer.serialize(software, "Array<string>");
        }

        if (softwareVersions !== undefined) {
            localVarQueryParameters['software_versions'] = ObjectSerializer.serialize(softwareVersions, "Array<string>");
        }

        if (status !== undefined) {
            localVarQueryParameters['status'] = ObjectSerializer.serialize(status, "Array<'archived' | 'deleted' | 'in progress' | 'released'>");
        }

        if (submittedById !== undefined) {
            localVarQueryParameters['submitted_by.@id'] = ObjectSerializer.serialize(submittedById, "Array<string>");
        }

        if (submittedByTitle !== undefined) {
            localVarQueryParameters['submitted_by.title'] = ObjectSerializer.serialize(submittedByTitle, "Array<string>");
        }

        if (submitterComment !== undefined) {
            localVarQueryParameters['submitter_comment'] = ObjectSerializer.serialize(submitterComment, "Array<string>");
        }

        if (summary !== undefined) {
            localVarQueryParameters['summary'] = ObjectSerializer.serialize(summary, "Array<string>");
        }

        if (title !== undefined) {
            localVarQueryParameters['title'] = ObjectSerializer.serialize(title, "Array<string>");
        }

        if (uuid !== undefined) {
            localVarQueryParameters['uuid'] = ObjectSerializer.serialize(uuid, "Array<string>");
        }

        if (volume !== undefined) {
            localVarQueryParameters['volume'] = ObjectSerializer.serialize(volume, "Array<string>");
        }

        if (workflows !== undefined) {
            localVarQueryParameters['workflows'] = ObjectSerializer.serialize(workflows, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: PublicationResults;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "PublicationResults");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Collection endpoint that accepts various query parameters to filter, sort, and paginate ReferenceFile items. Supports filtering on fields within ReferenceFile items.
     * @summary List items in the ReferenceFile collection.
     * @param frame Constant value. Do not set.
     * @param query Query string for searching.
     * @param limit Maximum number of results to return. Default is 25. Use \&#39;all\&#39; for all results.
     * @param sort Fields to sort results by. Prefix with \&#39;-\&#39; for descending order. Can be repeated for multiple sort fields. Does not work with limit&#x3D;all.
     * @param id Filter by @id
     * @param accession Filter by accession
     * @param aliases Filter by aliases
     * @param alternateAccessions Filter by alternate_accessions
     * @param analysisStepVersion Filter by analysis_step_version
     * @param anvilUrl Filter by anvil_url
     * @param assembly Filter by assembly
     * @param awardId Filter by award.@id
     * @param awardComponent Filter by award.component
     * @param collections Filter by collections
     * @param contentMd5sum Filter by content_md5sum
     * @param contentType Filter by content_type
     * @param controlledAccess Filter by controlled_access
     * @param creationTimestamp Filter by creation_timestamp
     * @param dbxrefs Filter by dbxrefs
     * @param derivedFrom Filter by derived_from
     * @param description Filter by description
     * @param documents Filter by documents
     * @param external Filter by external
     * @param externalId Filter by external_id
     * @param fileFormat Filter by file_format
     * @param fileFormatSpecifications Filter by file_format_specifications
     * @param fileFormatType Filter by file_format_type
     * @param fileSet Filter by file_set
     * @param fileSize Filter by file_size
     * @param geneListFor Filter by gene_list_for
     * @param href Filter by href
     * @param inputFileFor Filter by input_file_for
     * @param integratedIn Filter by integrated_in
     * @param labId Filter by lab.@id
     * @param labTitle Filter by lab.title
     * @param lociListFor Filter by loci_list_for
     * @param md5sum Filter by md5sum
     * @param notes Filter by notes
     * @param releaseTimestamp Filter by release_timestamp
     * @param revokeDetail Filter by revoke_detail
     * @param s3Uri Filter by s3_uri
     * @param sourceUrl Filter by source_url
     * @param sources Filter by sources
     * @param status Filter by status
     * @param submittedById Filter by submitted_by.@id
     * @param submittedByTitle Filter by submitted_by.title
     * @param submittedFileName Filter by submitted_file_name
     * @param submitterComment Filter by submitter_comment
     * @param summary Filter by summary
     * @param transcriptomeAnnotation Filter by transcriptome_annotation
     * @param uploadStatus Filter by upload_status
     * @param uuid Filter by uuid
     * @param validationErrorDetail Filter by validation_error_detail
     */
    public async referenceFiles (frame: 'object', query?: string, limit?: Limit, sort?: Array<string>, id?: Array<string>, accession?: Array<string>, aliases?: Array<string>, alternateAccessions?: Array<string>, analysisStepVersion?: Array<string>, anvilUrl?: Array<string>, assembly?: Array<'GRCh38' | 'hg19' | 'GRCm39' | 'mm10'>, awardId?: Array<string>, awardComponent?: Array<'affiliate' | 'data analysis' | 'data coordination' | 'functional characterization' | 'mapping' | 'networks' | 'predictive modeling'>, collections?: Array<'ClinGen' | 'ENCODE' | 'GREGoR' | 'IGVF_catalog_beta_v0.1' | 'IGVF_catalog_beta_v0.2' | 'IGVF_catalog_beta_v0.3' | 'IGVF_catalog_beta_v0.4' | 'MaveDB' | 'MPRAbase' | 'Vista'>, contentMd5sum?: Array<string>, contentType?: Array<string>, controlledAccess?: Array<boolean>, creationTimestamp?: Array<string>, dbxrefs?: Array<string>, derivedFrom?: Array<string>, description?: Array<string>, documents?: Array<string>, external?: Array<boolean>, externalId?: Array<string>, fileFormat?: Array<'bed' | 'csv' | 'dat' | 'fasta' | 'gaf' | 'gds' | 'gtf' | 'obo' | 'owl' | 'PWM' | 'tar' | 'tsv' | 'txt' | 'vcf' | 'xml'>, fileFormatSpecifications?: Array<string>, fileFormatType?: Array<'bed12' | 'bed3' | 'bed3+' | 'bed5' | 'bed6' | 'bed6+' | 'bed9' | 'bed9+' | 'mpra_starr'>, fileSet?: Array<string>, fileSize?: Array<number>, geneListFor?: Array<string>, href?: Array<string>, inputFileFor?: Array<string>, integratedIn?: Array<string>, labId?: Array<string>, labTitle?: Array<string>, lociListFor?: Array<string>, md5sum?: Array<string>, notes?: Array<string>, releaseTimestamp?: Array<string>, revokeDetail?: Array<string>, s3Uri?: Array<string>, sourceUrl?: Array<string>, sources?: Array<string>, status?: Array<'in progress' | 'released' | 'deleted' | 'replaced' | 'revoked' | 'archived'>, submittedById?: Array<string>, submittedByTitle?: Array<string>, submittedFileName?: Array<string>, submitterComment?: Array<string>, summary?: Array<string>, transcriptomeAnnotation?: Array<'GENCODE 40' | 'GENCODE 41' | 'GENCODE 42' | 'GENCODE 43' | 'GENCODE 44' | 'GENCODE 45' | 'GENCODE M30' | 'GENCODE M31' | 'GENCODE M32' | 'GENCODE M33' | 'GENCODE M34'>, uploadStatus?: Array<'pending' | 'file not found' | 'invalidated' | 'validated'>, uuid?: Array<string>, validationErrorDetail?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: ReferenceFileResults;  }> {
        const localVarPath = this.basePath + '/reference-files/@@listing';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'frame' is not null or undefined
        if (frame === null || frame === undefined) {
            throw new Error('Required parameter frame was null or undefined when calling referenceFiles.');
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (frame !== undefined) {
            localVarQueryParameters['frame'] = ObjectSerializer.serialize(frame, "'object'");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "Limit");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "Array<string>");
        }

        if (id !== undefined) {
            localVarQueryParameters['@id'] = ObjectSerializer.serialize(id, "Array<string>");
        }

        if (accession !== undefined) {
            localVarQueryParameters['accession'] = ObjectSerializer.serialize(accession, "Array<string>");
        }

        if (aliases !== undefined) {
            localVarQueryParameters['aliases'] = ObjectSerializer.serialize(aliases, "Array<string>");
        }

        if (alternateAccessions !== undefined) {
            localVarQueryParameters['alternate_accessions'] = ObjectSerializer.serialize(alternateAccessions, "Array<string>");
        }

        if (analysisStepVersion !== undefined) {
            localVarQueryParameters['analysis_step_version'] = ObjectSerializer.serialize(analysisStepVersion, "Array<string>");
        }

        if (anvilUrl !== undefined) {
            localVarQueryParameters['anvil_url'] = ObjectSerializer.serialize(anvilUrl, "Array<string>");
        }

        if (assembly !== undefined) {
            localVarQueryParameters['assembly'] = ObjectSerializer.serialize(assembly, "Array<'GRCh38' | 'hg19' | 'GRCm39' | 'mm10'>");
        }

        if (awardId !== undefined) {
            localVarQueryParameters['award.@id'] = ObjectSerializer.serialize(awardId, "Array<string>");
        }

        if (awardComponent !== undefined) {
            localVarQueryParameters['award.component'] = ObjectSerializer.serialize(awardComponent, "Array<'affiliate' | 'data analysis' | 'data coordination' | 'functional characterization' | 'mapping' | 'networks' | 'predictive modeling'>");
        }

        if (collections !== undefined) {
            localVarQueryParameters['collections'] = ObjectSerializer.serialize(collections, "Array<'ClinGen' | 'ENCODE' | 'GREGoR' | 'IGVF_catalog_beta_v0.1' | 'IGVF_catalog_beta_v0.2' | 'IGVF_catalog_beta_v0.3' | 'IGVF_catalog_beta_v0.4' | 'MaveDB' | 'MPRAbase' | 'Vista'>");
        }

        if (contentMd5sum !== undefined) {
            localVarQueryParameters['content_md5sum'] = ObjectSerializer.serialize(contentMd5sum, "Array<string>");
        }

        if (contentType !== undefined) {
            localVarQueryParameters['content_type'] = ObjectSerializer.serialize(contentType, "Array<string>");
        }

        if (controlledAccess !== undefined) {
            localVarQueryParameters['controlled_access'] = ObjectSerializer.serialize(controlledAccess, "Array<boolean>");
        }

        if (creationTimestamp !== undefined) {
            localVarQueryParameters['creation_timestamp'] = ObjectSerializer.serialize(creationTimestamp, "Array<string>");
        }

        if (dbxrefs !== undefined) {
            localVarQueryParameters['dbxrefs'] = ObjectSerializer.serialize(dbxrefs, "Array<string>");
        }

        if (derivedFrom !== undefined) {
            localVarQueryParameters['derived_from'] = ObjectSerializer.serialize(derivedFrom, "Array<string>");
        }

        if (description !== undefined) {
            localVarQueryParameters['description'] = ObjectSerializer.serialize(description, "Array<string>");
        }

        if (documents !== undefined) {
            localVarQueryParameters['documents'] = ObjectSerializer.serialize(documents, "Array<string>");
        }

        if (external !== undefined) {
            localVarQueryParameters['external'] = ObjectSerializer.serialize(external, "Array<boolean>");
        }

        if (externalId !== undefined) {
            localVarQueryParameters['external_id'] = ObjectSerializer.serialize(externalId, "Array<string>");
        }

        if (fileFormat !== undefined) {
            localVarQueryParameters['file_format'] = ObjectSerializer.serialize(fileFormat, "Array<'bed' | 'csv' | 'dat' | 'fasta' | 'gaf' | 'gds' | 'gtf' | 'obo' | 'owl' | 'PWM' | 'tar' | 'tsv' | 'txt' | 'vcf' | 'xml'>");
        }

        if (fileFormatSpecifications !== undefined) {
            localVarQueryParameters['file_format_specifications'] = ObjectSerializer.serialize(fileFormatSpecifications, "Array<string>");
        }

        if (fileFormatType !== undefined) {
            localVarQueryParameters['file_format_type'] = ObjectSerializer.serialize(fileFormatType, "Array<'bed12' | 'bed3' | 'bed3+' | 'bed5' | 'bed6' | 'bed6+' | 'bed9' | 'bed9+' | 'mpra_starr'>");
        }

        if (fileSet !== undefined) {
            localVarQueryParameters['file_set'] = ObjectSerializer.serialize(fileSet, "Array<string>");
        }

        if (fileSize !== undefined) {
            localVarQueryParameters['file_size'] = ObjectSerializer.serialize(fileSize, "Array<number>");
        }

        if (geneListFor !== undefined) {
            localVarQueryParameters['gene_list_for'] = ObjectSerializer.serialize(geneListFor, "Array<string>");
        }

        if (href !== undefined) {
            localVarQueryParameters['href'] = ObjectSerializer.serialize(href, "Array<string>");
        }

        if (inputFileFor !== undefined) {
            localVarQueryParameters['input_file_for'] = ObjectSerializer.serialize(inputFileFor, "Array<string>");
        }

        if (integratedIn !== undefined) {
            localVarQueryParameters['integrated_in'] = ObjectSerializer.serialize(integratedIn, "Array<string>");
        }

        if (labId !== undefined) {
            localVarQueryParameters['lab.@id'] = ObjectSerializer.serialize(labId, "Array<string>");
        }

        if (labTitle !== undefined) {
            localVarQueryParameters['lab.title'] = ObjectSerializer.serialize(labTitle, "Array<string>");
        }

        if (lociListFor !== undefined) {
            localVarQueryParameters['loci_list_for'] = ObjectSerializer.serialize(lociListFor, "Array<string>");
        }

        if (md5sum !== undefined) {
            localVarQueryParameters['md5sum'] = ObjectSerializer.serialize(md5sum, "Array<string>");
        }

        if (notes !== undefined) {
            localVarQueryParameters['notes'] = ObjectSerializer.serialize(notes, "Array<string>");
        }

        if (releaseTimestamp !== undefined) {
            localVarQueryParameters['release_timestamp'] = ObjectSerializer.serialize(releaseTimestamp, "Array<string>");
        }

        if (revokeDetail !== undefined) {
            localVarQueryParameters['revoke_detail'] = ObjectSerializer.serialize(revokeDetail, "Array<string>");
        }

        if (s3Uri !== undefined) {
            localVarQueryParameters['s3_uri'] = ObjectSerializer.serialize(s3Uri, "Array<string>");
        }

        if (sourceUrl !== undefined) {
            localVarQueryParameters['source_url'] = ObjectSerializer.serialize(sourceUrl, "Array<string>");
        }

        if (sources !== undefined) {
            localVarQueryParameters['sources'] = ObjectSerializer.serialize(sources, "Array<string>");
        }

        if (status !== undefined) {
            localVarQueryParameters['status'] = ObjectSerializer.serialize(status, "Array<'in progress' | 'released' | 'deleted' | 'replaced' | 'revoked' | 'archived'>");
        }

        if (submittedById !== undefined) {
            localVarQueryParameters['submitted_by.@id'] = ObjectSerializer.serialize(submittedById, "Array<string>");
        }

        if (submittedByTitle !== undefined) {
            localVarQueryParameters['submitted_by.title'] = ObjectSerializer.serialize(submittedByTitle, "Array<string>");
        }

        if (submittedFileName !== undefined) {
            localVarQueryParameters['submitted_file_name'] = ObjectSerializer.serialize(submittedFileName, "Array<string>");
        }

        if (submitterComment !== undefined) {
            localVarQueryParameters['submitter_comment'] = ObjectSerializer.serialize(submitterComment, "Array<string>");
        }

        if (summary !== undefined) {
            localVarQueryParameters['summary'] = ObjectSerializer.serialize(summary, "Array<string>");
        }

        if (transcriptomeAnnotation !== undefined) {
            localVarQueryParameters['transcriptome_annotation'] = ObjectSerializer.serialize(transcriptomeAnnotation, "Array<'GENCODE 40' | 'GENCODE 41' | 'GENCODE 42' | 'GENCODE 43' | 'GENCODE 44' | 'GENCODE 45' | 'GENCODE M30' | 'GENCODE M31' | 'GENCODE M32' | 'GENCODE M33' | 'GENCODE M34'>");
        }

        if (uploadStatus !== undefined) {
            localVarQueryParameters['upload_status'] = ObjectSerializer.serialize(uploadStatus, "Array<'pending' | 'file not found' | 'invalidated' | 'validated'>");
        }

        if (uuid !== undefined) {
            localVarQueryParameters['uuid'] = ObjectSerializer.serialize(uuid, "Array<string>");
        }

        if (validationErrorDetail !== undefined) {
            localVarQueryParameters['validation_error_detail'] = ObjectSerializer.serialize(validationErrorDetail, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: ReferenceFileResults;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "ReferenceFileResults");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Like /search endpoint but returns a TSV file instead of JSON. Must specify item type(s).
     * @summary Generate a report based on search query. All results are returned.
     * @param query Query string for searching.
     * @param type Filter by item type.
     * @param limit Maximum number of results to return. Default is 25. Use \&#39;all\&#39; for all results.
     * @param sort Fields to sort results by. Prefix with \&#39;-\&#39; for descending order. Does not work with limit&#x3D;all.
     * @param fieldFilters Any field from any item type can be used as a filter. Use \&#39;!\&#39; at end of field name for negation and \&#39;lt:\&#39;, \&#39;lte:\&#39;, \&#39;gt:\&#39;, \&#39;gte:\&#39; with value for range queries on numeric fields. Examples: {\&#39;status!\&#39;: \&#39;in progress\&#39;, \&#39;file_size\&#39;: \&#39;gte:30000\&#39;}
     * @param include_fields Fields to include in the response. Can be repeated for multiple fields.
     * @param frame Object with links, or object with some links embedded.
     */
    public async report (query?: string, type?: Array<string>, limit?: Limit, sort?: Array<string>, fieldFilters?: object, include_fields?: Array<string>, frame?: 'object' | 'embedded', options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: string;  }> {
        const localVarPath = this.basePath + '/multireport.tsv';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['text/tab-separated-values', 'application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (type !== undefined) {
            localVarQueryParameters['type'] = ObjectSerializer.serialize(type, "Array<string>");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "Limit");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "Array<string>");
        }

        if (fieldFilters !== undefined) {
            localVarQueryParameters['field_filters'] = ObjectSerializer.serialize(fieldFilters, "object");
        }

        if (include_fields !== undefined) {
            localVarQueryParameters['field'] = ObjectSerializer.serialize(include_fields, "Array<string>");
        }

        if (frame !== undefined) {
            localVarQueryParameters['frame'] = ObjectSerializer.serialize(frame, "'object' | 'embedded'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: string;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "string");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Collection endpoint that accepts various query parameters to filter, sort, and paginate RodentDonor items. Supports filtering on fields within RodentDonor items.
     * @summary List items in the RodentDonor collection.
     * @param frame Constant value. Do not set.
     * @param query Query string for searching.
     * @param limit Maximum number of results to return. Default is 25. Use \&#39;all\&#39; for all results.
     * @param sort Fields to sort results by. Prefix with \&#39;-\&#39; for descending order. Can be repeated for multiple sort fields. Does not work with limit&#x3D;all.
     * @param id Filter by @id
     * @param accession Filter by accession
     * @param aliases Filter by aliases
     * @param alternateAccessions Filter by alternate_accessions
     * @param awardId Filter by award.@id
     * @param awardComponent Filter by award.component
     * @param collections Filter by collections
     * @param creationTimestamp Filter by creation_timestamp
     * @param dbxrefs Filter by dbxrefs
     * @param description Filter by description
     * @param documents Filter by documents
     * @param genotype Filter by genotype
     * @param individualRodent Filter by individual_rodent
     * @param labId Filter by lab.@id
     * @param labTitle Filter by lab.title
     * @param lotId Filter by lot_id
     * @param notes Filter by notes
     * @param phenotypicFeaturesId Filter by phenotypic_features.@id
     * @param phenotypicFeaturesFeatureId Filter by phenotypic_features.feature.@id
     * @param phenotypicFeaturesFeatureTermId Filter by phenotypic_features.feature.term_id
     * @param phenotypicFeaturesFeatureTermName Filter by phenotypic_features.feature.term_name
     * @param phenotypicFeaturesObservationDate Filter by phenotypic_features.observation_date
     * @param phenotypicFeaturesQuantityUnits Filter by phenotypic_features.quantity_units
     * @param productId Filter by product_id
     * @param publicationIdentifiers Filter by publication_identifiers
     * @param publications Filter by publications
     * @param releaseTimestamp Filter by release_timestamp
     * @param revokeDetail Filter by revoke_detail
     * @param rodentIdentifier Filter by rodent_identifier
     * @param sex Filter by sex
     * @param sourcesId Filter by sources.@id
     * @param status Filter by status
     * @param strain Filter by strain
     * @param strainBackground Filter by strain_background
     * @param submittedById Filter by submitted_by.@id
     * @param submittedByTitle Filter by submitted_by.title
     * @param submitterComment Filter by submitter_comment
     * @param summary Filter by summary
     * @param taxa Filter by taxa
     * @param url Filter by url
     * @param uuid Filter by uuid
     * @param virtual Filter by virtual
     */
    public async rodentDonors (frame: 'object', query?: string, limit?: Limit, sort?: Array<string>, id?: Array<string>, accession?: Array<string>, aliases?: Array<string>, alternateAccessions?: Array<string>, awardId?: Array<string>, awardComponent?: Array<'affiliate' | 'data analysis' | 'data coordination' | 'functional characterization' | 'mapping' | 'networks' | 'predictive modeling'>, collections?: Array<'ClinGen' | 'ENCODE' | 'GREGoR' | 'IGVF_catalog_beta_v0.1' | 'IGVF_catalog_beta_v0.2' | 'IGVF_catalog_beta_v0.3' | 'IGVF_catalog_beta_v0.4' | 'MaveDB' | 'MPRAbase' | 'Vista'>, creationTimestamp?: Array<string>, dbxrefs?: Array<string>, description?: Array<string>, documents?: Array<string>, genotype?: Array<string>, individualRodent?: Array<boolean>, labId?: Array<string>, labTitle?: Array<string>, lotId?: Array<string>, notes?: Array<string>, phenotypicFeaturesId?: Array<string>, phenotypicFeaturesFeatureId?: Array<string>, phenotypicFeaturesFeatureTermId?: Array<string>, phenotypicFeaturesFeatureTermName?: Array<string>, phenotypicFeaturesObservationDate?: Array<string>, phenotypicFeaturesQuantityUnits?: Array<'meter' | 'micromole' | 'nanogram' | 'microgram' | 'milligram' | 'gram' | 'kilogram' | 'milli-International Unit per milliliter' | 'picogram per milliliter' | 'nanogram per milliliter' | 'milligram per deciliter'>, productId?: Array<string>, publicationIdentifiers?: Array<string>, publications?: Array<string>, releaseTimestamp?: Array<string>, revokeDetail?: Array<string>, rodentIdentifier?: Array<string>, sex?: Array<'male' | 'female' | 'unspecified'>, sourcesId?: Array<string>, status?: Array<'in progress' | 'released' | 'deleted' | 'replaced' | 'revoked' | 'archived'>, strain?: Array<string>, strainBackground?: Array<'A/J (AJ)' | 'C57BL/6J (B6)' | '129S1/SvImJ (129)' | 'NOD/ShiLtJ (NOD)' | 'NZO/H1LtJ (NZO)' | 'CAST/EiJ (CAST)' | 'PWK/PhJ (PWK)' | 'WSB/EiJ (WSB)' | 'CAST (M. m. castaneus)' | 'WSB (M. m. domesticus)' | 'PWK (M. m. musculus)'>, submittedById?: Array<string>, submittedByTitle?: Array<string>, submitterComment?: Array<string>, summary?: Array<string>, taxa?: Array<'Mus musculus'>, url?: Array<string>, uuid?: Array<string>, virtual?: Array<boolean>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: RodentDonorResults;  }> {
        const localVarPath = this.basePath + '/rodent-donors/@@listing';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'frame' is not null or undefined
        if (frame === null || frame === undefined) {
            throw new Error('Required parameter frame was null or undefined when calling rodentDonors.');
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (frame !== undefined) {
            localVarQueryParameters['frame'] = ObjectSerializer.serialize(frame, "'object'");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "Limit");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "Array<string>");
        }

        if (id !== undefined) {
            localVarQueryParameters['@id'] = ObjectSerializer.serialize(id, "Array<string>");
        }

        if (accession !== undefined) {
            localVarQueryParameters['accession'] = ObjectSerializer.serialize(accession, "Array<string>");
        }

        if (aliases !== undefined) {
            localVarQueryParameters['aliases'] = ObjectSerializer.serialize(aliases, "Array<string>");
        }

        if (alternateAccessions !== undefined) {
            localVarQueryParameters['alternate_accessions'] = ObjectSerializer.serialize(alternateAccessions, "Array<string>");
        }

        if (awardId !== undefined) {
            localVarQueryParameters['award.@id'] = ObjectSerializer.serialize(awardId, "Array<string>");
        }

        if (awardComponent !== undefined) {
            localVarQueryParameters['award.component'] = ObjectSerializer.serialize(awardComponent, "Array<'affiliate' | 'data analysis' | 'data coordination' | 'functional characterization' | 'mapping' | 'networks' | 'predictive modeling'>");
        }

        if (collections !== undefined) {
            localVarQueryParameters['collections'] = ObjectSerializer.serialize(collections, "Array<'ClinGen' | 'ENCODE' | 'GREGoR' | 'IGVF_catalog_beta_v0.1' | 'IGVF_catalog_beta_v0.2' | 'IGVF_catalog_beta_v0.3' | 'IGVF_catalog_beta_v0.4' | 'MaveDB' | 'MPRAbase' | 'Vista'>");
        }

        if (creationTimestamp !== undefined) {
            localVarQueryParameters['creation_timestamp'] = ObjectSerializer.serialize(creationTimestamp, "Array<string>");
        }

        if (dbxrefs !== undefined) {
            localVarQueryParameters['dbxrefs'] = ObjectSerializer.serialize(dbxrefs, "Array<string>");
        }

        if (description !== undefined) {
            localVarQueryParameters['description'] = ObjectSerializer.serialize(description, "Array<string>");
        }

        if (documents !== undefined) {
            localVarQueryParameters['documents'] = ObjectSerializer.serialize(documents, "Array<string>");
        }

        if (genotype !== undefined) {
            localVarQueryParameters['genotype'] = ObjectSerializer.serialize(genotype, "Array<string>");
        }

        if (individualRodent !== undefined) {
            localVarQueryParameters['individual_rodent'] = ObjectSerializer.serialize(individualRodent, "Array<boolean>");
        }

        if (labId !== undefined) {
            localVarQueryParameters['lab.@id'] = ObjectSerializer.serialize(labId, "Array<string>");
        }

        if (labTitle !== undefined) {
            localVarQueryParameters['lab.title'] = ObjectSerializer.serialize(labTitle, "Array<string>");
        }

        if (lotId !== undefined) {
            localVarQueryParameters['lot_id'] = ObjectSerializer.serialize(lotId, "Array<string>");
        }

        if (notes !== undefined) {
            localVarQueryParameters['notes'] = ObjectSerializer.serialize(notes, "Array<string>");
        }

        if (phenotypicFeaturesId !== undefined) {
            localVarQueryParameters['phenotypic_features.@id'] = ObjectSerializer.serialize(phenotypicFeaturesId, "Array<string>");
        }

        if (phenotypicFeaturesFeatureId !== undefined) {
            localVarQueryParameters['phenotypic_features.feature.@id'] = ObjectSerializer.serialize(phenotypicFeaturesFeatureId, "Array<string>");
        }

        if (phenotypicFeaturesFeatureTermId !== undefined) {
            localVarQueryParameters['phenotypic_features.feature.term_id'] = ObjectSerializer.serialize(phenotypicFeaturesFeatureTermId, "Array<string>");
        }

        if (phenotypicFeaturesFeatureTermName !== undefined) {
            localVarQueryParameters['phenotypic_features.feature.term_name'] = ObjectSerializer.serialize(phenotypicFeaturesFeatureTermName, "Array<string>");
        }

        if (phenotypicFeaturesObservationDate !== undefined) {
            localVarQueryParameters['phenotypic_features.observation_date'] = ObjectSerializer.serialize(phenotypicFeaturesObservationDate, "Array<string>");
        }

        if (phenotypicFeaturesQuantityUnits !== undefined) {
            localVarQueryParameters['phenotypic_features.quantity_units'] = ObjectSerializer.serialize(phenotypicFeaturesQuantityUnits, "Array<'meter' | 'micromole' | 'nanogram' | 'microgram' | 'milligram' | 'gram' | 'kilogram' | 'milli-International Unit per milliliter' | 'picogram per milliliter' | 'nanogram per milliliter' | 'milligram per deciliter'>");
        }

        if (productId !== undefined) {
            localVarQueryParameters['product_id'] = ObjectSerializer.serialize(productId, "Array<string>");
        }

        if (publicationIdentifiers !== undefined) {
            localVarQueryParameters['publication_identifiers'] = ObjectSerializer.serialize(publicationIdentifiers, "Array<string>");
        }

        if (publications !== undefined) {
            localVarQueryParameters['publications'] = ObjectSerializer.serialize(publications, "Array<string>");
        }

        if (releaseTimestamp !== undefined) {
            localVarQueryParameters['release_timestamp'] = ObjectSerializer.serialize(releaseTimestamp, "Array<string>");
        }

        if (revokeDetail !== undefined) {
            localVarQueryParameters['revoke_detail'] = ObjectSerializer.serialize(revokeDetail, "Array<string>");
        }

        if (rodentIdentifier !== undefined) {
            localVarQueryParameters['rodent_identifier'] = ObjectSerializer.serialize(rodentIdentifier, "Array<string>");
        }

        if (sex !== undefined) {
            localVarQueryParameters['sex'] = ObjectSerializer.serialize(sex, "Array<'male' | 'female' | 'unspecified'>");
        }

        if (sourcesId !== undefined) {
            localVarQueryParameters['sources.@id'] = ObjectSerializer.serialize(sourcesId, "Array<string>");
        }

        if (status !== undefined) {
            localVarQueryParameters['status'] = ObjectSerializer.serialize(status, "Array<'in progress' | 'released' | 'deleted' | 'replaced' | 'revoked' | 'archived'>");
        }

        if (strain !== undefined) {
            localVarQueryParameters['strain'] = ObjectSerializer.serialize(strain, "Array<string>");
        }

        if (strainBackground !== undefined) {
            localVarQueryParameters['strain_background'] = ObjectSerializer.serialize(strainBackground, "Array<'A/J (AJ)' | 'C57BL/6J (B6)' | '129S1/SvImJ (129)' | 'NOD/ShiLtJ (NOD)' | 'NZO/H1LtJ (NZO)' | 'CAST/EiJ (CAST)' | 'PWK/PhJ (PWK)' | 'WSB/EiJ (WSB)' | 'CAST (M. m. castaneus)' | 'WSB (M. m. domesticus)' | 'PWK (M. m. musculus)'>");
        }

        if (submittedById !== undefined) {
            localVarQueryParameters['submitted_by.@id'] = ObjectSerializer.serialize(submittedById, "Array<string>");
        }

        if (submittedByTitle !== undefined) {
            localVarQueryParameters['submitted_by.title'] = ObjectSerializer.serialize(submittedByTitle, "Array<string>");
        }

        if (submitterComment !== undefined) {
            localVarQueryParameters['submitter_comment'] = ObjectSerializer.serialize(submitterComment, "Array<string>");
        }

        if (summary !== undefined) {
            localVarQueryParameters['summary'] = ObjectSerializer.serialize(summary, "Array<string>");
        }

        if (taxa !== undefined) {
            localVarQueryParameters['taxa'] = ObjectSerializer.serialize(taxa, "Array<'Mus musculus'>");
        }

        if (url !== undefined) {
            localVarQueryParameters['url'] = ObjectSerializer.serialize(url, "Array<string>");
        }

        if (uuid !== undefined) {
            localVarQueryParameters['uuid'] = ObjectSerializer.serialize(uuid, "Array<string>");
        }

        if (virtual !== undefined) {
            localVarQueryParameters['virtual'] = ObjectSerializer.serialize(virtual, "Array<boolean>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: RodentDonorResults;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "RodentDonorResults");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Collection endpoint that accepts various query parameters to filter, sort, and paginate SampleTerm items. Supports filtering on fields within SampleTerm items.
     * @summary List items in the SampleTerm collection.
     * @param frame Constant value. Do not set.
     * @param query Query string for searching.
     * @param limit Maximum number of results to return. Default is 25. Use \&#39;all\&#39; for all results.
     * @param sort Fields to sort results by. Prefix with \&#39;-\&#39; for descending order. Can be repeated for multiple sort fields. Does not work with limit&#x3D;all.
     * @param id Filter by @id
     * @param aliases Filter by aliases
     * @param ancestors Filter by ancestors
     * @param cellSlims Filter by cell_slims
     * @param creationTimestamp Filter by creation_timestamp
     * @param dbxrefs Filter by dbxrefs
     * @param deprecatedNtrTerms Filter by deprecated_ntr_terms
     * @param description Filter by description
     * @param developmentalSlims Filter by developmental_slims
     * @param isA Filter by is_a
     * @param name Filter by name
     * @param notes Filter by notes
     * @param ontology Filter by ontology
     * @param organSlims Filter by organ_slims
     * @param releaseTimestamp Filter by release_timestamp
     * @param status Filter by status
     * @param submittedById Filter by submitted_by.@id
     * @param submittedByTitle Filter by submitted_by.title
     * @param submitterComment Filter by submitter_comment
     * @param summary Filter by summary
     * @param synonyms Filter by synonyms
     * @param systemSlims Filter by system_slims
     * @param termId Filter by term_id
     * @param termName Filter by term_name
     * @param uuid Filter by uuid
     */
    public async sampleTerms (frame: 'object', query?: string, limit?: Limit, sort?: Array<string>, id?: Array<string>, aliases?: Array<string>, ancestors?: Array<string>, cellSlims?: Array<string>, creationTimestamp?: Array<string>, dbxrefs?: Array<string>, deprecatedNtrTerms?: Array<string>, description?: Array<string>, developmentalSlims?: Array<string>, isA?: Array<string>, name?: Array<string>, notes?: Array<string>, ontology?: Array<string>, organSlims?: Array<string>, releaseTimestamp?: Array<string>, status?: Array<'archived' | 'deleted' | 'in progress' | 'released'>, submittedById?: Array<string>, submittedByTitle?: Array<string>, submitterComment?: Array<string>, summary?: Array<string>, synonyms?: Array<string>, systemSlims?: Array<string>, termId?: Array<string>, termName?: Array<string>, uuid?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: SampleTermResults;  }> {
        const localVarPath = this.basePath + '/sample-terms/@@listing';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'frame' is not null or undefined
        if (frame === null || frame === undefined) {
            throw new Error('Required parameter frame was null or undefined when calling sampleTerms.');
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (frame !== undefined) {
            localVarQueryParameters['frame'] = ObjectSerializer.serialize(frame, "'object'");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "Limit");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "Array<string>");
        }

        if (id !== undefined) {
            localVarQueryParameters['@id'] = ObjectSerializer.serialize(id, "Array<string>");
        }

        if (aliases !== undefined) {
            localVarQueryParameters['aliases'] = ObjectSerializer.serialize(aliases, "Array<string>");
        }

        if (ancestors !== undefined) {
            localVarQueryParameters['ancestors'] = ObjectSerializer.serialize(ancestors, "Array<string>");
        }

        if (cellSlims !== undefined) {
            localVarQueryParameters['cell_slims'] = ObjectSerializer.serialize(cellSlims, "Array<string>");
        }

        if (creationTimestamp !== undefined) {
            localVarQueryParameters['creation_timestamp'] = ObjectSerializer.serialize(creationTimestamp, "Array<string>");
        }

        if (dbxrefs !== undefined) {
            localVarQueryParameters['dbxrefs'] = ObjectSerializer.serialize(dbxrefs, "Array<string>");
        }

        if (deprecatedNtrTerms !== undefined) {
            localVarQueryParameters['deprecated_ntr_terms'] = ObjectSerializer.serialize(deprecatedNtrTerms, "Array<string>");
        }

        if (description !== undefined) {
            localVarQueryParameters['description'] = ObjectSerializer.serialize(description, "Array<string>");
        }

        if (developmentalSlims !== undefined) {
            localVarQueryParameters['developmental_slims'] = ObjectSerializer.serialize(developmentalSlims, "Array<string>");
        }

        if (isA !== undefined) {
            localVarQueryParameters['is_a'] = ObjectSerializer.serialize(isA, "Array<string>");
        }

        if (name !== undefined) {
            localVarQueryParameters['name'] = ObjectSerializer.serialize(name, "Array<string>");
        }

        if (notes !== undefined) {
            localVarQueryParameters['notes'] = ObjectSerializer.serialize(notes, "Array<string>");
        }

        if (ontology !== undefined) {
            localVarQueryParameters['ontology'] = ObjectSerializer.serialize(ontology, "Array<string>");
        }

        if (organSlims !== undefined) {
            localVarQueryParameters['organ_slims'] = ObjectSerializer.serialize(organSlims, "Array<string>");
        }

        if (releaseTimestamp !== undefined) {
            localVarQueryParameters['release_timestamp'] = ObjectSerializer.serialize(releaseTimestamp, "Array<string>");
        }

        if (status !== undefined) {
            localVarQueryParameters['status'] = ObjectSerializer.serialize(status, "Array<'archived' | 'deleted' | 'in progress' | 'released'>");
        }

        if (submittedById !== undefined) {
            localVarQueryParameters['submitted_by.@id'] = ObjectSerializer.serialize(submittedById, "Array<string>");
        }

        if (submittedByTitle !== undefined) {
            localVarQueryParameters['submitted_by.title'] = ObjectSerializer.serialize(submittedByTitle, "Array<string>");
        }

        if (submitterComment !== undefined) {
            localVarQueryParameters['submitter_comment'] = ObjectSerializer.serialize(submitterComment, "Array<string>");
        }

        if (summary !== undefined) {
            localVarQueryParameters['summary'] = ObjectSerializer.serialize(summary, "Array<string>");
        }

        if (synonyms !== undefined) {
            localVarQueryParameters['synonyms'] = ObjectSerializer.serialize(synonyms, "Array<string>");
        }

        if (systemSlims !== undefined) {
            localVarQueryParameters['system_slims'] = ObjectSerializer.serialize(systemSlims, "Array<string>");
        }

        if (termId !== undefined) {
            localVarQueryParameters['term_id'] = ObjectSerializer.serialize(termId, "Array<string>");
        }

        if (termName !== undefined) {
            localVarQueryParameters['term_name'] = ObjectSerializer.serialize(termName, "Array<string>");
        }

        if (uuid !== undefined) {
            localVarQueryParameters['uuid'] = ObjectSerializer.serialize(uuid, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: SampleTermResults;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "SampleTermResults");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Returns JSON schemas of all the item types defined in IGVF
     * @summary Retrieve JSON schema for item type
     * @param itemType The name of the item type
     */
    public async schemaForItemType (itemType: ItemType, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: object;  }> {
        const localVarPath = this.basePath + '/profiles/{item_type}'
            .replace('{' + 'item_type' + '}', encodeURIComponent(String(itemType)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'itemType' is not null or undefined
        if (itemType === null || itemType === undefined) {
            throw new Error('Required parameter itemType was null or undefined when calling schemaForItemType.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "object");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Returns JSON schemas of all the item types defined in IGVF
     * @summary Retrieve JSON schemas for all item types
     */
    public async schemas (options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: object;  }> {
        const localVarPath = this.basePath + '/profiles';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "object");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Search endpoint that accepts various query parameters to filter, sort, and paginate results. Supports complex filtering on types and fields within JSON objects.
     * @summary Search for items in the IGVF Project.
     * @param frame Constant value. Do not set.
     * @param query Query string for searching.
     * @param type Filter by item type.
     * @param limit Maximum number of results to return. Default is 25. Use \&#39;all\&#39; for all results.
     * @param sort Fields to sort results by. Prefix with \&#39;-\&#39; for descending order. Does not work with limit&#x3D;all.
     * @param fieldFilters Any field from any item type can be used as a filter. Use \&#39;!\&#39; at end of field name for negation and \&#39;lt:\&#39;, \&#39;lte:\&#39;, \&#39;gt:\&#39;, \&#39;gte:\&#39; with value for range queries on numeric fields. Examples: {\&#39;status!\&#39;: \&#39;in progress\&#39;, \&#39;file_size\&#39;: \&#39;gte:30000\&#39;}
     */
    public async search (frame: 'object', query?: string, type?: Array<string>, limit?: Limit, sort?: Array<string>, fieldFilters?: object, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: SearchResults;  }> {
        const localVarPath = this.basePath + '/search';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'frame' is not null or undefined
        if (frame === null || frame === undefined) {
            throw new Error('Required parameter frame was null or undefined when calling search.');
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (type !== undefined) {
            localVarQueryParameters['type'] = ObjectSerializer.serialize(type, "Array<string>");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "Limit");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "Array<string>");
        }

        if (fieldFilters !== undefined) {
            localVarQueryParameters['field_filters'] = ObjectSerializer.serialize(fieldFilters, "object");
        }

        if (frame !== undefined) {
            localVarQueryParameters['frame'] = ObjectSerializer.serialize(frame, "'object'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: SearchResults;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "SearchResults");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Collection endpoint that accepts various query parameters to filter, sort, and paginate SequenceFile items. Supports filtering on fields within SequenceFile items.
     * @summary List items in the SequenceFile collection.
     * @param frame Constant value. Do not set.
     * @param query Query string for searching.
     * @param limit Maximum number of results to return. Default is 25. Use \&#39;all\&#39; for all results.
     * @param sort Fields to sort results by. Prefix with \&#39;-\&#39; for descending order. Can be repeated for multiple sort fields. Does not work with limit&#x3D;all.
     * @param id Filter by @id
     * @param accession Filter by accession
     * @param aliases Filter by aliases
     * @param alternateAccessions Filter by alternate_accessions
     * @param analysisStepVersion Filter by analysis_step_version
     * @param anvilUrl Filter by anvil_url
     * @param awardId Filter by award.@id
     * @param awardComponent Filter by award.component
     * @param collections Filter by collections
     * @param contentMd5sum Filter by content_md5sum
     * @param contentType Filter by content_type
     * @param controlledAccess Filter by controlled_access
     * @param creationTimestamp Filter by creation_timestamp
     * @param dbxrefs Filter by dbxrefs
     * @param derivedFrom Filter by derived_from
     * @param description Filter by description
     * @param documents Filter by documents
     * @param fileFormat Filter by file_format
     * @param fileFormatSpecifications Filter by file_format_specifications
     * @param fileSet Filter by file_set
     * @param fileSize Filter by file_size
     * @param flowcellId Filter by flowcell_id
     * @param geneListFor Filter by gene_list_for
     * @param href Filter by href
     * @param illuminaReadType Filter by illumina_read_type
     * @param index Filter by index
     * @param inputFileFor Filter by input_file_for
     * @param integratedIn Filter by integrated_in
     * @param labId Filter by lab.@id
     * @param labTitle Filter by lab.title
     * @param lane Filter by lane
     * @param lociListFor Filter by loci_list_for
     * @param maximumReadLength Filter by maximum_read_length
     * @param md5sum Filter by md5sum
     * @param meanReadLength Filter by mean_read_length
     * @param minimumReadLength Filter by minimum_read_length
     * @param notes Filter by notes
     * @param readCount Filter by read_count
     * @param releaseTimestamp Filter by release_timestamp
     * @param revokeDetail Filter by revoke_detail
     * @param s3Uri Filter by s3_uri
     * @param seqspecs Filter by seqspecs
     * @param sequencingKit Filter by sequencing_kit
     * @param sequencingPlatform Filter by sequencing_platform
     * @param sequencingRun Filter by sequencing_run
     * @param status Filter by status
     * @param submittedById Filter by submitted_by.@id
     * @param submittedByTitle Filter by submitted_by.title
     * @param submittedFileName Filter by submitted_file_name
     * @param submitterComment Filter by submitter_comment
     * @param summary Filter by summary
     * @param uploadStatus Filter by upload_status
     * @param uuid Filter by uuid
     * @param validationErrorDetail Filter by validation_error_detail
     */
    public async sequenceFiles (frame: 'object', query?: string, limit?: Limit, sort?: Array<string>, id?: Array<string>, accession?: Array<string>, aliases?: Array<string>, alternateAccessions?: Array<string>, analysisStepVersion?: Array<string>, anvilUrl?: Array<string>, awardId?: Array<string>, awardComponent?: Array<'affiliate' | 'data analysis' | 'data coordination' | 'functional characterization' | 'mapping' | 'networks' | 'predictive modeling'>, collections?: Array<'ClinGen' | 'ENCODE' | 'GREGoR' | 'IGVF_catalog_beta_v0.1' | 'IGVF_catalog_beta_v0.2' | 'IGVF_catalog_beta_v0.3' | 'IGVF_catalog_beta_v0.4' | 'MaveDB' | 'MPRAbase' | 'Vista'>, contentMd5sum?: Array<string>, contentType?: Array<string>, controlledAccess?: Array<boolean>, creationTimestamp?: Array<string>, dbxrefs?: Array<string>, derivedFrom?: Array<string>, description?: Array<string>, documents?: Array<string>, fileFormat?: Array<'bam' | 'fastq' | 'pod5'>, fileFormatSpecifications?: Array<string>, fileSet?: Array<string>, fileSize?: Array<number>, flowcellId?: Array<string>, geneListFor?: Array<string>, href?: Array<string>, illuminaReadType?: Array<'R1' | 'R2' | 'R3' | 'I1' | 'I2'>, index?: Array<string>, inputFileFor?: Array<string>, integratedIn?: Array<string>, labId?: Array<string>, labTitle?: Array<string>, lane?: Array<number>, lociListFor?: Array<string>, maximumReadLength?: Array<number>, md5sum?: Array<string>, meanReadLength?: Array<number>, minimumReadLength?: Array<number>, notes?: Array<string>, readCount?: Array<number>, releaseTimestamp?: Array<string>, revokeDetail?: Array<string>, s3Uri?: Array<string>, seqspecs?: Array<string>, sequencingKit?: Array<'HiSeq SBS Kit v4' | 'HiSeq SR Cluster Kit v4-cBot-HS' | 'HiSeq PE Cluster Kit v4-cBot-HS' | 'HiSeq SR Rapid Cluster Kit v2' | 'HiSeq PE Rapid Cluster Kit v2' | 'HiSeq Rapid SBS Kit v2' | 'HiSeq 3000/4000 SBS Kit' | 'HiSeq 3000/4000 SR Cluster Kit' | 'HiSeq 3000/4000 PE Cluster Kit' | 'MiSeq Reagent Kit v2' | 'NextSeq 500 Mid Output Kit' | 'NextSeq 500 High Output Kit' | 'NextSeq 500 Mid Output v2 Kit' | 'NextSeq 500 High Output v2 Kit' | 'NextSeq 500/550 Mid-Output v2.5 Kit' | 'NextSeq 500/550 High-Output v2.5 Kit' | 'TG NextSeq 500/550 Mid-Output Kit v2.5' | 'TG NextSeq 500/550 High-Output Kit v2.5' | 'NextSeq 1000/2000 P1 Reagent Kit' | 'NextSeq 1000/2000 P2 Reagent Kit' | 'NextSeq 1000/2000 P3 Reagent Kit' | 'NextSeq 1000/2000 P1 XLEAP-SBS Reagent Kit' | 'NextSeq 1000/2000 P2 XLEAP-SBS Reagent Kit' | 'NextSeq 2000 P3 XLEAP-SBS Reagent Kit' | 'NextSeq 2000 P4 XLEAP-SBS Reagent Kit' | 'NovaSeq 6000 SP Reagent Kit v1.5' | 'NovaSeq 6000 S1 Reagent Kit v1.5' | 'NovaSeq 6000 S2 Reagent Kit v1.5' | 'NovaSeq 6000 S4 Reagent Kit v1.5' | 'NovaSeq X Series 10B Reagent Kit' | 'ONT Ligation Sequencing Kit V14' | 'Sequel sequencing kit 3.0' | 'Sequel II sequencing kit 2.0'>, sequencingPlatform?: Array<string>, sequencingRun?: Array<number>, status?: Array<'in progress' | 'released' | 'deleted' | 'replaced' | 'revoked' | 'archived'>, submittedById?: Array<string>, submittedByTitle?: Array<string>, submittedFileName?: Array<string>, submitterComment?: Array<string>, summary?: Array<string>, uploadStatus?: Array<'pending' | 'file not found' | 'invalidated' | 'validated'>, uuid?: Array<string>, validationErrorDetail?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: SequenceFileResults;  }> {
        const localVarPath = this.basePath + '/sequence-files/@@listing';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'frame' is not null or undefined
        if (frame === null || frame === undefined) {
            throw new Error('Required parameter frame was null or undefined when calling sequenceFiles.');
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (frame !== undefined) {
            localVarQueryParameters['frame'] = ObjectSerializer.serialize(frame, "'object'");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "Limit");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "Array<string>");
        }

        if (id !== undefined) {
            localVarQueryParameters['@id'] = ObjectSerializer.serialize(id, "Array<string>");
        }

        if (accession !== undefined) {
            localVarQueryParameters['accession'] = ObjectSerializer.serialize(accession, "Array<string>");
        }

        if (aliases !== undefined) {
            localVarQueryParameters['aliases'] = ObjectSerializer.serialize(aliases, "Array<string>");
        }

        if (alternateAccessions !== undefined) {
            localVarQueryParameters['alternate_accessions'] = ObjectSerializer.serialize(alternateAccessions, "Array<string>");
        }

        if (analysisStepVersion !== undefined) {
            localVarQueryParameters['analysis_step_version'] = ObjectSerializer.serialize(analysisStepVersion, "Array<string>");
        }

        if (anvilUrl !== undefined) {
            localVarQueryParameters['anvil_url'] = ObjectSerializer.serialize(anvilUrl, "Array<string>");
        }

        if (awardId !== undefined) {
            localVarQueryParameters['award.@id'] = ObjectSerializer.serialize(awardId, "Array<string>");
        }

        if (awardComponent !== undefined) {
            localVarQueryParameters['award.component'] = ObjectSerializer.serialize(awardComponent, "Array<'affiliate' | 'data analysis' | 'data coordination' | 'functional characterization' | 'mapping' | 'networks' | 'predictive modeling'>");
        }

        if (collections !== undefined) {
            localVarQueryParameters['collections'] = ObjectSerializer.serialize(collections, "Array<'ClinGen' | 'ENCODE' | 'GREGoR' | 'IGVF_catalog_beta_v0.1' | 'IGVF_catalog_beta_v0.2' | 'IGVF_catalog_beta_v0.3' | 'IGVF_catalog_beta_v0.4' | 'MaveDB' | 'MPRAbase' | 'Vista'>");
        }

        if (contentMd5sum !== undefined) {
            localVarQueryParameters['content_md5sum'] = ObjectSerializer.serialize(contentMd5sum, "Array<string>");
        }

        if (contentType !== undefined) {
            localVarQueryParameters['content_type'] = ObjectSerializer.serialize(contentType, "Array<string>");
        }

        if (controlledAccess !== undefined) {
            localVarQueryParameters['controlled_access'] = ObjectSerializer.serialize(controlledAccess, "Array<boolean>");
        }

        if (creationTimestamp !== undefined) {
            localVarQueryParameters['creation_timestamp'] = ObjectSerializer.serialize(creationTimestamp, "Array<string>");
        }

        if (dbxrefs !== undefined) {
            localVarQueryParameters['dbxrefs'] = ObjectSerializer.serialize(dbxrefs, "Array<string>");
        }

        if (derivedFrom !== undefined) {
            localVarQueryParameters['derived_from'] = ObjectSerializer.serialize(derivedFrom, "Array<string>");
        }

        if (description !== undefined) {
            localVarQueryParameters['description'] = ObjectSerializer.serialize(description, "Array<string>");
        }

        if (documents !== undefined) {
            localVarQueryParameters['documents'] = ObjectSerializer.serialize(documents, "Array<string>");
        }

        if (fileFormat !== undefined) {
            localVarQueryParameters['file_format'] = ObjectSerializer.serialize(fileFormat, "Array<'bam' | 'fastq' | 'pod5'>");
        }

        if (fileFormatSpecifications !== undefined) {
            localVarQueryParameters['file_format_specifications'] = ObjectSerializer.serialize(fileFormatSpecifications, "Array<string>");
        }

        if (fileSet !== undefined) {
            localVarQueryParameters['file_set'] = ObjectSerializer.serialize(fileSet, "Array<string>");
        }

        if (fileSize !== undefined) {
            localVarQueryParameters['file_size'] = ObjectSerializer.serialize(fileSize, "Array<number>");
        }

        if (flowcellId !== undefined) {
            localVarQueryParameters['flowcell_id'] = ObjectSerializer.serialize(flowcellId, "Array<string>");
        }

        if (geneListFor !== undefined) {
            localVarQueryParameters['gene_list_for'] = ObjectSerializer.serialize(geneListFor, "Array<string>");
        }

        if (href !== undefined) {
            localVarQueryParameters['href'] = ObjectSerializer.serialize(href, "Array<string>");
        }

        if (illuminaReadType !== undefined) {
            localVarQueryParameters['illumina_read_type'] = ObjectSerializer.serialize(illuminaReadType, "Array<'R1' | 'R2' | 'R3' | 'I1' | 'I2'>");
        }

        if (index !== undefined) {
            localVarQueryParameters['index'] = ObjectSerializer.serialize(index, "Array<string>");
        }

        if (inputFileFor !== undefined) {
            localVarQueryParameters['input_file_for'] = ObjectSerializer.serialize(inputFileFor, "Array<string>");
        }

        if (integratedIn !== undefined) {
            localVarQueryParameters['integrated_in'] = ObjectSerializer.serialize(integratedIn, "Array<string>");
        }

        if (labId !== undefined) {
            localVarQueryParameters['lab.@id'] = ObjectSerializer.serialize(labId, "Array<string>");
        }

        if (labTitle !== undefined) {
            localVarQueryParameters['lab.title'] = ObjectSerializer.serialize(labTitle, "Array<string>");
        }

        if (lane !== undefined) {
            localVarQueryParameters['lane'] = ObjectSerializer.serialize(lane, "Array<number>");
        }

        if (lociListFor !== undefined) {
            localVarQueryParameters['loci_list_for'] = ObjectSerializer.serialize(lociListFor, "Array<string>");
        }

        if (maximumReadLength !== undefined) {
            localVarQueryParameters['maximum_read_length'] = ObjectSerializer.serialize(maximumReadLength, "Array<number>");
        }

        if (md5sum !== undefined) {
            localVarQueryParameters['md5sum'] = ObjectSerializer.serialize(md5sum, "Array<string>");
        }

        if (meanReadLength !== undefined) {
            localVarQueryParameters['mean_read_length'] = ObjectSerializer.serialize(meanReadLength, "Array<number>");
        }

        if (minimumReadLength !== undefined) {
            localVarQueryParameters['minimum_read_length'] = ObjectSerializer.serialize(minimumReadLength, "Array<number>");
        }

        if (notes !== undefined) {
            localVarQueryParameters['notes'] = ObjectSerializer.serialize(notes, "Array<string>");
        }

        if (readCount !== undefined) {
            localVarQueryParameters['read_count'] = ObjectSerializer.serialize(readCount, "Array<number>");
        }

        if (releaseTimestamp !== undefined) {
            localVarQueryParameters['release_timestamp'] = ObjectSerializer.serialize(releaseTimestamp, "Array<string>");
        }

        if (revokeDetail !== undefined) {
            localVarQueryParameters['revoke_detail'] = ObjectSerializer.serialize(revokeDetail, "Array<string>");
        }

        if (s3Uri !== undefined) {
            localVarQueryParameters['s3_uri'] = ObjectSerializer.serialize(s3Uri, "Array<string>");
        }

        if (seqspecs !== undefined) {
            localVarQueryParameters['seqspecs'] = ObjectSerializer.serialize(seqspecs, "Array<string>");
        }

        if (sequencingKit !== undefined) {
            localVarQueryParameters['sequencing_kit'] = ObjectSerializer.serialize(sequencingKit, "Array<'HiSeq SBS Kit v4' | 'HiSeq SR Cluster Kit v4-cBot-HS' | 'HiSeq PE Cluster Kit v4-cBot-HS' | 'HiSeq SR Rapid Cluster Kit v2' | 'HiSeq PE Rapid Cluster Kit v2' | 'HiSeq Rapid SBS Kit v2' | 'HiSeq 3000/4000 SBS Kit' | 'HiSeq 3000/4000 SR Cluster Kit' | 'HiSeq 3000/4000 PE Cluster Kit' | 'MiSeq Reagent Kit v2' | 'NextSeq 500 Mid Output Kit' | 'NextSeq 500 High Output Kit' | 'NextSeq 500 Mid Output v2 Kit' | 'NextSeq 500 High Output v2 Kit' | 'NextSeq 500/550 Mid-Output v2.5 Kit' | 'NextSeq 500/550 High-Output v2.5 Kit' | 'TG NextSeq 500/550 Mid-Output Kit v2.5' | 'TG NextSeq 500/550 High-Output Kit v2.5' | 'NextSeq 1000/2000 P1 Reagent Kit' | 'NextSeq 1000/2000 P2 Reagent Kit' | 'NextSeq 1000/2000 P3 Reagent Kit' | 'NextSeq 1000/2000 P1 XLEAP-SBS Reagent Kit' | 'NextSeq 1000/2000 P2 XLEAP-SBS Reagent Kit' | 'NextSeq 2000 P3 XLEAP-SBS Reagent Kit' | 'NextSeq 2000 P4 XLEAP-SBS Reagent Kit' | 'NovaSeq 6000 SP Reagent Kit v1.5' | 'NovaSeq 6000 S1 Reagent Kit v1.5' | 'NovaSeq 6000 S2 Reagent Kit v1.5' | 'NovaSeq 6000 S4 Reagent Kit v1.5' | 'NovaSeq X Series 10B Reagent Kit' | 'ONT Ligation Sequencing Kit V14' | 'Sequel sequencing kit 3.0' | 'Sequel II sequencing kit 2.0'>");
        }

        if (sequencingPlatform !== undefined) {
            localVarQueryParameters['sequencing_platform'] = ObjectSerializer.serialize(sequencingPlatform, "Array<string>");
        }

        if (sequencingRun !== undefined) {
            localVarQueryParameters['sequencing_run'] = ObjectSerializer.serialize(sequencingRun, "Array<number>");
        }

        if (status !== undefined) {
            localVarQueryParameters['status'] = ObjectSerializer.serialize(status, "Array<'in progress' | 'released' | 'deleted' | 'replaced' | 'revoked' | 'archived'>");
        }

        if (submittedById !== undefined) {
            localVarQueryParameters['submitted_by.@id'] = ObjectSerializer.serialize(submittedById, "Array<string>");
        }

        if (submittedByTitle !== undefined) {
            localVarQueryParameters['submitted_by.title'] = ObjectSerializer.serialize(submittedByTitle, "Array<string>");
        }

        if (submittedFileName !== undefined) {
            localVarQueryParameters['submitted_file_name'] = ObjectSerializer.serialize(submittedFileName, "Array<string>");
        }

        if (submitterComment !== undefined) {
            localVarQueryParameters['submitter_comment'] = ObjectSerializer.serialize(submitterComment, "Array<string>");
        }

        if (summary !== undefined) {
            localVarQueryParameters['summary'] = ObjectSerializer.serialize(summary, "Array<string>");
        }

        if (uploadStatus !== undefined) {
            localVarQueryParameters['upload_status'] = ObjectSerializer.serialize(uploadStatus, "Array<'pending' | 'file not found' | 'invalidated' | 'validated'>");
        }

        if (uuid !== undefined) {
            localVarQueryParameters['uuid'] = ObjectSerializer.serialize(uuid, "Array<string>");
        }

        if (validationErrorDetail !== undefined) {
            localVarQueryParameters['validation_error_detail'] = ObjectSerializer.serialize(validationErrorDetail, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: SequenceFileResults;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "SequenceFileResults");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Collection endpoint that accepts various query parameters to filter, sort, and paginate SignalFile items. Supports filtering on fields within SignalFile items.
     * @summary List items in the SignalFile collection.
     * @param frame Constant value. Do not set.
     * @param query Query string for searching.
     * @param limit Maximum number of results to return. Default is 25. Use \&#39;all\&#39; for all results.
     * @param sort Fields to sort results by. Prefix with \&#39;-\&#39; for descending order. Can be repeated for multiple sort fields. Does not work with limit&#x3D;all.
     * @param id Filter by @id
     * @param accession Filter by accession
     * @param aliases Filter by aliases
     * @param alternateAccessions Filter by alternate_accessions
     * @param analysisStepVersion Filter by analysis_step_version
     * @param assembly Filter by assembly
     * @param awardId Filter by award.@id
     * @param awardComponent Filter by award.component
     * @param collections Filter by collections
     * @param contentMd5sum Filter by content_md5sum
     * @param contentSummary Filter by content_summary
     * @param contentType Filter by content_type
     * @param creationTimestamp Filter by creation_timestamp
     * @param dbxrefs Filter by dbxrefs
     * @param derivedFrom Filter by derived_from
     * @param description Filter by description
     * @param documents Filter by documents
     * @param fileFormat Filter by file_format
     * @param fileFormatSpecifications Filter by file_format_specifications
     * @param fileSet Filter by file_set
     * @param fileSize Filter by file_size
     * @param filtered Filter by filtered
     * @param geneListFor Filter by gene_list_for
     * @param href Filter by href
     * @param inputFileFor Filter by input_file_for
     * @param integratedIn Filter by integrated_in
     * @param labId Filter by lab.@id
     * @param labTitle Filter by lab.title
     * @param lociListFor Filter by loci_list_for
     * @param md5sum Filter by md5sum
     * @param normalized Filter by normalized
     * @param notes Filter by notes
     * @param referenceFiles Filter by reference_files
     * @param releaseTimestamp Filter by release_timestamp
     * @param revokeDetail Filter by revoke_detail
     * @param s3Uri Filter by s3_uri
     * @param startViewPosition Filter by start_view_position
     * @param status Filter by status
     * @param strandSpecificity Filter by strand_specificity
     * @param submittedById Filter by submitted_by.@id
     * @param submittedByTitle Filter by submitted_by.title
     * @param submittedFileName Filter by submitted_file_name
     * @param submitterComment Filter by submitter_comment
     * @param summary Filter by summary
     * @param transcriptomeAnnotation Filter by transcriptome_annotation
     * @param uploadStatus Filter by upload_status
     * @param uuid Filter by uuid
     * @param validationErrorDetail Filter by validation_error_detail
     */
    public async signalFiles (frame: 'object', query?: string, limit?: Limit, sort?: Array<string>, id?: Array<string>, accession?: Array<string>, aliases?: Array<string>, alternateAccessions?: Array<string>, analysisStepVersion?: Array<string>, assembly?: Array<'GRCh38' | 'GRCm39'>, awardId?: Array<string>, awardComponent?: Array<'affiliate' | 'data analysis' | 'data coordination' | 'functional characterization' | 'mapping' | 'networks' | 'predictive modeling'>, collections?: Array<'ClinGen' | 'ENCODE' | 'GREGoR' | 'IGVF_catalog_beta_v0.1' | 'IGVF_catalog_beta_v0.2' | 'IGVF_catalog_beta_v0.3' | 'IGVF_catalog_beta_v0.4' | 'MaveDB' | 'MPRAbase' | 'Vista'>, contentMd5sum?: Array<string>, contentSummary?: Array<string>, contentType?: Array<string>, creationTimestamp?: Array<string>, dbxrefs?: Array<string>, derivedFrom?: Array<string>, description?: Array<string>, documents?: Array<string>, fileFormat?: Array<'bigWig'>, fileFormatSpecifications?: Array<string>, fileSet?: Array<string>, fileSize?: Array<number>, filtered?: Array<boolean>, geneListFor?: Array<string>, href?: Array<string>, inputFileFor?: Array<string>, integratedIn?: Array<string>, labId?: Array<string>, labTitle?: Array<string>, lociListFor?: Array<string>, md5sum?: Array<string>, normalized?: Array<boolean>, notes?: Array<string>, referenceFiles?: Array<string>, releaseTimestamp?: Array<string>, revokeDetail?: Array<string>, s3Uri?: Array<string>, startViewPosition?: Array<string>, status?: Array<'in progress' | 'released' | 'deleted' | 'replaced' | 'revoked' | 'archived'>, strandSpecificity?: Array<'plus' | 'minus' | 'unstranded'>, submittedById?: Array<string>, submittedByTitle?: Array<string>, submittedFileName?: Array<string>, submitterComment?: Array<string>, summary?: Array<string>, transcriptomeAnnotation?: Array<'GENCODE 40' | 'GENCODE 41' | 'GENCODE 42' | 'GENCODE 43' | 'GENCODE 44' | 'GENCODE 45' | 'GENCODE M30' | 'GENCODE M31' | 'GENCODE M32' | 'GENCODE M33' | 'GENCODE M34'>, uploadStatus?: Array<'pending' | 'file not found' | 'invalidated' | 'validated'>, uuid?: Array<string>, validationErrorDetail?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: SignalFileResults;  }> {
        const localVarPath = this.basePath + '/signal-files/@@listing';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'frame' is not null or undefined
        if (frame === null || frame === undefined) {
            throw new Error('Required parameter frame was null or undefined when calling signalFiles.');
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (frame !== undefined) {
            localVarQueryParameters['frame'] = ObjectSerializer.serialize(frame, "'object'");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "Limit");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "Array<string>");
        }

        if (id !== undefined) {
            localVarQueryParameters['@id'] = ObjectSerializer.serialize(id, "Array<string>");
        }

        if (accession !== undefined) {
            localVarQueryParameters['accession'] = ObjectSerializer.serialize(accession, "Array<string>");
        }

        if (aliases !== undefined) {
            localVarQueryParameters['aliases'] = ObjectSerializer.serialize(aliases, "Array<string>");
        }

        if (alternateAccessions !== undefined) {
            localVarQueryParameters['alternate_accessions'] = ObjectSerializer.serialize(alternateAccessions, "Array<string>");
        }

        if (analysisStepVersion !== undefined) {
            localVarQueryParameters['analysis_step_version'] = ObjectSerializer.serialize(analysisStepVersion, "Array<string>");
        }

        if (assembly !== undefined) {
            localVarQueryParameters['assembly'] = ObjectSerializer.serialize(assembly, "Array<'GRCh38' | 'GRCm39'>");
        }

        if (awardId !== undefined) {
            localVarQueryParameters['award.@id'] = ObjectSerializer.serialize(awardId, "Array<string>");
        }

        if (awardComponent !== undefined) {
            localVarQueryParameters['award.component'] = ObjectSerializer.serialize(awardComponent, "Array<'affiliate' | 'data analysis' | 'data coordination' | 'functional characterization' | 'mapping' | 'networks' | 'predictive modeling'>");
        }

        if (collections !== undefined) {
            localVarQueryParameters['collections'] = ObjectSerializer.serialize(collections, "Array<'ClinGen' | 'ENCODE' | 'GREGoR' | 'IGVF_catalog_beta_v0.1' | 'IGVF_catalog_beta_v0.2' | 'IGVF_catalog_beta_v0.3' | 'IGVF_catalog_beta_v0.4' | 'MaveDB' | 'MPRAbase' | 'Vista'>");
        }

        if (contentMd5sum !== undefined) {
            localVarQueryParameters['content_md5sum'] = ObjectSerializer.serialize(contentMd5sum, "Array<string>");
        }

        if (contentSummary !== undefined) {
            localVarQueryParameters['content_summary'] = ObjectSerializer.serialize(contentSummary, "Array<string>");
        }

        if (contentType !== undefined) {
            localVarQueryParameters['content_type'] = ObjectSerializer.serialize(contentType, "Array<string>");
        }

        if (creationTimestamp !== undefined) {
            localVarQueryParameters['creation_timestamp'] = ObjectSerializer.serialize(creationTimestamp, "Array<string>");
        }

        if (dbxrefs !== undefined) {
            localVarQueryParameters['dbxrefs'] = ObjectSerializer.serialize(dbxrefs, "Array<string>");
        }

        if (derivedFrom !== undefined) {
            localVarQueryParameters['derived_from'] = ObjectSerializer.serialize(derivedFrom, "Array<string>");
        }

        if (description !== undefined) {
            localVarQueryParameters['description'] = ObjectSerializer.serialize(description, "Array<string>");
        }

        if (documents !== undefined) {
            localVarQueryParameters['documents'] = ObjectSerializer.serialize(documents, "Array<string>");
        }

        if (fileFormat !== undefined) {
            localVarQueryParameters['file_format'] = ObjectSerializer.serialize(fileFormat, "Array<'bigWig'>");
        }

        if (fileFormatSpecifications !== undefined) {
            localVarQueryParameters['file_format_specifications'] = ObjectSerializer.serialize(fileFormatSpecifications, "Array<string>");
        }

        if (fileSet !== undefined) {
            localVarQueryParameters['file_set'] = ObjectSerializer.serialize(fileSet, "Array<string>");
        }

        if (fileSize !== undefined) {
            localVarQueryParameters['file_size'] = ObjectSerializer.serialize(fileSize, "Array<number>");
        }

        if (filtered !== undefined) {
            localVarQueryParameters['filtered'] = ObjectSerializer.serialize(filtered, "Array<boolean>");
        }

        if (geneListFor !== undefined) {
            localVarQueryParameters['gene_list_for'] = ObjectSerializer.serialize(geneListFor, "Array<string>");
        }

        if (href !== undefined) {
            localVarQueryParameters['href'] = ObjectSerializer.serialize(href, "Array<string>");
        }

        if (inputFileFor !== undefined) {
            localVarQueryParameters['input_file_for'] = ObjectSerializer.serialize(inputFileFor, "Array<string>");
        }

        if (integratedIn !== undefined) {
            localVarQueryParameters['integrated_in'] = ObjectSerializer.serialize(integratedIn, "Array<string>");
        }

        if (labId !== undefined) {
            localVarQueryParameters['lab.@id'] = ObjectSerializer.serialize(labId, "Array<string>");
        }

        if (labTitle !== undefined) {
            localVarQueryParameters['lab.title'] = ObjectSerializer.serialize(labTitle, "Array<string>");
        }

        if (lociListFor !== undefined) {
            localVarQueryParameters['loci_list_for'] = ObjectSerializer.serialize(lociListFor, "Array<string>");
        }

        if (md5sum !== undefined) {
            localVarQueryParameters['md5sum'] = ObjectSerializer.serialize(md5sum, "Array<string>");
        }

        if (normalized !== undefined) {
            localVarQueryParameters['normalized'] = ObjectSerializer.serialize(normalized, "Array<boolean>");
        }

        if (notes !== undefined) {
            localVarQueryParameters['notes'] = ObjectSerializer.serialize(notes, "Array<string>");
        }

        if (referenceFiles !== undefined) {
            localVarQueryParameters['reference_files'] = ObjectSerializer.serialize(referenceFiles, "Array<string>");
        }

        if (releaseTimestamp !== undefined) {
            localVarQueryParameters['release_timestamp'] = ObjectSerializer.serialize(releaseTimestamp, "Array<string>");
        }

        if (revokeDetail !== undefined) {
            localVarQueryParameters['revoke_detail'] = ObjectSerializer.serialize(revokeDetail, "Array<string>");
        }

        if (s3Uri !== undefined) {
            localVarQueryParameters['s3_uri'] = ObjectSerializer.serialize(s3Uri, "Array<string>");
        }

        if (startViewPosition !== undefined) {
            localVarQueryParameters['start_view_position'] = ObjectSerializer.serialize(startViewPosition, "Array<string>");
        }

        if (status !== undefined) {
            localVarQueryParameters['status'] = ObjectSerializer.serialize(status, "Array<'in progress' | 'released' | 'deleted' | 'replaced' | 'revoked' | 'archived'>");
        }

        if (strandSpecificity !== undefined) {
            localVarQueryParameters['strand_specificity'] = ObjectSerializer.serialize(strandSpecificity, "Array<'plus' | 'minus' | 'unstranded'>");
        }

        if (submittedById !== undefined) {
            localVarQueryParameters['submitted_by.@id'] = ObjectSerializer.serialize(submittedById, "Array<string>");
        }

        if (submittedByTitle !== undefined) {
            localVarQueryParameters['submitted_by.title'] = ObjectSerializer.serialize(submittedByTitle, "Array<string>");
        }

        if (submittedFileName !== undefined) {
            localVarQueryParameters['submitted_file_name'] = ObjectSerializer.serialize(submittedFileName, "Array<string>");
        }

        if (submitterComment !== undefined) {
            localVarQueryParameters['submitter_comment'] = ObjectSerializer.serialize(submitterComment, "Array<string>");
        }

        if (summary !== undefined) {
            localVarQueryParameters['summary'] = ObjectSerializer.serialize(summary, "Array<string>");
        }

        if (transcriptomeAnnotation !== undefined) {
            localVarQueryParameters['transcriptome_annotation'] = ObjectSerializer.serialize(transcriptomeAnnotation, "Array<'GENCODE 40' | 'GENCODE 41' | 'GENCODE 42' | 'GENCODE 43' | 'GENCODE 44' | 'GENCODE 45' | 'GENCODE M30' | 'GENCODE M31' | 'GENCODE M32' | 'GENCODE M33' | 'GENCODE M34'>");
        }

        if (uploadStatus !== undefined) {
            localVarQueryParameters['upload_status'] = ObjectSerializer.serialize(uploadStatus, "Array<'pending' | 'file not found' | 'invalidated' | 'validated'>");
        }

        if (uuid !== undefined) {
            localVarQueryParameters['uuid'] = ObjectSerializer.serialize(uuid, "Array<string>");
        }

        if (validationErrorDetail !== undefined) {
            localVarQueryParameters['validation_error_detail'] = ObjectSerializer.serialize(validationErrorDetail, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: SignalFileResults;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "SignalFileResults");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Collection endpoint that accepts various query parameters to filter, sort, and paginate Software items. Supports filtering on fields within Software items.
     * @summary List items in the Software collection.
     * @param frame Constant value. Do not set.
     * @param query Query string for searching.
     * @param limit Maximum number of results to return. Default is 25. Use \&#39;all\&#39; for all results.
     * @param sort Fields to sort results by. Prefix with \&#39;-\&#39; for descending order. Can be repeated for multiple sort fields. Does not work with limit&#x3D;all.
     * @param id Filter by @id
     * @param aliases Filter by aliases
     * @param awardId Filter by award.@id
     * @param awardComponent Filter by award.component
     * @param creationTimestamp Filter by creation_timestamp
     * @param description Filter by description
     * @param labId Filter by lab.@id
     * @param labTitle Filter by lab.title
     * @param name Filter by name
     * @param notes Filter by notes
     * @param publicationIdentifiers Filter by publication_identifiers
     * @param publications Filter by publications
     * @param releaseTimestamp Filter by release_timestamp
     * @param sourceUrl Filter by source_url
     * @param status Filter by status
     * @param submittedById Filter by submitted_by.@id
     * @param submittedByTitle Filter by submitted_by.title
     * @param submitterComment Filter by submitter_comment
     * @param summary Filter by summary
     * @param title Filter by title
     * @param usedBy Filter by used_by
     * @param uuid Filter by uuid
     * @param versions Filter by versions
     */
    public async software (frame: 'object', query?: string, limit?: Limit, sort?: Array<string>, id?: Array<string>, aliases?: Array<string>, awardId?: Array<string>, awardComponent?: Array<'affiliate' | 'data analysis' | 'data coordination' | 'functional characterization' | 'mapping' | 'networks' | 'predictive modeling'>, creationTimestamp?: Array<string>, description?: Array<string>, labId?: Array<string>, labTitle?: Array<string>, name?: Array<string>, notes?: Array<string>, publicationIdentifiers?: Array<string>, publications?: Array<string>, releaseTimestamp?: Array<string>, sourceUrl?: Array<string>, status?: Array<'archived' | 'deleted' | 'in progress' | 'released'>, submittedById?: Array<string>, submittedByTitle?: Array<string>, submitterComment?: Array<string>, summary?: Array<string>, title?: Array<string>, usedBy?: Array<'consortium analysis' | 'DACC' | 'processing pipelines'>, uuid?: Array<string>, versions?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: SoftwareResults;  }> {
        const localVarPath = this.basePath + '/software/@@listing';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'frame' is not null or undefined
        if (frame === null || frame === undefined) {
            throw new Error('Required parameter frame was null or undefined when calling software.');
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (frame !== undefined) {
            localVarQueryParameters['frame'] = ObjectSerializer.serialize(frame, "'object'");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "Limit");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "Array<string>");
        }

        if (id !== undefined) {
            localVarQueryParameters['@id'] = ObjectSerializer.serialize(id, "Array<string>");
        }

        if (aliases !== undefined) {
            localVarQueryParameters['aliases'] = ObjectSerializer.serialize(aliases, "Array<string>");
        }

        if (awardId !== undefined) {
            localVarQueryParameters['award.@id'] = ObjectSerializer.serialize(awardId, "Array<string>");
        }

        if (awardComponent !== undefined) {
            localVarQueryParameters['award.component'] = ObjectSerializer.serialize(awardComponent, "Array<'affiliate' | 'data analysis' | 'data coordination' | 'functional characterization' | 'mapping' | 'networks' | 'predictive modeling'>");
        }

        if (creationTimestamp !== undefined) {
            localVarQueryParameters['creation_timestamp'] = ObjectSerializer.serialize(creationTimestamp, "Array<string>");
        }

        if (description !== undefined) {
            localVarQueryParameters['description'] = ObjectSerializer.serialize(description, "Array<string>");
        }

        if (labId !== undefined) {
            localVarQueryParameters['lab.@id'] = ObjectSerializer.serialize(labId, "Array<string>");
        }

        if (labTitle !== undefined) {
            localVarQueryParameters['lab.title'] = ObjectSerializer.serialize(labTitle, "Array<string>");
        }

        if (name !== undefined) {
            localVarQueryParameters['name'] = ObjectSerializer.serialize(name, "Array<string>");
        }

        if (notes !== undefined) {
            localVarQueryParameters['notes'] = ObjectSerializer.serialize(notes, "Array<string>");
        }

        if (publicationIdentifiers !== undefined) {
            localVarQueryParameters['publication_identifiers'] = ObjectSerializer.serialize(publicationIdentifiers, "Array<string>");
        }

        if (publications !== undefined) {
            localVarQueryParameters['publications'] = ObjectSerializer.serialize(publications, "Array<string>");
        }

        if (releaseTimestamp !== undefined) {
            localVarQueryParameters['release_timestamp'] = ObjectSerializer.serialize(releaseTimestamp, "Array<string>");
        }

        if (sourceUrl !== undefined) {
            localVarQueryParameters['source_url'] = ObjectSerializer.serialize(sourceUrl, "Array<string>");
        }

        if (status !== undefined) {
            localVarQueryParameters['status'] = ObjectSerializer.serialize(status, "Array<'archived' | 'deleted' | 'in progress' | 'released'>");
        }

        if (submittedById !== undefined) {
            localVarQueryParameters['submitted_by.@id'] = ObjectSerializer.serialize(submittedById, "Array<string>");
        }

        if (submittedByTitle !== undefined) {
            localVarQueryParameters['submitted_by.title'] = ObjectSerializer.serialize(submittedByTitle, "Array<string>");
        }

        if (submitterComment !== undefined) {
            localVarQueryParameters['submitter_comment'] = ObjectSerializer.serialize(submitterComment, "Array<string>");
        }

        if (summary !== undefined) {
            localVarQueryParameters['summary'] = ObjectSerializer.serialize(summary, "Array<string>");
        }

        if (title !== undefined) {
            localVarQueryParameters['title'] = ObjectSerializer.serialize(title, "Array<string>");
        }

        if (usedBy !== undefined) {
            localVarQueryParameters['used_by'] = ObjectSerializer.serialize(usedBy, "Array<'consortium analysis' | 'DACC' | 'processing pipelines'>");
        }

        if (uuid !== undefined) {
            localVarQueryParameters['uuid'] = ObjectSerializer.serialize(uuid, "Array<string>");
        }

        if (versions !== undefined) {
            localVarQueryParameters['versions'] = ObjectSerializer.serialize(versions, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: SoftwareResults;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "SoftwareResults");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Collection endpoint that accepts various query parameters to filter, sort, and paginate SoftwareVersion items. Supports filtering on fields within SoftwareVersion items.
     * @summary List items in the SoftwareVersion collection.
     * @param frame Constant value. Do not set.
     * @param query Query string for searching.
     * @param limit Maximum number of results to return. Default is 25. Use \&#39;all\&#39; for all results.
     * @param sort Fields to sort results by. Prefix with \&#39;-\&#39; for descending order. Can be repeated for multiple sort fields. Does not work with limit&#x3D;all.
     * @param id Filter by @id
     * @param aliases Filter by aliases
     * @param awardId Filter by award.@id
     * @param awardComponent Filter by award.component
     * @param creationTimestamp Filter by creation_timestamp
     * @param description Filter by description
     * @param downloadId Filter by download_id
     * @param downloadedUrl Filter by downloaded_url
     * @param labId Filter by lab.@id
     * @param labTitle Filter by lab.title
     * @param name Filter by name
     * @param notes Filter by notes
     * @param publicationIdentifiers Filter by publication_identifiers
     * @param publications Filter by publications
     * @param releaseTimestamp Filter by release_timestamp
     * @param softwareId Filter by software.@id
     * @param softwareTitle Filter by software.title
     * @param status Filter by status
     * @param submittedById Filter by submitted_by.@id
     * @param submittedByTitle Filter by submitted_by.title
     * @param submitterComment Filter by submitter_comment
     * @param summary Filter by summary
     * @param uuid Filter by uuid
     * @param version Filter by version
     */
    public async softwareVersions (frame: 'object', query?: string, limit?: Limit, sort?: Array<string>, id?: Array<string>, aliases?: Array<string>, awardId?: Array<string>, awardComponent?: Array<'affiliate' | 'data analysis' | 'data coordination' | 'functional characterization' | 'mapping' | 'networks' | 'predictive modeling'>, creationTimestamp?: Array<string>, description?: Array<string>, downloadId?: Array<string>, downloadedUrl?: Array<string>, labId?: Array<string>, labTitle?: Array<string>, name?: Array<string>, notes?: Array<string>, publicationIdentifiers?: Array<string>, publications?: Array<string>, releaseTimestamp?: Array<string>, softwareId?: Array<string>, softwareTitle?: Array<string>, status?: Array<'archived' | 'deleted' | 'in progress' | 'released'>, submittedById?: Array<string>, submittedByTitle?: Array<string>, submitterComment?: Array<string>, summary?: Array<string>, uuid?: Array<string>, version?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: SoftwareVersionResults;  }> {
        const localVarPath = this.basePath + '/software-versions/@@listing';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'frame' is not null or undefined
        if (frame === null || frame === undefined) {
            throw new Error('Required parameter frame was null or undefined when calling softwareVersions.');
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (frame !== undefined) {
            localVarQueryParameters['frame'] = ObjectSerializer.serialize(frame, "'object'");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "Limit");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "Array<string>");
        }

        if (id !== undefined) {
            localVarQueryParameters['@id'] = ObjectSerializer.serialize(id, "Array<string>");
        }

        if (aliases !== undefined) {
            localVarQueryParameters['aliases'] = ObjectSerializer.serialize(aliases, "Array<string>");
        }

        if (awardId !== undefined) {
            localVarQueryParameters['award.@id'] = ObjectSerializer.serialize(awardId, "Array<string>");
        }

        if (awardComponent !== undefined) {
            localVarQueryParameters['award.component'] = ObjectSerializer.serialize(awardComponent, "Array<'affiliate' | 'data analysis' | 'data coordination' | 'functional characterization' | 'mapping' | 'networks' | 'predictive modeling'>");
        }

        if (creationTimestamp !== undefined) {
            localVarQueryParameters['creation_timestamp'] = ObjectSerializer.serialize(creationTimestamp, "Array<string>");
        }

        if (description !== undefined) {
            localVarQueryParameters['description'] = ObjectSerializer.serialize(description, "Array<string>");
        }

        if (downloadId !== undefined) {
            localVarQueryParameters['download_id'] = ObjectSerializer.serialize(downloadId, "Array<string>");
        }

        if (downloadedUrl !== undefined) {
            localVarQueryParameters['downloaded_url'] = ObjectSerializer.serialize(downloadedUrl, "Array<string>");
        }

        if (labId !== undefined) {
            localVarQueryParameters['lab.@id'] = ObjectSerializer.serialize(labId, "Array<string>");
        }

        if (labTitle !== undefined) {
            localVarQueryParameters['lab.title'] = ObjectSerializer.serialize(labTitle, "Array<string>");
        }

        if (name !== undefined) {
            localVarQueryParameters['name'] = ObjectSerializer.serialize(name, "Array<string>");
        }

        if (notes !== undefined) {
            localVarQueryParameters['notes'] = ObjectSerializer.serialize(notes, "Array<string>");
        }

        if (publicationIdentifiers !== undefined) {
            localVarQueryParameters['publication_identifiers'] = ObjectSerializer.serialize(publicationIdentifiers, "Array<string>");
        }

        if (publications !== undefined) {
            localVarQueryParameters['publications'] = ObjectSerializer.serialize(publications, "Array<string>");
        }

        if (releaseTimestamp !== undefined) {
            localVarQueryParameters['release_timestamp'] = ObjectSerializer.serialize(releaseTimestamp, "Array<string>");
        }

        if (softwareId !== undefined) {
            localVarQueryParameters['software.@id'] = ObjectSerializer.serialize(softwareId, "Array<string>");
        }

        if (softwareTitle !== undefined) {
            localVarQueryParameters['software.title'] = ObjectSerializer.serialize(softwareTitle, "Array<string>");
        }

        if (status !== undefined) {
            localVarQueryParameters['status'] = ObjectSerializer.serialize(status, "Array<'archived' | 'deleted' | 'in progress' | 'released'>");
        }

        if (submittedById !== undefined) {
            localVarQueryParameters['submitted_by.@id'] = ObjectSerializer.serialize(submittedById, "Array<string>");
        }

        if (submittedByTitle !== undefined) {
            localVarQueryParameters['submitted_by.title'] = ObjectSerializer.serialize(submittedByTitle, "Array<string>");
        }

        if (submitterComment !== undefined) {
            localVarQueryParameters['submitter_comment'] = ObjectSerializer.serialize(submitterComment, "Array<string>");
        }

        if (summary !== undefined) {
            localVarQueryParameters['summary'] = ObjectSerializer.serialize(summary, "Array<string>");
        }

        if (uuid !== undefined) {
            localVarQueryParameters['uuid'] = ObjectSerializer.serialize(uuid, "Array<string>");
        }

        if (version !== undefined) {
            localVarQueryParameters['version'] = ObjectSerializer.serialize(version, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: SoftwareVersionResults;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "SoftwareVersionResults");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Collection endpoint that accepts various query parameters to filter, sort, and paginate Source items. Supports filtering on fields within Source items.
     * @summary List items in the Source collection.
     * @param frame Constant value. Do not set.
     * @param query Query string for searching.
     * @param limit Maximum number of results to return. Default is 25. Use \&#39;all\&#39; for all results.
     * @param sort Fields to sort results by. Prefix with \&#39;-\&#39; for descending order. Can be repeated for multiple sort fields. Does not work with limit&#x3D;all.
     * @param id Filter by @id
     * @param aliases Filter by aliases
     * @param creationTimestamp Filter by creation_timestamp
     * @param description Filter by description
     * @param name Filter by name
     * @param notes Filter by notes
     * @param releaseTimestamp Filter by release_timestamp
     * @param status Filter by status
     * @param submittedById Filter by submitted_by.@id
     * @param submittedByTitle Filter by submitted_by.title
     * @param submitterComment Filter by submitter_comment
     * @param summary Filter by summary
     * @param title Filter by title
     * @param url Filter by url
     * @param uuid Filter by uuid
     */
    public async sources (frame: 'object', query?: string, limit?: Limit, sort?: Array<string>, id?: Array<string>, aliases?: Array<string>, creationTimestamp?: Array<string>, description?: Array<string>, name?: Array<string>, notes?: Array<string>, releaseTimestamp?: Array<string>, status?: Array<'archived' | 'deleted' | 'in progress' | 'released'>, submittedById?: Array<string>, submittedByTitle?: Array<string>, submitterComment?: Array<string>, summary?: Array<string>, title?: Array<string>, url?: Array<string>, uuid?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: SourceResults;  }> {
        const localVarPath = this.basePath + '/sources/@@listing';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'frame' is not null or undefined
        if (frame === null || frame === undefined) {
            throw new Error('Required parameter frame was null or undefined when calling sources.');
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (frame !== undefined) {
            localVarQueryParameters['frame'] = ObjectSerializer.serialize(frame, "'object'");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "Limit");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "Array<string>");
        }

        if (id !== undefined) {
            localVarQueryParameters['@id'] = ObjectSerializer.serialize(id, "Array<string>");
        }

        if (aliases !== undefined) {
            localVarQueryParameters['aliases'] = ObjectSerializer.serialize(aliases, "Array<string>");
        }

        if (creationTimestamp !== undefined) {
            localVarQueryParameters['creation_timestamp'] = ObjectSerializer.serialize(creationTimestamp, "Array<string>");
        }

        if (description !== undefined) {
            localVarQueryParameters['description'] = ObjectSerializer.serialize(description, "Array<string>");
        }

        if (name !== undefined) {
            localVarQueryParameters['name'] = ObjectSerializer.serialize(name, "Array<string>");
        }

        if (notes !== undefined) {
            localVarQueryParameters['notes'] = ObjectSerializer.serialize(notes, "Array<string>");
        }

        if (releaseTimestamp !== undefined) {
            localVarQueryParameters['release_timestamp'] = ObjectSerializer.serialize(releaseTimestamp, "Array<string>");
        }

        if (status !== undefined) {
            localVarQueryParameters['status'] = ObjectSerializer.serialize(status, "Array<'archived' | 'deleted' | 'in progress' | 'released'>");
        }

        if (submittedById !== undefined) {
            localVarQueryParameters['submitted_by.@id'] = ObjectSerializer.serialize(submittedById, "Array<string>");
        }

        if (submittedByTitle !== undefined) {
            localVarQueryParameters['submitted_by.title'] = ObjectSerializer.serialize(submittedByTitle, "Array<string>");
        }

        if (submitterComment !== undefined) {
            localVarQueryParameters['submitter_comment'] = ObjectSerializer.serialize(submitterComment, "Array<string>");
        }

        if (summary !== undefined) {
            localVarQueryParameters['summary'] = ObjectSerializer.serialize(summary, "Array<string>");
        }

        if (title !== undefined) {
            localVarQueryParameters['title'] = ObjectSerializer.serialize(title, "Array<string>");
        }

        if (url !== undefined) {
            localVarQueryParameters['url'] = ObjectSerializer.serialize(url, "Array<string>");
        }

        if (uuid !== undefined) {
            localVarQueryParameters['uuid'] = ObjectSerializer.serialize(uuid, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: SourceResults;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "SourceResults");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Collection endpoint that accepts various query parameters to filter, sort, and paginate TabularFile items. Supports filtering on fields within TabularFile items.
     * @summary List items in the TabularFile collection.
     * @param frame Constant value. Do not set.
     * @param query Query string for searching.
     * @param limit Maximum number of results to return. Default is 25. Use \&#39;all\&#39; for all results.
     * @param sort Fields to sort results by. Prefix with \&#39;-\&#39; for descending order. Can be repeated for multiple sort fields. Does not work with limit&#x3D;all.
     * @param id Filter by @id
     * @param accession Filter by accession
     * @param aliases Filter by aliases
     * @param alternateAccessions Filter by alternate_accessions
     * @param analysisStepVersion Filter by analysis_step_version
     * @param anvilUrl Filter by anvil_url
     * @param assembly Filter by assembly
     * @param awardId Filter by award.@id
     * @param awardComponent Filter by award.component
     * @param collections Filter by collections
     * @param contentMd5sum Filter by content_md5sum
     * @param contentType Filter by content_type
     * @param controlledAccess Filter by controlled_access
     * @param creationTimestamp Filter by creation_timestamp
     * @param dbxrefs Filter by dbxrefs
     * @param derivedFrom Filter by derived_from
     * @param description Filter by description
     * @param documents Filter by documents
     * @param fileFormat Filter by file_format
     * @param fileFormatSpecifications Filter by file_format_specifications
     * @param fileFormatType Filter by file_format_type
     * @param fileSet Filter by file_set
     * @param fileSize Filter by file_size
     * @param geneListFor Filter by gene_list_for
     * @param href Filter by href
     * @param inputFileFor Filter by input_file_for
     * @param integratedIn Filter by integrated_in
     * @param labId Filter by lab.@id
     * @param labTitle Filter by lab.title
     * @param lociListFor Filter by loci_list_for
     * @param md5sum Filter by md5sum
     * @param notes Filter by notes
     * @param releaseTimestamp Filter by release_timestamp
     * @param revokeDetail Filter by revoke_detail
     * @param s3Uri Filter by s3_uri
     * @param status Filter by status
     * @param submittedById Filter by submitted_by.@id
     * @param submittedByTitle Filter by submitted_by.title
     * @param submittedFileName Filter by submitted_file_name
     * @param submitterComment Filter by submitter_comment
     * @param summary Filter by summary
     * @param transcriptomeAnnotation Filter by transcriptome_annotation
     * @param uploadStatus Filter by upload_status
     * @param uuid Filter by uuid
     * @param validationErrorDetail Filter by validation_error_detail
     */
    public async tabularFiles (frame: 'object', query?: string, limit?: Limit, sort?: Array<string>, id?: Array<string>, accession?: Array<string>, aliases?: Array<string>, alternateAccessions?: Array<string>, analysisStepVersion?: Array<string>, anvilUrl?: Array<string>, assembly?: Array<'GRCh38' | 'GRCm39'>, awardId?: Array<string>, awardComponent?: Array<'affiliate' | 'data analysis' | 'data coordination' | 'functional characterization' | 'mapping' | 'networks' | 'predictive modeling'>, collections?: Array<'ClinGen' | 'ENCODE' | 'GREGoR' | 'IGVF_catalog_beta_v0.1' | 'IGVF_catalog_beta_v0.2' | 'IGVF_catalog_beta_v0.3' | 'IGVF_catalog_beta_v0.4' | 'MaveDB' | 'MPRAbase' | 'Vista'>, contentMd5sum?: Array<string>, contentType?: Array<string>, controlledAccess?: Array<boolean>, creationTimestamp?: Array<string>, dbxrefs?: Array<string>, derivedFrom?: Array<string>, description?: Array<string>, documents?: Array<string>, fileFormat?: Array<'bed' | 'csv' | 'gtf' | 'tsv' | 'txt' | 'vcf'>, fileFormatSpecifications?: Array<string>, fileFormatType?: Array<'bed12' | 'bed3' | 'bed3+' | 'bed5' | 'bed6' | 'bed6+' | 'bed9' | 'bed9+' | 'mpra_starr'>, fileSet?: Array<string>, fileSize?: Array<number>, geneListFor?: Array<string>, href?: Array<string>, inputFileFor?: Array<string>, integratedIn?: Array<string>, labId?: Array<string>, labTitle?: Array<string>, lociListFor?: Array<string>, md5sum?: Array<string>, notes?: Array<string>, releaseTimestamp?: Array<string>, revokeDetail?: Array<string>, s3Uri?: Array<string>, status?: Array<'in progress' | 'released' | 'deleted' | 'replaced' | 'revoked' | 'archived'>, submittedById?: Array<string>, submittedByTitle?: Array<string>, submittedFileName?: Array<string>, submitterComment?: Array<string>, summary?: Array<string>, transcriptomeAnnotation?: Array<'GENCODE 40' | 'GENCODE 41' | 'GENCODE 42' | 'GENCODE 43' | 'GENCODE 44' | 'GENCODE 45' | 'GENCODE M30' | 'GENCODE M31' | 'GENCODE M32' | 'GENCODE M33' | 'GENCODE M34'>, uploadStatus?: Array<'pending' | 'file not found' | 'invalidated' | 'validated'>, uuid?: Array<string>, validationErrorDetail?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: TabularFileResults;  }> {
        const localVarPath = this.basePath + '/tabular-files/@@listing';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'frame' is not null or undefined
        if (frame === null || frame === undefined) {
            throw new Error('Required parameter frame was null or undefined when calling tabularFiles.');
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (frame !== undefined) {
            localVarQueryParameters['frame'] = ObjectSerializer.serialize(frame, "'object'");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "Limit");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "Array<string>");
        }

        if (id !== undefined) {
            localVarQueryParameters['@id'] = ObjectSerializer.serialize(id, "Array<string>");
        }

        if (accession !== undefined) {
            localVarQueryParameters['accession'] = ObjectSerializer.serialize(accession, "Array<string>");
        }

        if (aliases !== undefined) {
            localVarQueryParameters['aliases'] = ObjectSerializer.serialize(aliases, "Array<string>");
        }

        if (alternateAccessions !== undefined) {
            localVarQueryParameters['alternate_accessions'] = ObjectSerializer.serialize(alternateAccessions, "Array<string>");
        }

        if (analysisStepVersion !== undefined) {
            localVarQueryParameters['analysis_step_version'] = ObjectSerializer.serialize(analysisStepVersion, "Array<string>");
        }

        if (anvilUrl !== undefined) {
            localVarQueryParameters['anvil_url'] = ObjectSerializer.serialize(anvilUrl, "Array<string>");
        }

        if (assembly !== undefined) {
            localVarQueryParameters['assembly'] = ObjectSerializer.serialize(assembly, "Array<'GRCh38' | 'GRCm39'>");
        }

        if (awardId !== undefined) {
            localVarQueryParameters['award.@id'] = ObjectSerializer.serialize(awardId, "Array<string>");
        }

        if (awardComponent !== undefined) {
            localVarQueryParameters['award.component'] = ObjectSerializer.serialize(awardComponent, "Array<'affiliate' | 'data analysis' | 'data coordination' | 'functional characterization' | 'mapping' | 'networks' | 'predictive modeling'>");
        }

        if (collections !== undefined) {
            localVarQueryParameters['collections'] = ObjectSerializer.serialize(collections, "Array<'ClinGen' | 'ENCODE' | 'GREGoR' | 'IGVF_catalog_beta_v0.1' | 'IGVF_catalog_beta_v0.2' | 'IGVF_catalog_beta_v0.3' | 'IGVF_catalog_beta_v0.4' | 'MaveDB' | 'MPRAbase' | 'Vista'>");
        }

        if (contentMd5sum !== undefined) {
            localVarQueryParameters['content_md5sum'] = ObjectSerializer.serialize(contentMd5sum, "Array<string>");
        }

        if (contentType !== undefined) {
            localVarQueryParameters['content_type'] = ObjectSerializer.serialize(contentType, "Array<string>");
        }

        if (controlledAccess !== undefined) {
            localVarQueryParameters['controlled_access'] = ObjectSerializer.serialize(controlledAccess, "Array<boolean>");
        }

        if (creationTimestamp !== undefined) {
            localVarQueryParameters['creation_timestamp'] = ObjectSerializer.serialize(creationTimestamp, "Array<string>");
        }

        if (dbxrefs !== undefined) {
            localVarQueryParameters['dbxrefs'] = ObjectSerializer.serialize(dbxrefs, "Array<string>");
        }

        if (derivedFrom !== undefined) {
            localVarQueryParameters['derived_from'] = ObjectSerializer.serialize(derivedFrom, "Array<string>");
        }

        if (description !== undefined) {
            localVarQueryParameters['description'] = ObjectSerializer.serialize(description, "Array<string>");
        }

        if (documents !== undefined) {
            localVarQueryParameters['documents'] = ObjectSerializer.serialize(documents, "Array<string>");
        }

        if (fileFormat !== undefined) {
            localVarQueryParameters['file_format'] = ObjectSerializer.serialize(fileFormat, "Array<'bed' | 'csv' | 'gtf' | 'tsv' | 'txt' | 'vcf'>");
        }

        if (fileFormatSpecifications !== undefined) {
            localVarQueryParameters['file_format_specifications'] = ObjectSerializer.serialize(fileFormatSpecifications, "Array<string>");
        }

        if (fileFormatType !== undefined) {
            localVarQueryParameters['file_format_type'] = ObjectSerializer.serialize(fileFormatType, "Array<'bed12' | 'bed3' | 'bed3+' | 'bed5' | 'bed6' | 'bed6+' | 'bed9' | 'bed9+' | 'mpra_starr'>");
        }

        if (fileSet !== undefined) {
            localVarQueryParameters['file_set'] = ObjectSerializer.serialize(fileSet, "Array<string>");
        }

        if (fileSize !== undefined) {
            localVarQueryParameters['file_size'] = ObjectSerializer.serialize(fileSize, "Array<number>");
        }

        if (geneListFor !== undefined) {
            localVarQueryParameters['gene_list_for'] = ObjectSerializer.serialize(geneListFor, "Array<string>");
        }

        if (href !== undefined) {
            localVarQueryParameters['href'] = ObjectSerializer.serialize(href, "Array<string>");
        }

        if (inputFileFor !== undefined) {
            localVarQueryParameters['input_file_for'] = ObjectSerializer.serialize(inputFileFor, "Array<string>");
        }

        if (integratedIn !== undefined) {
            localVarQueryParameters['integrated_in'] = ObjectSerializer.serialize(integratedIn, "Array<string>");
        }

        if (labId !== undefined) {
            localVarQueryParameters['lab.@id'] = ObjectSerializer.serialize(labId, "Array<string>");
        }

        if (labTitle !== undefined) {
            localVarQueryParameters['lab.title'] = ObjectSerializer.serialize(labTitle, "Array<string>");
        }

        if (lociListFor !== undefined) {
            localVarQueryParameters['loci_list_for'] = ObjectSerializer.serialize(lociListFor, "Array<string>");
        }

        if (md5sum !== undefined) {
            localVarQueryParameters['md5sum'] = ObjectSerializer.serialize(md5sum, "Array<string>");
        }

        if (notes !== undefined) {
            localVarQueryParameters['notes'] = ObjectSerializer.serialize(notes, "Array<string>");
        }

        if (releaseTimestamp !== undefined) {
            localVarQueryParameters['release_timestamp'] = ObjectSerializer.serialize(releaseTimestamp, "Array<string>");
        }

        if (revokeDetail !== undefined) {
            localVarQueryParameters['revoke_detail'] = ObjectSerializer.serialize(revokeDetail, "Array<string>");
        }

        if (s3Uri !== undefined) {
            localVarQueryParameters['s3_uri'] = ObjectSerializer.serialize(s3Uri, "Array<string>");
        }

        if (status !== undefined) {
            localVarQueryParameters['status'] = ObjectSerializer.serialize(status, "Array<'in progress' | 'released' | 'deleted' | 'replaced' | 'revoked' | 'archived'>");
        }

        if (submittedById !== undefined) {
            localVarQueryParameters['submitted_by.@id'] = ObjectSerializer.serialize(submittedById, "Array<string>");
        }

        if (submittedByTitle !== undefined) {
            localVarQueryParameters['submitted_by.title'] = ObjectSerializer.serialize(submittedByTitle, "Array<string>");
        }

        if (submittedFileName !== undefined) {
            localVarQueryParameters['submitted_file_name'] = ObjectSerializer.serialize(submittedFileName, "Array<string>");
        }

        if (submitterComment !== undefined) {
            localVarQueryParameters['submitter_comment'] = ObjectSerializer.serialize(submitterComment, "Array<string>");
        }

        if (summary !== undefined) {
            localVarQueryParameters['summary'] = ObjectSerializer.serialize(summary, "Array<string>");
        }

        if (transcriptomeAnnotation !== undefined) {
            localVarQueryParameters['transcriptome_annotation'] = ObjectSerializer.serialize(transcriptomeAnnotation, "Array<'GENCODE 40' | 'GENCODE 41' | 'GENCODE 42' | 'GENCODE 43' | 'GENCODE 44' | 'GENCODE 45' | 'GENCODE M30' | 'GENCODE M31' | 'GENCODE M32' | 'GENCODE M33' | 'GENCODE M34'>");
        }

        if (uploadStatus !== undefined) {
            localVarQueryParameters['upload_status'] = ObjectSerializer.serialize(uploadStatus, "Array<'pending' | 'file not found' | 'invalidated' | 'validated'>");
        }

        if (uuid !== undefined) {
            localVarQueryParameters['uuid'] = ObjectSerializer.serialize(uuid, "Array<string>");
        }

        if (validationErrorDetail !== undefined) {
            localVarQueryParameters['validation_error_detail'] = ObjectSerializer.serialize(validationErrorDetail, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: TabularFileResults;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "TabularFileResults");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Collection endpoint that accepts various query parameters to filter, sort, and paginate TechnicalSample items. Supports filtering on fields within TechnicalSample items.
     * @summary List items in the TechnicalSample collection.
     * @param frame Constant value. Do not set.
     * @param query Query string for searching.
     * @param limit Maximum number of results to return. Default is 25. Use \&#39;all\&#39; for all results.
     * @param sort Fields to sort results by. Prefix with \&#39;-\&#39; for descending order. Can be repeated for multiple sort fields. Does not work with limit&#x3D;all.
     * @param id Filter by @id
     * @param accession Filter by accession
     * @param aliases Filter by aliases
     * @param alternateAccessions Filter by alternate_accessions
     * @param awardId Filter by award.@id
     * @param awardComponent Filter by award.component
     * @param classifications Filter by classifications
     * @param collections Filter by collections
     * @param constructLibrarySets Filter by construct_library_sets
     * @param creationTimestamp Filter by creation_timestamp
     * @param dateObtained Filter by date_obtained
     * @param dbxrefs Filter by dbxrefs
     * @param description Filter by description
     * @param documents Filter by documents
     * @param fileSetsId Filter by file_sets.@id
     * @param fileSetsAccession Filter by file_sets.accession
     * @param fileSetsAliases Filter by file_sets.aliases
     * @param fileSetsAssayTermTermName Filter by file_sets.assay_term.term_name
     * @param fileSetsLabTitle Filter by file_sets.lab.title
     * @param fileSetsStatus Filter by file_sets.status
     * @param fileSetsSummary Filter by file_sets.summary
     * @param institutionalCertificates Filter by institutional_certificates
     * @param labId Filter by lab.@id
     * @param labTitle Filter by lab.title
     * @param lotId Filter by lot_id
     * @param moi Filter by moi
     * @param multiplexedInId Filter by multiplexed_in.@id
     * @param multiplexedInAccession Filter by multiplexed_in.accession
     * @param notes Filter by notes
     * @param nucleicAcidDelivery Filter by nucleic_acid_delivery
     * @param originOf Filter by origin_of
     * @param productId Filter by product_id
     * @param protocols Filter by protocols
     * @param publicationIdentifiers Filter by publication_identifiers
     * @param publications Filter by publications
     * @param releaseTimestamp Filter by release_timestamp
     * @param revokeDetail Filter by revoke_detail
     * @param sampleMaterial Filter by sample_material
     * @param sampleTermsId Filter by sample_terms.@id
     * @param sampleTermsTermName Filter by sample_terms.term_name
     * @param sortedFractions Filter by sorted_fractions
     * @param sortedFromId Filter by sorted_from.@id
     * @param sortedFromAccession Filter by sorted_from.accession
     * @param sortedFromDetail Filter by sorted_from_detail
     * @param sourcesId Filter by sources.@id
     * @param startingAmount Filter by starting_amount
     * @param startingAmountUnits Filter by starting_amount_units
     * @param status Filter by status
     * @param submittedById Filter by submitted_by.@id
     * @param submittedByTitle Filter by submitted_by.title
     * @param submitterComment Filter by submitter_comment
     * @param summary Filter by summary
     * @param taxa Filter by taxa
     * @param timePostLibraryDelivery Filter by time_post_library_delivery
     * @param timePostLibraryDeliveryUnits Filter by time_post_library_delivery_units
     * @param url Filter by url
     * @param uuid Filter by uuid
     * @param virtual Filter by virtual
     */
    public async technicalSamples (frame: 'object', query?: string, limit?: Limit, sort?: Array<string>, id?: Array<string>, accession?: Array<string>, aliases?: Array<string>, alternateAccessions?: Array<string>, awardId?: Array<string>, awardComponent?: Array<'affiliate' | 'data analysis' | 'data coordination' | 'functional characterization' | 'mapping' | 'networks' | 'predictive modeling'>, classifications?: Array<string>, collections?: Array<'ClinGen' | 'ENCODE' | 'GREGoR' | 'IGVF_catalog_beta_v0.1' | 'IGVF_catalog_beta_v0.2' | 'IGVF_catalog_beta_v0.3' | 'IGVF_catalog_beta_v0.4' | 'MaveDB' | 'MPRAbase' | 'Vista'>, constructLibrarySets?: Array<string>, creationTimestamp?: Array<string>, dateObtained?: Array<string>, dbxrefs?: Array<string>, description?: Array<string>, documents?: Array<string>, fileSetsId?: Array<string>, fileSetsAccession?: Array<string>, fileSetsAliases?: Array<string>, fileSetsAssayTermTermName?: Array<string>, fileSetsLabTitle?: Array<string>, fileSetsStatus?: Array<'in progress' | 'released' | 'deleted' | 'replaced' | 'revoked' | 'archived'>, fileSetsSummary?: Array<string>, institutionalCertificates?: Array<string>, labId?: Array<string>, labTitle?: Array<string>, lotId?: Array<string>, moi?: Array<number>, multiplexedInId?: Array<string>, multiplexedInAccession?: Array<string>, notes?: Array<string>, nucleicAcidDelivery?: Array<'transfection' | 'adenoviral transduction' | 'lentiviral transduction'>, originOf?: Array<string>, productId?: Array<string>, protocols?: Array<string>, publicationIdentifiers?: Array<string>, publications?: Array<string>, releaseTimestamp?: Array<string>, revokeDetail?: Array<string>, sampleMaterial?: Array<'undefined' | 'inorganic' | 'synthetic' | 'organic'>, sampleTermsId?: Array<string>, sampleTermsTermName?: Array<string>, sortedFractions?: Array<string>, sortedFromId?: Array<string>, sortedFromAccession?: Array<string>, sortedFromDetail?: Array<string>, sourcesId?: Array<string>, startingAmount?: Array<number>, startingAmountUnits?: Array<'cells' | 'cells/ml' | 'g' | 'items' | 'mg' | 'whole animals' | 'whole embryos' | 'μg' | 'ng'>, status?: Array<'in progress' | 'released' | 'deleted' | 'replaced' | 'revoked' | 'archived'>, submittedById?: Array<string>, submittedByTitle?: Array<string>, submitterComment?: Array<string>, summary?: Array<string>, taxa?: Array<'Saccharomyces cerevisiae' | 'Homo sapiens'>, timePostLibraryDelivery?: Array<number>, timePostLibraryDeliveryUnits?: Array<'minute' | 'hour' | 'day' | 'week' | 'month'>, url?: Array<string>, uuid?: Array<string>, virtual?: Array<boolean>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: TechnicalSampleResults;  }> {
        const localVarPath = this.basePath + '/technical-samples/@@listing';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'frame' is not null or undefined
        if (frame === null || frame === undefined) {
            throw new Error('Required parameter frame was null or undefined when calling technicalSamples.');
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (frame !== undefined) {
            localVarQueryParameters['frame'] = ObjectSerializer.serialize(frame, "'object'");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "Limit");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "Array<string>");
        }

        if (id !== undefined) {
            localVarQueryParameters['@id'] = ObjectSerializer.serialize(id, "Array<string>");
        }

        if (accession !== undefined) {
            localVarQueryParameters['accession'] = ObjectSerializer.serialize(accession, "Array<string>");
        }

        if (aliases !== undefined) {
            localVarQueryParameters['aliases'] = ObjectSerializer.serialize(aliases, "Array<string>");
        }

        if (alternateAccessions !== undefined) {
            localVarQueryParameters['alternate_accessions'] = ObjectSerializer.serialize(alternateAccessions, "Array<string>");
        }

        if (awardId !== undefined) {
            localVarQueryParameters['award.@id'] = ObjectSerializer.serialize(awardId, "Array<string>");
        }

        if (awardComponent !== undefined) {
            localVarQueryParameters['award.component'] = ObjectSerializer.serialize(awardComponent, "Array<'affiliate' | 'data analysis' | 'data coordination' | 'functional characterization' | 'mapping' | 'networks' | 'predictive modeling'>");
        }

        if (classifications !== undefined) {
            localVarQueryParameters['classifications'] = ObjectSerializer.serialize(classifications, "Array<string>");
        }

        if (collections !== undefined) {
            localVarQueryParameters['collections'] = ObjectSerializer.serialize(collections, "Array<'ClinGen' | 'ENCODE' | 'GREGoR' | 'IGVF_catalog_beta_v0.1' | 'IGVF_catalog_beta_v0.2' | 'IGVF_catalog_beta_v0.3' | 'IGVF_catalog_beta_v0.4' | 'MaveDB' | 'MPRAbase' | 'Vista'>");
        }

        if (constructLibrarySets !== undefined) {
            localVarQueryParameters['construct_library_sets'] = ObjectSerializer.serialize(constructLibrarySets, "Array<string>");
        }

        if (creationTimestamp !== undefined) {
            localVarQueryParameters['creation_timestamp'] = ObjectSerializer.serialize(creationTimestamp, "Array<string>");
        }

        if (dateObtained !== undefined) {
            localVarQueryParameters['date_obtained'] = ObjectSerializer.serialize(dateObtained, "Array<string>");
        }

        if (dbxrefs !== undefined) {
            localVarQueryParameters['dbxrefs'] = ObjectSerializer.serialize(dbxrefs, "Array<string>");
        }

        if (description !== undefined) {
            localVarQueryParameters['description'] = ObjectSerializer.serialize(description, "Array<string>");
        }

        if (documents !== undefined) {
            localVarQueryParameters['documents'] = ObjectSerializer.serialize(documents, "Array<string>");
        }

        if (fileSetsId !== undefined) {
            localVarQueryParameters['file_sets.@id'] = ObjectSerializer.serialize(fileSetsId, "Array<string>");
        }

        if (fileSetsAccession !== undefined) {
            localVarQueryParameters['file_sets.accession'] = ObjectSerializer.serialize(fileSetsAccession, "Array<string>");
        }

        if (fileSetsAliases !== undefined) {
            localVarQueryParameters['file_sets.aliases'] = ObjectSerializer.serialize(fileSetsAliases, "Array<string>");
        }

        if (fileSetsAssayTermTermName !== undefined) {
            localVarQueryParameters['file_sets.assay_term.term_name'] = ObjectSerializer.serialize(fileSetsAssayTermTermName, "Array<string>");
        }

        if (fileSetsLabTitle !== undefined) {
            localVarQueryParameters['file_sets.lab.title'] = ObjectSerializer.serialize(fileSetsLabTitle, "Array<string>");
        }

        if (fileSetsStatus !== undefined) {
            localVarQueryParameters['file_sets.status'] = ObjectSerializer.serialize(fileSetsStatus, "Array<'in progress' | 'released' | 'deleted' | 'replaced' | 'revoked' | 'archived'>");
        }

        if (fileSetsSummary !== undefined) {
            localVarQueryParameters['file_sets.summary'] = ObjectSerializer.serialize(fileSetsSummary, "Array<string>");
        }

        if (institutionalCertificates !== undefined) {
            localVarQueryParameters['institutional_certificates'] = ObjectSerializer.serialize(institutionalCertificates, "Array<string>");
        }

        if (labId !== undefined) {
            localVarQueryParameters['lab.@id'] = ObjectSerializer.serialize(labId, "Array<string>");
        }

        if (labTitle !== undefined) {
            localVarQueryParameters['lab.title'] = ObjectSerializer.serialize(labTitle, "Array<string>");
        }

        if (lotId !== undefined) {
            localVarQueryParameters['lot_id'] = ObjectSerializer.serialize(lotId, "Array<string>");
        }

        if (moi !== undefined) {
            localVarQueryParameters['moi'] = ObjectSerializer.serialize(moi, "Array<number>");
        }

        if (multiplexedInId !== undefined) {
            localVarQueryParameters['multiplexed_in.@id'] = ObjectSerializer.serialize(multiplexedInId, "Array<string>");
        }

        if (multiplexedInAccession !== undefined) {
            localVarQueryParameters['multiplexed_in.accession'] = ObjectSerializer.serialize(multiplexedInAccession, "Array<string>");
        }

        if (notes !== undefined) {
            localVarQueryParameters['notes'] = ObjectSerializer.serialize(notes, "Array<string>");
        }

        if (nucleicAcidDelivery !== undefined) {
            localVarQueryParameters['nucleic_acid_delivery'] = ObjectSerializer.serialize(nucleicAcidDelivery, "Array<'transfection' | 'adenoviral transduction' | 'lentiviral transduction'>");
        }

        if (originOf !== undefined) {
            localVarQueryParameters['origin_of'] = ObjectSerializer.serialize(originOf, "Array<string>");
        }

        if (productId !== undefined) {
            localVarQueryParameters['product_id'] = ObjectSerializer.serialize(productId, "Array<string>");
        }

        if (protocols !== undefined) {
            localVarQueryParameters['protocols'] = ObjectSerializer.serialize(protocols, "Array<string>");
        }

        if (publicationIdentifiers !== undefined) {
            localVarQueryParameters['publication_identifiers'] = ObjectSerializer.serialize(publicationIdentifiers, "Array<string>");
        }

        if (publications !== undefined) {
            localVarQueryParameters['publications'] = ObjectSerializer.serialize(publications, "Array<string>");
        }

        if (releaseTimestamp !== undefined) {
            localVarQueryParameters['release_timestamp'] = ObjectSerializer.serialize(releaseTimestamp, "Array<string>");
        }

        if (revokeDetail !== undefined) {
            localVarQueryParameters['revoke_detail'] = ObjectSerializer.serialize(revokeDetail, "Array<string>");
        }

        if (sampleMaterial !== undefined) {
            localVarQueryParameters['sample_material'] = ObjectSerializer.serialize(sampleMaterial, "Array<'undefined' | 'inorganic' | 'synthetic' | 'organic'>");
        }

        if (sampleTermsId !== undefined) {
            localVarQueryParameters['sample_terms.@id'] = ObjectSerializer.serialize(sampleTermsId, "Array<string>");
        }

        if (sampleTermsTermName !== undefined) {
            localVarQueryParameters['sample_terms.term_name'] = ObjectSerializer.serialize(sampleTermsTermName, "Array<string>");
        }

        if (sortedFractions !== undefined) {
            localVarQueryParameters['sorted_fractions'] = ObjectSerializer.serialize(sortedFractions, "Array<string>");
        }

        if (sortedFromId !== undefined) {
            localVarQueryParameters['sorted_from.@id'] = ObjectSerializer.serialize(sortedFromId, "Array<string>");
        }

        if (sortedFromAccession !== undefined) {
            localVarQueryParameters['sorted_from.accession'] = ObjectSerializer.serialize(sortedFromAccession, "Array<string>");
        }

        if (sortedFromDetail !== undefined) {
            localVarQueryParameters['sorted_from_detail'] = ObjectSerializer.serialize(sortedFromDetail, "Array<string>");
        }

        if (sourcesId !== undefined) {
            localVarQueryParameters['sources.@id'] = ObjectSerializer.serialize(sourcesId, "Array<string>");
        }

        if (startingAmount !== undefined) {
            localVarQueryParameters['starting_amount'] = ObjectSerializer.serialize(startingAmount, "Array<number>");
        }

        if (startingAmountUnits !== undefined) {
            localVarQueryParameters['starting_amount_units'] = ObjectSerializer.serialize(startingAmountUnits, "Array<'cells' | 'cells/ml' | 'g' | 'items' | 'mg' | 'whole animals' | 'whole embryos' | 'μg' | 'ng'>");
        }

        if (status !== undefined) {
            localVarQueryParameters['status'] = ObjectSerializer.serialize(status, "Array<'in progress' | 'released' | 'deleted' | 'replaced' | 'revoked' | 'archived'>");
        }

        if (submittedById !== undefined) {
            localVarQueryParameters['submitted_by.@id'] = ObjectSerializer.serialize(submittedById, "Array<string>");
        }

        if (submittedByTitle !== undefined) {
            localVarQueryParameters['submitted_by.title'] = ObjectSerializer.serialize(submittedByTitle, "Array<string>");
        }

        if (submitterComment !== undefined) {
            localVarQueryParameters['submitter_comment'] = ObjectSerializer.serialize(submitterComment, "Array<string>");
        }

        if (summary !== undefined) {
            localVarQueryParameters['summary'] = ObjectSerializer.serialize(summary, "Array<string>");
        }

        if (taxa !== undefined) {
            localVarQueryParameters['taxa'] = ObjectSerializer.serialize(taxa, "Array<'Saccharomyces cerevisiae' | 'Homo sapiens'>");
        }

        if (timePostLibraryDelivery !== undefined) {
            localVarQueryParameters['time_post_library_delivery'] = ObjectSerializer.serialize(timePostLibraryDelivery, "Array<number>");
        }

        if (timePostLibraryDeliveryUnits !== undefined) {
            localVarQueryParameters['time_post_library_delivery_units'] = ObjectSerializer.serialize(timePostLibraryDeliveryUnits, "Array<'minute' | 'hour' | 'day' | 'week' | 'month'>");
        }

        if (url !== undefined) {
            localVarQueryParameters['url'] = ObjectSerializer.serialize(url, "Array<string>");
        }

        if (uuid !== undefined) {
            localVarQueryParameters['uuid'] = ObjectSerializer.serialize(uuid, "Array<string>");
        }

        if (virtual !== undefined) {
            localVarQueryParameters['virtual'] = ObjectSerializer.serialize(virtual, "Array<boolean>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: TechnicalSampleResults;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "TechnicalSampleResults");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Collection endpoint that accepts various query parameters to filter, sort, and paginate Tissue items. Supports filtering on fields within Tissue items.
     * @summary List items in the Tissue collection.
     * @param frame Constant value. Do not set.
     * @param query Query string for searching.
     * @param limit Maximum number of results to return. Default is 25. Use \&#39;all\&#39; for all results.
     * @param sort Fields to sort results by. Prefix with \&#39;-\&#39; for descending order. Can be repeated for multiple sort fields. Does not work with limit&#x3D;all.
     * @param id Filter by @id
     * @param accession Filter by accession
     * @param age Filter by age
     * @param ageUnits Filter by age_units
     * @param aliases Filter by aliases
     * @param alternateAccessions Filter by alternate_accessions
     * @param awardId Filter by award.@id
     * @param awardComponent Filter by award.component
     * @param biomarkers Filter by biomarkers
     * @param ccfId Filter by ccf_id
     * @param cellularSubPool Filter by cellular_sub_pool
     * @param classifications Filter by classifications
     * @param collections Filter by collections
     * @param constructLibrarySets Filter by construct_library_sets
     * @param creationTimestamp Filter by creation_timestamp
     * @param dateObtained Filter by date_obtained
     * @param dbxrefs Filter by dbxrefs
     * @param description Filter by description
     * @param diseaseTermsId Filter by disease_terms.@id
     * @param diseaseTermsTermName Filter by disease_terms.term_name
     * @param documents Filter by documents
     * @param donors Filter by donors
     * @param embryonic Filter by embryonic
     * @param fileSetsId Filter by file_sets.@id
     * @param fileSetsAccession Filter by file_sets.accession
     * @param fileSetsAliases Filter by file_sets.aliases
     * @param fileSetsAssayTermTermName Filter by file_sets.assay_term.term_name
     * @param fileSetsLabTitle Filter by file_sets.lab.title
     * @param fileSetsStatus Filter by file_sets.status
     * @param fileSetsSummary Filter by file_sets.summary
     * @param institutionalCertificatesId Filter by institutional_certificates.@id
     * @param institutionalCertificatesCertificateIdentifier Filter by institutional_certificates.certificate_identifier
     * @param labId Filter by lab.@id
     * @param labTitle Filter by lab.title
     * @param lotId Filter by lot_id
     * @param lowerBoundAge Filter by lower_bound_age
     * @param lowerBoundAgeInHours Filter by lower_bound_age_in_hours
     * @param modificationsId Filter by modifications.@id
     * @param modificationsStatus Filter by modifications.status
     * @param modificationsSummary Filter by modifications.summary
     * @param moi Filter by moi
     * @param multiplexedInId Filter by multiplexed_in.@id
     * @param multiplexedInAccession Filter by multiplexed_in.accession
     * @param notes Filter by notes
     * @param nucleicAcidDelivery Filter by nucleic_acid_delivery
     * @param originOf Filter by origin_of
     * @param originatedFrom Filter by originated_from
     * @param partOf Filter by part_of
     * @param parts Filter by parts
     * @param pmi Filter by pmi
     * @param pmiUnits Filter by pmi_units
     * @param pooledFrom Filter by pooled_from
     * @param pooledIn Filter by pooled_in
     * @param preservationMethod Filter by preservation_method
     * @param productId Filter by product_id
     * @param protocols Filter by protocols
     * @param publicationIdentifiers Filter by publication_identifiers
     * @param publications Filter by publications
     * @param releaseTimestamp Filter by release_timestamp
     * @param revokeDetail Filter by revoke_detail
     * @param sampleTermsId Filter by sample_terms.@id
     * @param sampleTermsTermName Filter by sample_terms.term_name
     * @param sex Filter by sex
     * @param sortedFractions Filter by sorted_fractions
     * @param sortedFromId Filter by sorted_from.@id
     * @param sortedFromAccession Filter by sorted_from.accession
     * @param sortedFromDetail Filter by sorted_from_detail
     * @param sourcesId Filter by sources.@id
     * @param startingAmount Filter by starting_amount
     * @param startingAmountUnits Filter by starting_amount_units
     * @param status Filter by status
     * @param submittedById Filter by submitted_by.@id
     * @param submittedByTitle Filter by submitted_by.title
     * @param submitterComment Filter by submitter_comment
     * @param summary Filter by summary
     * @param taxa Filter by taxa
     * @param timePostLibraryDelivery Filter by time_post_library_delivery
     * @param timePostLibraryDeliveryUnits Filter by time_post_library_delivery_units
     * @param treatmentsId Filter by treatments.@id
     * @param treatmentsPurpose Filter by treatments.purpose
     * @param treatmentsStatus Filter by treatments.status
     * @param treatmentsSummary Filter by treatments.summary
     * @param treatmentsTreatmentType Filter by treatments.treatment_type
     * @param upperBoundAge Filter by upper_bound_age
     * @param upperBoundAgeInHours Filter by upper_bound_age_in_hours
     * @param url Filter by url
     * @param uuid Filter by uuid
     * @param virtual Filter by virtual
     */
    public async tissues (frame: 'object', query?: string, limit?: Limit, sort?: Array<string>, id?: Array<string>, accession?: Array<string>, age?: Array<string>, ageUnits?: Array<'minute' | 'hour' | 'day' | 'week' | 'month' | 'year'>, aliases?: Array<string>, alternateAccessions?: Array<string>, awardId?: Array<string>, awardComponent?: Array<'affiliate' | 'data analysis' | 'data coordination' | 'functional characterization' | 'mapping' | 'networks' | 'predictive modeling'>, biomarkers?: Array<string>, ccfId?: Array<string>, cellularSubPool?: Array<string>, classifications?: Array<string>, collections?: Array<'ClinGen' | 'ENCODE' | 'GREGoR' | 'IGVF_catalog_beta_v0.1' | 'IGVF_catalog_beta_v0.2' | 'IGVF_catalog_beta_v0.3' | 'IGVF_catalog_beta_v0.4' | 'MaveDB' | 'MPRAbase' | 'Vista'>, constructLibrarySets?: Array<string>, creationTimestamp?: Array<string>, dateObtained?: Array<string>, dbxrefs?: Array<string>, description?: Array<string>, diseaseTermsId?: Array<string>, diseaseTermsTermName?: Array<string>, documents?: Array<string>, donors?: Array<string>, embryonic?: Array<boolean>, fileSetsId?: Array<string>, fileSetsAccession?: Array<string>, fileSetsAliases?: Array<string>, fileSetsAssayTermTermName?: Array<string>, fileSetsLabTitle?: Array<string>, fileSetsStatus?: Array<'in progress' | 'released' | 'deleted' | 'replaced' | 'revoked' | 'archived'>, fileSetsSummary?: Array<string>, institutionalCertificatesId?: Array<string>, institutionalCertificatesCertificateIdentifier?: Array<string>, labId?: Array<string>, labTitle?: Array<string>, lotId?: Array<string>, lowerBoundAge?: Array<number>, lowerBoundAgeInHours?: Array<number>, modificationsId?: Array<string>, modificationsStatus?: Array<'archived' | 'deleted' | 'in progress' | 'released'>, modificationsSummary?: Array<string>, moi?: Array<number>, multiplexedInId?: Array<string>, multiplexedInAccession?: Array<string>, notes?: Array<string>, nucleicAcidDelivery?: Array<'transfection' | 'adenoviral transduction' | 'lentiviral transduction'>, originOf?: Array<string>, originatedFrom?: Array<string>, partOf?: Array<string>, parts?: Array<string>, pmi?: Array<number>, pmiUnits?: Array<'second' | 'minute' | 'hour' | 'day' | 'week'>, pooledFrom?: Array<string>, pooledIn?: Array<string>, preservationMethod?: Array<'cryopreservation' | 'flash-freezing'>, productId?: Array<string>, protocols?: Array<string>, publicationIdentifiers?: Array<string>, publications?: Array<string>, releaseTimestamp?: Array<string>, revokeDetail?: Array<string>, sampleTermsId?: Array<string>, sampleTermsTermName?: Array<string>, sex?: Array<'female' | 'male' | 'mixed' | 'unspecified'>, sortedFractions?: Array<string>, sortedFromId?: Array<string>, sortedFromAccession?: Array<string>, sortedFromDetail?: Array<string>, sourcesId?: Array<string>, startingAmount?: Array<number>, startingAmountUnits?: Array<'cells' | 'cells/ml' | 'g' | 'items' | 'mg' | 'whole animals' | 'whole embryos' | 'μg' | 'ng'>, status?: Array<'in progress' | 'released' | 'deleted' | 'replaced' | 'revoked' | 'archived'>, submittedById?: Array<string>, submittedByTitle?: Array<string>, submitterComment?: Array<string>, summary?: Array<string>, taxa?: Array<'Homo sapiens' | 'Mus musculus'>, timePostLibraryDelivery?: Array<number>, timePostLibraryDeliveryUnits?: Array<'minute' | 'hour' | 'day' | 'week' | 'month'>, treatmentsId?: Array<string>, treatmentsPurpose?: Array<'activation' | 'agonist' | 'antagonist' | 'control' | 'differentiation' | 'de-differentiation' | 'perturbation' | 'selection' | 'stimulation'>, treatmentsStatus?: Array<'archived' | 'deleted' | 'in progress' | 'released'>, treatmentsSummary?: Array<string>, treatmentsTreatmentType?: Array<'chemical' | 'protein' | 'environmental'>, upperBoundAge?: Array<number>, upperBoundAgeInHours?: Array<number>, url?: Array<string>, uuid?: Array<string>, virtual?: Array<boolean>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: TissueResults;  }> {
        const localVarPath = this.basePath + '/tissues/@@listing';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'frame' is not null or undefined
        if (frame === null || frame === undefined) {
            throw new Error('Required parameter frame was null or undefined when calling tissues.');
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (frame !== undefined) {
            localVarQueryParameters['frame'] = ObjectSerializer.serialize(frame, "'object'");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "Limit");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "Array<string>");
        }

        if (id !== undefined) {
            localVarQueryParameters['@id'] = ObjectSerializer.serialize(id, "Array<string>");
        }

        if (accession !== undefined) {
            localVarQueryParameters['accession'] = ObjectSerializer.serialize(accession, "Array<string>");
        }

        if (age !== undefined) {
            localVarQueryParameters['age'] = ObjectSerializer.serialize(age, "Array<string>");
        }

        if (ageUnits !== undefined) {
            localVarQueryParameters['age_units'] = ObjectSerializer.serialize(ageUnits, "Array<'minute' | 'hour' | 'day' | 'week' | 'month' | 'year'>");
        }

        if (aliases !== undefined) {
            localVarQueryParameters['aliases'] = ObjectSerializer.serialize(aliases, "Array<string>");
        }

        if (alternateAccessions !== undefined) {
            localVarQueryParameters['alternate_accessions'] = ObjectSerializer.serialize(alternateAccessions, "Array<string>");
        }

        if (awardId !== undefined) {
            localVarQueryParameters['award.@id'] = ObjectSerializer.serialize(awardId, "Array<string>");
        }

        if (awardComponent !== undefined) {
            localVarQueryParameters['award.component'] = ObjectSerializer.serialize(awardComponent, "Array<'affiliate' | 'data analysis' | 'data coordination' | 'functional characterization' | 'mapping' | 'networks' | 'predictive modeling'>");
        }

        if (biomarkers !== undefined) {
            localVarQueryParameters['biomarkers'] = ObjectSerializer.serialize(biomarkers, "Array<string>");
        }

        if (ccfId !== undefined) {
            localVarQueryParameters['ccf_id'] = ObjectSerializer.serialize(ccfId, "Array<string>");
        }

        if (cellularSubPool !== undefined) {
            localVarQueryParameters['cellular_sub_pool'] = ObjectSerializer.serialize(cellularSubPool, "Array<string>");
        }

        if (classifications !== undefined) {
            localVarQueryParameters['classifications'] = ObjectSerializer.serialize(classifications, "Array<string>");
        }

        if (collections !== undefined) {
            localVarQueryParameters['collections'] = ObjectSerializer.serialize(collections, "Array<'ClinGen' | 'ENCODE' | 'GREGoR' | 'IGVF_catalog_beta_v0.1' | 'IGVF_catalog_beta_v0.2' | 'IGVF_catalog_beta_v0.3' | 'IGVF_catalog_beta_v0.4' | 'MaveDB' | 'MPRAbase' | 'Vista'>");
        }

        if (constructLibrarySets !== undefined) {
            localVarQueryParameters['construct_library_sets'] = ObjectSerializer.serialize(constructLibrarySets, "Array<string>");
        }

        if (creationTimestamp !== undefined) {
            localVarQueryParameters['creation_timestamp'] = ObjectSerializer.serialize(creationTimestamp, "Array<string>");
        }

        if (dateObtained !== undefined) {
            localVarQueryParameters['date_obtained'] = ObjectSerializer.serialize(dateObtained, "Array<string>");
        }

        if (dbxrefs !== undefined) {
            localVarQueryParameters['dbxrefs'] = ObjectSerializer.serialize(dbxrefs, "Array<string>");
        }

        if (description !== undefined) {
            localVarQueryParameters['description'] = ObjectSerializer.serialize(description, "Array<string>");
        }

        if (diseaseTermsId !== undefined) {
            localVarQueryParameters['disease_terms.@id'] = ObjectSerializer.serialize(diseaseTermsId, "Array<string>");
        }

        if (diseaseTermsTermName !== undefined) {
            localVarQueryParameters['disease_terms.term_name'] = ObjectSerializer.serialize(diseaseTermsTermName, "Array<string>");
        }

        if (documents !== undefined) {
            localVarQueryParameters['documents'] = ObjectSerializer.serialize(documents, "Array<string>");
        }

        if (donors !== undefined) {
            localVarQueryParameters['donors'] = ObjectSerializer.serialize(donors, "Array<string>");
        }

        if (embryonic !== undefined) {
            localVarQueryParameters['embryonic'] = ObjectSerializer.serialize(embryonic, "Array<boolean>");
        }

        if (fileSetsId !== undefined) {
            localVarQueryParameters['file_sets.@id'] = ObjectSerializer.serialize(fileSetsId, "Array<string>");
        }

        if (fileSetsAccession !== undefined) {
            localVarQueryParameters['file_sets.accession'] = ObjectSerializer.serialize(fileSetsAccession, "Array<string>");
        }

        if (fileSetsAliases !== undefined) {
            localVarQueryParameters['file_sets.aliases'] = ObjectSerializer.serialize(fileSetsAliases, "Array<string>");
        }

        if (fileSetsAssayTermTermName !== undefined) {
            localVarQueryParameters['file_sets.assay_term.term_name'] = ObjectSerializer.serialize(fileSetsAssayTermTermName, "Array<string>");
        }

        if (fileSetsLabTitle !== undefined) {
            localVarQueryParameters['file_sets.lab.title'] = ObjectSerializer.serialize(fileSetsLabTitle, "Array<string>");
        }

        if (fileSetsStatus !== undefined) {
            localVarQueryParameters['file_sets.status'] = ObjectSerializer.serialize(fileSetsStatus, "Array<'in progress' | 'released' | 'deleted' | 'replaced' | 'revoked' | 'archived'>");
        }

        if (fileSetsSummary !== undefined) {
            localVarQueryParameters['file_sets.summary'] = ObjectSerializer.serialize(fileSetsSummary, "Array<string>");
        }

        if (institutionalCertificatesId !== undefined) {
            localVarQueryParameters['institutional_certificates.@id'] = ObjectSerializer.serialize(institutionalCertificatesId, "Array<string>");
        }

        if (institutionalCertificatesCertificateIdentifier !== undefined) {
            localVarQueryParameters['institutional_certificates.certificate_identifier'] = ObjectSerializer.serialize(institutionalCertificatesCertificateIdentifier, "Array<string>");
        }

        if (labId !== undefined) {
            localVarQueryParameters['lab.@id'] = ObjectSerializer.serialize(labId, "Array<string>");
        }

        if (labTitle !== undefined) {
            localVarQueryParameters['lab.title'] = ObjectSerializer.serialize(labTitle, "Array<string>");
        }

        if (lotId !== undefined) {
            localVarQueryParameters['lot_id'] = ObjectSerializer.serialize(lotId, "Array<string>");
        }

        if (lowerBoundAge !== undefined) {
            localVarQueryParameters['lower_bound_age'] = ObjectSerializer.serialize(lowerBoundAge, "Array<number>");
        }

        if (lowerBoundAgeInHours !== undefined) {
            localVarQueryParameters['lower_bound_age_in_hours'] = ObjectSerializer.serialize(lowerBoundAgeInHours, "Array<number>");
        }

        if (modificationsId !== undefined) {
            localVarQueryParameters['modifications.@id'] = ObjectSerializer.serialize(modificationsId, "Array<string>");
        }

        if (modificationsStatus !== undefined) {
            localVarQueryParameters['modifications.status'] = ObjectSerializer.serialize(modificationsStatus, "Array<'archived' | 'deleted' | 'in progress' | 'released'>");
        }

        if (modificationsSummary !== undefined) {
            localVarQueryParameters['modifications.summary'] = ObjectSerializer.serialize(modificationsSummary, "Array<string>");
        }

        if (moi !== undefined) {
            localVarQueryParameters['moi'] = ObjectSerializer.serialize(moi, "Array<number>");
        }

        if (multiplexedInId !== undefined) {
            localVarQueryParameters['multiplexed_in.@id'] = ObjectSerializer.serialize(multiplexedInId, "Array<string>");
        }

        if (multiplexedInAccession !== undefined) {
            localVarQueryParameters['multiplexed_in.accession'] = ObjectSerializer.serialize(multiplexedInAccession, "Array<string>");
        }

        if (notes !== undefined) {
            localVarQueryParameters['notes'] = ObjectSerializer.serialize(notes, "Array<string>");
        }

        if (nucleicAcidDelivery !== undefined) {
            localVarQueryParameters['nucleic_acid_delivery'] = ObjectSerializer.serialize(nucleicAcidDelivery, "Array<'transfection' | 'adenoviral transduction' | 'lentiviral transduction'>");
        }

        if (originOf !== undefined) {
            localVarQueryParameters['origin_of'] = ObjectSerializer.serialize(originOf, "Array<string>");
        }

        if (originatedFrom !== undefined) {
            localVarQueryParameters['originated_from'] = ObjectSerializer.serialize(originatedFrom, "Array<string>");
        }

        if (partOf !== undefined) {
            localVarQueryParameters['part_of'] = ObjectSerializer.serialize(partOf, "Array<string>");
        }

        if (parts !== undefined) {
            localVarQueryParameters['parts'] = ObjectSerializer.serialize(parts, "Array<string>");
        }

        if (pmi !== undefined) {
            localVarQueryParameters['pmi'] = ObjectSerializer.serialize(pmi, "Array<number>");
        }

        if (pmiUnits !== undefined) {
            localVarQueryParameters['pmi_units'] = ObjectSerializer.serialize(pmiUnits, "Array<'second' | 'minute' | 'hour' | 'day' | 'week'>");
        }

        if (pooledFrom !== undefined) {
            localVarQueryParameters['pooled_from'] = ObjectSerializer.serialize(pooledFrom, "Array<string>");
        }

        if (pooledIn !== undefined) {
            localVarQueryParameters['pooled_in'] = ObjectSerializer.serialize(pooledIn, "Array<string>");
        }

        if (preservationMethod !== undefined) {
            localVarQueryParameters['preservation_method'] = ObjectSerializer.serialize(preservationMethod, "Array<'cryopreservation' | 'flash-freezing'>");
        }

        if (productId !== undefined) {
            localVarQueryParameters['product_id'] = ObjectSerializer.serialize(productId, "Array<string>");
        }

        if (protocols !== undefined) {
            localVarQueryParameters['protocols'] = ObjectSerializer.serialize(protocols, "Array<string>");
        }

        if (publicationIdentifiers !== undefined) {
            localVarQueryParameters['publication_identifiers'] = ObjectSerializer.serialize(publicationIdentifiers, "Array<string>");
        }

        if (publications !== undefined) {
            localVarQueryParameters['publications'] = ObjectSerializer.serialize(publications, "Array<string>");
        }

        if (releaseTimestamp !== undefined) {
            localVarQueryParameters['release_timestamp'] = ObjectSerializer.serialize(releaseTimestamp, "Array<string>");
        }

        if (revokeDetail !== undefined) {
            localVarQueryParameters['revoke_detail'] = ObjectSerializer.serialize(revokeDetail, "Array<string>");
        }

        if (sampleTermsId !== undefined) {
            localVarQueryParameters['sample_terms.@id'] = ObjectSerializer.serialize(sampleTermsId, "Array<string>");
        }

        if (sampleTermsTermName !== undefined) {
            localVarQueryParameters['sample_terms.term_name'] = ObjectSerializer.serialize(sampleTermsTermName, "Array<string>");
        }

        if (sex !== undefined) {
            localVarQueryParameters['sex'] = ObjectSerializer.serialize(sex, "Array<'female' | 'male' | 'mixed' | 'unspecified'>");
        }

        if (sortedFractions !== undefined) {
            localVarQueryParameters['sorted_fractions'] = ObjectSerializer.serialize(sortedFractions, "Array<string>");
        }

        if (sortedFromId !== undefined) {
            localVarQueryParameters['sorted_from.@id'] = ObjectSerializer.serialize(sortedFromId, "Array<string>");
        }

        if (sortedFromAccession !== undefined) {
            localVarQueryParameters['sorted_from.accession'] = ObjectSerializer.serialize(sortedFromAccession, "Array<string>");
        }

        if (sortedFromDetail !== undefined) {
            localVarQueryParameters['sorted_from_detail'] = ObjectSerializer.serialize(sortedFromDetail, "Array<string>");
        }

        if (sourcesId !== undefined) {
            localVarQueryParameters['sources.@id'] = ObjectSerializer.serialize(sourcesId, "Array<string>");
        }

        if (startingAmount !== undefined) {
            localVarQueryParameters['starting_amount'] = ObjectSerializer.serialize(startingAmount, "Array<number>");
        }

        if (startingAmountUnits !== undefined) {
            localVarQueryParameters['starting_amount_units'] = ObjectSerializer.serialize(startingAmountUnits, "Array<'cells' | 'cells/ml' | 'g' | 'items' | 'mg' | 'whole animals' | 'whole embryos' | 'μg' | 'ng'>");
        }

        if (status !== undefined) {
            localVarQueryParameters['status'] = ObjectSerializer.serialize(status, "Array<'in progress' | 'released' | 'deleted' | 'replaced' | 'revoked' | 'archived'>");
        }

        if (submittedById !== undefined) {
            localVarQueryParameters['submitted_by.@id'] = ObjectSerializer.serialize(submittedById, "Array<string>");
        }

        if (submittedByTitle !== undefined) {
            localVarQueryParameters['submitted_by.title'] = ObjectSerializer.serialize(submittedByTitle, "Array<string>");
        }

        if (submitterComment !== undefined) {
            localVarQueryParameters['submitter_comment'] = ObjectSerializer.serialize(submitterComment, "Array<string>");
        }

        if (summary !== undefined) {
            localVarQueryParameters['summary'] = ObjectSerializer.serialize(summary, "Array<string>");
        }

        if (taxa !== undefined) {
            localVarQueryParameters['taxa'] = ObjectSerializer.serialize(taxa, "Array<'Homo sapiens' | 'Mus musculus'>");
        }

        if (timePostLibraryDelivery !== undefined) {
            localVarQueryParameters['time_post_library_delivery'] = ObjectSerializer.serialize(timePostLibraryDelivery, "Array<number>");
        }

        if (timePostLibraryDeliveryUnits !== undefined) {
            localVarQueryParameters['time_post_library_delivery_units'] = ObjectSerializer.serialize(timePostLibraryDeliveryUnits, "Array<'minute' | 'hour' | 'day' | 'week' | 'month'>");
        }

        if (treatmentsId !== undefined) {
            localVarQueryParameters['treatments.@id'] = ObjectSerializer.serialize(treatmentsId, "Array<string>");
        }

        if (treatmentsPurpose !== undefined) {
            localVarQueryParameters['treatments.purpose'] = ObjectSerializer.serialize(treatmentsPurpose, "Array<'activation' | 'agonist' | 'antagonist' | 'control' | 'differentiation' | 'de-differentiation' | 'perturbation' | 'selection' | 'stimulation'>");
        }

        if (treatmentsStatus !== undefined) {
            localVarQueryParameters['treatments.status'] = ObjectSerializer.serialize(treatmentsStatus, "Array<'archived' | 'deleted' | 'in progress' | 'released'>");
        }

        if (treatmentsSummary !== undefined) {
            localVarQueryParameters['treatments.summary'] = ObjectSerializer.serialize(treatmentsSummary, "Array<string>");
        }

        if (treatmentsTreatmentType !== undefined) {
            localVarQueryParameters['treatments.treatment_type'] = ObjectSerializer.serialize(treatmentsTreatmentType, "Array<'chemical' | 'protein' | 'environmental'>");
        }

        if (upperBoundAge !== undefined) {
            localVarQueryParameters['upper_bound_age'] = ObjectSerializer.serialize(upperBoundAge, "Array<number>");
        }

        if (upperBoundAgeInHours !== undefined) {
            localVarQueryParameters['upper_bound_age_in_hours'] = ObjectSerializer.serialize(upperBoundAgeInHours, "Array<number>");
        }

        if (url !== undefined) {
            localVarQueryParameters['url'] = ObjectSerializer.serialize(url, "Array<string>");
        }

        if (uuid !== undefined) {
            localVarQueryParameters['uuid'] = ObjectSerializer.serialize(uuid, "Array<string>");
        }

        if (virtual !== undefined) {
            localVarQueryParameters['virtual'] = ObjectSerializer.serialize(virtual, "Array<boolean>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: TissueResults;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "TissueResults");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Collection endpoint that accepts various query parameters to filter, sort, and paginate Treatment items. Supports filtering on fields within Treatment items.
     * @summary List items in the Treatment collection.
     * @param frame Constant value. Do not set.
     * @param query Query string for searching.
     * @param limit Maximum number of results to return. Default is 25. Use \&#39;all\&#39; for all results.
     * @param sort Fields to sort results by. Prefix with \&#39;-\&#39; for descending order. Can be repeated for multiple sort fields. Does not work with limit&#x3D;all.
     * @param id Filter by @id
     * @param aliases Filter by aliases
     * @param amount Filter by amount
     * @param amountUnits Filter by amount_units
     * @param awardId Filter by award.@id
     * @param awardComponent Filter by award.component
     * @param biosamplesTreated Filter by biosamples_treated
     * @param creationTimestamp Filter by creation_timestamp
     * @param depletion Filter by depletion
     * @param description Filter by description
     * @param documents Filter by documents
     * @param duration Filter by duration
     * @param durationUnits Filter by duration_units
     * @param labId Filter by lab.@id
     * @param labTitle Filter by lab.title
     * @param lotId Filter by lot_id
     * @param notes Filter by notes
     * @param pH Filter by pH
     * @param postTreatmentTime Filter by post_treatment_time
     * @param postTreatmentTimeUnits Filter by post_treatment_time_units
     * @param productId Filter by product_id
     * @param purpose Filter by purpose
     * @param releaseTimestamp Filter by release_timestamp
     * @param sourcesId Filter by sources.@id
     * @param status Filter by status
     * @param submittedById Filter by submitted_by.@id
     * @param submittedByTitle Filter by submitted_by.title
     * @param submitterComment Filter by submitter_comment
     * @param summary Filter by summary
     * @param temperature Filter by temperature
     * @param temperatureUnits Filter by temperature_units
     * @param treatmentTermId Filter by treatment_term_id
     * @param treatmentTermName Filter by treatment_term_name
     * @param treatmentType Filter by treatment_type
     * @param uuid Filter by uuid
     */
    public async treatments (frame: 'object', query?: string, limit?: Limit, sort?: Array<string>, id?: Array<string>, aliases?: Array<string>, amount?: Array<number>, amountUnits?: Array<'mg/kg' | 'mg/mL' | 'mM' | 'ng/mL' | 'nM' | 'percent' | 'μg/kg' | 'μg/kg' | 'μg/mL' | 'μM' | 'kpa'>, awardId?: Array<string>, awardComponent?: Array<'affiliate' | 'data analysis' | 'data coordination' | 'functional characterization' | 'mapping' | 'networks' | 'predictive modeling'>, biosamplesTreated?: Array<string>, creationTimestamp?: Array<string>, depletion?: Array<boolean>, description?: Array<string>, documents?: Array<string>, duration?: Array<number>, durationUnits?: Array<'second' | 'minute' | 'hour' | 'day'>, labId?: Array<string>, labTitle?: Array<string>, lotId?: Array<string>, notes?: Array<string>, pH?: Array<number>, postTreatmentTime?: Array<number>, postTreatmentTimeUnits?: Array<'minute' | 'hour' | 'day' | 'week' | 'month'>, productId?: Array<string>, purpose?: Array<'activation' | 'agonist' | 'antagonist' | 'control' | 'differentiation' | 'de-differentiation' | 'perturbation' | 'selection' | 'stimulation'>, releaseTimestamp?: Array<string>, sourcesId?: Array<string>, status?: Array<'archived' | 'deleted' | 'in progress' | 'released'>, submittedById?: Array<string>, submittedByTitle?: Array<string>, submitterComment?: Array<string>, summary?: Array<string>, temperature?: Array<number>, temperatureUnits?: Array<'Celsius'>, treatmentTermId?: Array<string>, treatmentTermName?: Array<string>, treatmentType?: Array<'chemical' | 'protein' | 'environmental'>, uuid?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: TreatmentResults;  }> {
        const localVarPath = this.basePath + '/treatments/@@listing';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'frame' is not null or undefined
        if (frame === null || frame === undefined) {
            throw new Error('Required parameter frame was null or undefined when calling treatments.');
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (frame !== undefined) {
            localVarQueryParameters['frame'] = ObjectSerializer.serialize(frame, "'object'");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "Limit");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "Array<string>");
        }

        if (id !== undefined) {
            localVarQueryParameters['@id'] = ObjectSerializer.serialize(id, "Array<string>");
        }

        if (aliases !== undefined) {
            localVarQueryParameters['aliases'] = ObjectSerializer.serialize(aliases, "Array<string>");
        }

        if (amount !== undefined) {
            localVarQueryParameters['amount'] = ObjectSerializer.serialize(amount, "Array<number>");
        }

        if (amountUnits !== undefined) {
            localVarQueryParameters['amount_units'] = ObjectSerializer.serialize(amountUnits, "Array<'mg/kg' | 'mg/mL' | 'mM' | 'ng/mL' | 'nM' | 'percent' | 'μg/kg' | 'μg/kg' | 'μg/mL' | 'μM' | 'kpa'>");
        }

        if (awardId !== undefined) {
            localVarQueryParameters['award.@id'] = ObjectSerializer.serialize(awardId, "Array<string>");
        }

        if (awardComponent !== undefined) {
            localVarQueryParameters['award.component'] = ObjectSerializer.serialize(awardComponent, "Array<'affiliate' | 'data analysis' | 'data coordination' | 'functional characterization' | 'mapping' | 'networks' | 'predictive modeling'>");
        }

        if (biosamplesTreated !== undefined) {
            localVarQueryParameters['biosamples_treated'] = ObjectSerializer.serialize(biosamplesTreated, "Array<string>");
        }

        if (creationTimestamp !== undefined) {
            localVarQueryParameters['creation_timestamp'] = ObjectSerializer.serialize(creationTimestamp, "Array<string>");
        }

        if (depletion !== undefined) {
            localVarQueryParameters['depletion'] = ObjectSerializer.serialize(depletion, "Array<boolean>");
        }

        if (description !== undefined) {
            localVarQueryParameters['description'] = ObjectSerializer.serialize(description, "Array<string>");
        }

        if (documents !== undefined) {
            localVarQueryParameters['documents'] = ObjectSerializer.serialize(documents, "Array<string>");
        }

        if (duration !== undefined) {
            localVarQueryParameters['duration'] = ObjectSerializer.serialize(duration, "Array<number>");
        }

        if (durationUnits !== undefined) {
            localVarQueryParameters['duration_units'] = ObjectSerializer.serialize(durationUnits, "Array<'second' | 'minute' | 'hour' | 'day'>");
        }

        if (labId !== undefined) {
            localVarQueryParameters['lab.@id'] = ObjectSerializer.serialize(labId, "Array<string>");
        }

        if (labTitle !== undefined) {
            localVarQueryParameters['lab.title'] = ObjectSerializer.serialize(labTitle, "Array<string>");
        }

        if (lotId !== undefined) {
            localVarQueryParameters['lot_id'] = ObjectSerializer.serialize(lotId, "Array<string>");
        }

        if (notes !== undefined) {
            localVarQueryParameters['notes'] = ObjectSerializer.serialize(notes, "Array<string>");
        }

        if (pH !== undefined) {
            localVarQueryParameters['pH'] = ObjectSerializer.serialize(pH, "Array<number>");
        }

        if (postTreatmentTime !== undefined) {
            localVarQueryParameters['post_treatment_time'] = ObjectSerializer.serialize(postTreatmentTime, "Array<number>");
        }

        if (postTreatmentTimeUnits !== undefined) {
            localVarQueryParameters['post_treatment_time_units'] = ObjectSerializer.serialize(postTreatmentTimeUnits, "Array<'minute' | 'hour' | 'day' | 'week' | 'month'>");
        }

        if (productId !== undefined) {
            localVarQueryParameters['product_id'] = ObjectSerializer.serialize(productId, "Array<string>");
        }

        if (purpose !== undefined) {
            localVarQueryParameters['purpose'] = ObjectSerializer.serialize(purpose, "Array<'activation' | 'agonist' | 'antagonist' | 'control' | 'differentiation' | 'de-differentiation' | 'perturbation' | 'selection' | 'stimulation'>");
        }

        if (releaseTimestamp !== undefined) {
            localVarQueryParameters['release_timestamp'] = ObjectSerializer.serialize(releaseTimestamp, "Array<string>");
        }

        if (sourcesId !== undefined) {
            localVarQueryParameters['sources.@id'] = ObjectSerializer.serialize(sourcesId, "Array<string>");
        }

        if (status !== undefined) {
            localVarQueryParameters['status'] = ObjectSerializer.serialize(status, "Array<'archived' | 'deleted' | 'in progress' | 'released'>");
        }

        if (submittedById !== undefined) {
            localVarQueryParameters['submitted_by.@id'] = ObjectSerializer.serialize(submittedById, "Array<string>");
        }

        if (submittedByTitle !== undefined) {
            localVarQueryParameters['submitted_by.title'] = ObjectSerializer.serialize(submittedByTitle, "Array<string>");
        }

        if (submitterComment !== undefined) {
            localVarQueryParameters['submitter_comment'] = ObjectSerializer.serialize(submitterComment, "Array<string>");
        }

        if (summary !== undefined) {
            localVarQueryParameters['summary'] = ObjectSerializer.serialize(summary, "Array<string>");
        }

        if (temperature !== undefined) {
            localVarQueryParameters['temperature'] = ObjectSerializer.serialize(temperature, "Array<number>");
        }

        if (temperatureUnits !== undefined) {
            localVarQueryParameters['temperature_units'] = ObjectSerializer.serialize(temperatureUnits, "Array<'Celsius'>");
        }

        if (treatmentTermId !== undefined) {
            localVarQueryParameters['treatment_term_id'] = ObjectSerializer.serialize(treatmentTermId, "Array<string>");
        }

        if (treatmentTermName !== undefined) {
            localVarQueryParameters['treatment_term_name'] = ObjectSerializer.serialize(treatmentTermName, "Array<string>");
        }

        if (treatmentType !== undefined) {
            localVarQueryParameters['treatment_type'] = ObjectSerializer.serialize(treatmentType, "Array<'chemical' | 'protein' | 'environmental'>");
        }

        if (uuid !== undefined) {
            localVarQueryParameters['uuid'] = ObjectSerializer.serialize(uuid, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: TreatmentResults;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "TreatmentResults");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Collection endpoint that accepts various query parameters to filter, sort, and paginate User items. Supports filtering on fields within User items.
     * @summary List items in the User collection.
     * @param frame Constant value. Do not set.
     * @param query Query string for searching.
     * @param limit Maximum number of results to return. Default is 25. Use \&#39;all\&#39; for all results.
     * @param sort Fields to sort results by. Prefix with \&#39;-\&#39; for descending order. Can be repeated for multiple sort fields. Does not work with limit&#x3D;all.
     * @param id Filter by @id
     * @param aliases Filter by aliases
     * @param creationTimestamp Filter by creation_timestamp
     * @param description Filter by description
     * @param email Filter by email
     * @param firstName Filter by first_name
     * @param groups Filter by groups
     * @param jobTitle Filter by job_title
     * @param lab Filter by lab
     * @param lastName Filter by last_name
     * @param notes Filter by notes
     * @param status Filter by status
     * @param submitsFor Filter by submits_for
     * @param submittedById Filter by submitted_by.@id
     * @param submittedByTitle Filter by submitted_by.title
     * @param submitterComment Filter by submitter_comment
     * @param summary Filter by summary
     * @param title Filter by title
     * @param uuid Filter by uuid
     * @param viewingGroups Filter by viewing_groups
     */
    public async users (frame: 'object', query?: string, limit?: Limit, sort?: Array<string>, id?: Array<string>, aliases?: Array<string>, creationTimestamp?: Array<string>, description?: Array<string>, email?: Array<string>, firstName?: Array<string>, groups?: Array<'admin' | 'read-only-admin' | 'verified'>, jobTitle?: Array<'Principal Investigator' | 'Co-Investigator' | 'Project Manager' | 'Submitter' | 'Post Doc' | 'Data Wrangler' | 'Scientist' | 'Computational Scientist' | 'Software Developer' | 'NHGRI staff member' | 'Other'>, lab?: Array<string>, lastName?: Array<string>, notes?: Array<string>, status?: Array<'current' | 'deleted' | 'disabled'>, submitsFor?: Array<string>, submittedById?: Array<string>, submittedByTitle?: Array<string>, submitterComment?: Array<string>, summary?: Array<string>, title?: Array<string>, uuid?: Array<string>, viewingGroups?: Array<'community' | 'IGVF'>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: UserResults;  }> {
        const localVarPath = this.basePath + '/users/@@listing';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'frame' is not null or undefined
        if (frame === null || frame === undefined) {
            throw new Error('Required parameter frame was null or undefined when calling users.');
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (frame !== undefined) {
            localVarQueryParameters['frame'] = ObjectSerializer.serialize(frame, "'object'");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "Limit");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "Array<string>");
        }

        if (id !== undefined) {
            localVarQueryParameters['@id'] = ObjectSerializer.serialize(id, "Array<string>");
        }

        if (aliases !== undefined) {
            localVarQueryParameters['aliases'] = ObjectSerializer.serialize(aliases, "Array<string>");
        }

        if (creationTimestamp !== undefined) {
            localVarQueryParameters['creation_timestamp'] = ObjectSerializer.serialize(creationTimestamp, "Array<string>");
        }

        if (description !== undefined) {
            localVarQueryParameters['description'] = ObjectSerializer.serialize(description, "Array<string>");
        }

        if (email !== undefined) {
            localVarQueryParameters['email'] = ObjectSerializer.serialize(email, "Array<string>");
        }

        if (firstName !== undefined) {
            localVarQueryParameters['first_name'] = ObjectSerializer.serialize(firstName, "Array<string>");
        }

        if (groups !== undefined) {
            localVarQueryParameters['groups'] = ObjectSerializer.serialize(groups, "Array<'admin' | 'read-only-admin' | 'verified'>");
        }

        if (jobTitle !== undefined) {
            localVarQueryParameters['job_title'] = ObjectSerializer.serialize(jobTitle, "Array<'Principal Investigator' | 'Co-Investigator' | 'Project Manager' | 'Submitter' | 'Post Doc' | 'Data Wrangler' | 'Scientist' | 'Computational Scientist' | 'Software Developer' | 'NHGRI staff member' | 'Other'>");
        }

        if (lab !== undefined) {
            localVarQueryParameters['lab'] = ObjectSerializer.serialize(lab, "Array<string>");
        }

        if (lastName !== undefined) {
            localVarQueryParameters['last_name'] = ObjectSerializer.serialize(lastName, "Array<string>");
        }

        if (notes !== undefined) {
            localVarQueryParameters['notes'] = ObjectSerializer.serialize(notes, "Array<string>");
        }

        if (status !== undefined) {
            localVarQueryParameters['status'] = ObjectSerializer.serialize(status, "Array<'current' | 'deleted' | 'disabled'>");
        }

        if (submitsFor !== undefined) {
            localVarQueryParameters['submits_for'] = ObjectSerializer.serialize(submitsFor, "Array<string>");
        }

        if (submittedById !== undefined) {
            localVarQueryParameters['submitted_by.@id'] = ObjectSerializer.serialize(submittedById, "Array<string>");
        }

        if (submittedByTitle !== undefined) {
            localVarQueryParameters['submitted_by.title'] = ObjectSerializer.serialize(submittedByTitle, "Array<string>");
        }

        if (submitterComment !== undefined) {
            localVarQueryParameters['submitter_comment'] = ObjectSerializer.serialize(submitterComment, "Array<string>");
        }

        if (summary !== undefined) {
            localVarQueryParameters['summary'] = ObjectSerializer.serialize(summary, "Array<string>");
        }

        if (title !== undefined) {
            localVarQueryParameters['title'] = ObjectSerializer.serialize(title, "Array<string>");
        }

        if (uuid !== undefined) {
            localVarQueryParameters['uuid'] = ObjectSerializer.serialize(uuid, "Array<string>");
        }

        if (viewingGroups !== undefined) {
            localVarQueryParameters['viewing_groups'] = ObjectSerializer.serialize(viewingGroups, "Array<'community' | 'IGVF'>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: UserResults;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "UserResults");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Collection endpoint that accepts various query parameters to filter, sort, and paginate WholeOrganism items. Supports filtering on fields within WholeOrganism items.
     * @summary List items in the WholeOrganism collection.
     * @param frame Constant value. Do not set.
     * @param query Query string for searching.
     * @param limit Maximum number of results to return. Default is 25. Use \&#39;all\&#39; for all results.
     * @param sort Fields to sort results by. Prefix with \&#39;-\&#39; for descending order. Can be repeated for multiple sort fields. Does not work with limit&#x3D;all.
     * @param id Filter by @id
     * @param accession Filter by accession
     * @param age Filter by age
     * @param ageUnits Filter by age_units
     * @param aliases Filter by aliases
     * @param alternateAccessions Filter by alternate_accessions
     * @param awardId Filter by award.@id
     * @param awardComponent Filter by award.component
     * @param biomarkers Filter by biomarkers
     * @param cellularSubPool Filter by cellular_sub_pool
     * @param classifications Filter by classifications
     * @param collections Filter by collections
     * @param constructLibrarySets Filter by construct_library_sets
     * @param creationTimestamp Filter by creation_timestamp
     * @param dateObtained Filter by date_obtained
     * @param dbxrefs Filter by dbxrefs
     * @param description Filter by description
     * @param diseaseTermsId Filter by disease_terms.@id
     * @param diseaseTermsTermName Filter by disease_terms.term_name
     * @param documents Filter by documents
     * @param donors Filter by donors
     * @param embryonic Filter by embryonic
     * @param fileSetsId Filter by file_sets.@id
     * @param fileSetsAccession Filter by file_sets.accession
     * @param fileSetsAliases Filter by file_sets.aliases
     * @param fileSetsAssayTermTermName Filter by file_sets.assay_term.term_name
     * @param fileSetsLabTitle Filter by file_sets.lab.title
     * @param fileSetsStatus Filter by file_sets.status
     * @param fileSetsSummary Filter by file_sets.summary
     * @param institutionalCertificatesId Filter by institutional_certificates.@id
     * @param institutionalCertificatesCertificateIdentifier Filter by institutional_certificates.certificate_identifier
     * @param labId Filter by lab.@id
     * @param labTitle Filter by lab.title
     * @param lotId Filter by lot_id
     * @param lowerBoundAge Filter by lower_bound_age
     * @param lowerBoundAgeInHours Filter by lower_bound_age_in_hours
     * @param modificationsId Filter by modifications.@id
     * @param modificationsStatus Filter by modifications.status
     * @param modificationsSummary Filter by modifications.summary
     * @param moi Filter by moi
     * @param multiplexedInId Filter by multiplexed_in.@id
     * @param multiplexedInAccession Filter by multiplexed_in.accession
     * @param notes Filter by notes
     * @param nucleicAcidDelivery Filter by nucleic_acid_delivery
     * @param originOf Filter by origin_of
     * @param originatedFrom Filter by originated_from
     * @param partOf Filter by part_of
     * @param parts Filter by parts
     * @param pooledFrom Filter by pooled_from
     * @param pooledIn Filter by pooled_in
     * @param productId Filter by product_id
     * @param protocols Filter by protocols
     * @param publicationIdentifiers Filter by publication_identifiers
     * @param publications Filter by publications
     * @param releaseTimestamp Filter by release_timestamp
     * @param revokeDetail Filter by revoke_detail
     * @param sampleTermsId Filter by sample_terms.@id
     * @param sampleTermsTermName Filter by sample_terms.term_name
     * @param sex Filter by sex
     * @param sortedFractions Filter by sorted_fractions
     * @param sortedFromId Filter by sorted_from.@id
     * @param sortedFromAccession Filter by sorted_from.accession
     * @param sortedFromDetail Filter by sorted_from_detail
     * @param sourcesId Filter by sources.@id
     * @param startingAmount Filter by starting_amount
     * @param startingAmountUnits Filter by starting_amount_units
     * @param status Filter by status
     * @param submittedById Filter by submitted_by.@id
     * @param submittedByTitle Filter by submitted_by.title
     * @param submitterComment Filter by submitter_comment
     * @param summary Filter by summary
     * @param taxa Filter by taxa
     * @param timePostLibraryDelivery Filter by time_post_library_delivery
     * @param timePostLibraryDeliveryUnits Filter by time_post_library_delivery_units
     * @param treatmentsId Filter by treatments.@id
     * @param treatmentsPurpose Filter by treatments.purpose
     * @param treatmentsStatus Filter by treatments.status
     * @param treatmentsSummary Filter by treatments.summary
     * @param treatmentsTreatmentType Filter by treatments.treatment_type
     * @param upperBoundAge Filter by upper_bound_age
     * @param upperBoundAgeInHours Filter by upper_bound_age_in_hours
     * @param url Filter by url
     * @param uuid Filter by uuid
     * @param virtual Filter by virtual
     */
    public async wholeOrganisms (frame: 'object', query?: string, limit?: Limit, sort?: Array<string>, id?: Array<string>, accession?: Array<string>, age?: Array<string>, ageUnits?: Array<'minute' | 'hour' | 'day' | 'week' | 'month' | 'year'>, aliases?: Array<string>, alternateAccessions?: Array<string>, awardId?: Array<string>, awardComponent?: Array<'affiliate' | 'data analysis' | 'data coordination' | 'functional characterization' | 'mapping' | 'networks' | 'predictive modeling'>, biomarkers?: Array<string>, cellularSubPool?: Array<string>, classifications?: Array<string>, collections?: Array<'ClinGen' | 'ENCODE' | 'GREGoR' | 'IGVF_catalog_beta_v0.1' | 'IGVF_catalog_beta_v0.2' | 'IGVF_catalog_beta_v0.3' | 'IGVF_catalog_beta_v0.4' | 'MaveDB' | 'MPRAbase' | 'Vista'>, constructLibrarySets?: Array<string>, creationTimestamp?: Array<string>, dateObtained?: Array<string>, dbxrefs?: Array<string>, description?: Array<string>, diseaseTermsId?: Array<string>, diseaseTermsTermName?: Array<string>, documents?: Array<string>, donors?: Array<string>, embryonic?: Array<boolean>, fileSetsId?: Array<string>, fileSetsAccession?: Array<string>, fileSetsAliases?: Array<string>, fileSetsAssayTermTermName?: Array<string>, fileSetsLabTitle?: Array<string>, fileSetsStatus?: Array<'in progress' | 'released' | 'deleted' | 'replaced' | 'revoked' | 'archived'>, fileSetsSummary?: Array<string>, institutionalCertificatesId?: Array<string>, institutionalCertificatesCertificateIdentifier?: Array<string>, labId?: Array<string>, labTitle?: Array<string>, lotId?: Array<string>, lowerBoundAge?: Array<number>, lowerBoundAgeInHours?: Array<number>, modificationsId?: Array<string>, modificationsStatus?: Array<'archived' | 'deleted' | 'in progress' | 'released'>, modificationsSummary?: Array<string>, moi?: Array<number>, multiplexedInId?: Array<string>, multiplexedInAccession?: Array<string>, notes?: Array<string>, nucleicAcidDelivery?: Array<'transfection' | 'adenoviral transduction' | 'lentiviral transduction'>, originOf?: Array<string>, originatedFrom?: Array<string>, partOf?: Array<string>, parts?: Array<string>, pooledFrom?: Array<string>, pooledIn?: Array<string>, productId?: Array<string>, protocols?: Array<string>, publicationIdentifiers?: Array<string>, publications?: Array<string>, releaseTimestamp?: Array<string>, revokeDetail?: Array<string>, sampleTermsId?: Array<string>, sampleTermsTermName?: Array<string>, sex?: Array<'female' | 'male' | 'mixed' | 'unspecified'>, sortedFractions?: Array<string>, sortedFromId?: Array<string>, sortedFromAccession?: Array<string>, sortedFromDetail?: Array<string>, sourcesId?: Array<string>, startingAmount?: Array<number>, startingAmountUnits?: Array<'cells' | 'cells/ml' | 'g' | 'items' | 'mg' | 'whole animals' | 'whole embryos' | 'μg' | 'ng'>, status?: Array<'in progress' | 'released' | 'deleted' | 'replaced' | 'revoked' | 'archived'>, submittedById?: Array<string>, submittedByTitle?: Array<string>, submitterComment?: Array<string>, summary?: Array<string>, taxa?: Array<'Homo sapiens' | 'Mus musculus'>, timePostLibraryDelivery?: Array<number>, timePostLibraryDeliveryUnits?: Array<'minute' | 'hour' | 'day' | 'week' | 'month'>, treatmentsId?: Array<string>, treatmentsPurpose?: Array<'activation' | 'agonist' | 'antagonist' | 'control' | 'differentiation' | 'de-differentiation' | 'perturbation' | 'selection' | 'stimulation'>, treatmentsStatus?: Array<'archived' | 'deleted' | 'in progress' | 'released'>, treatmentsSummary?: Array<string>, treatmentsTreatmentType?: Array<'chemical' | 'protein' | 'environmental'>, upperBoundAge?: Array<number>, upperBoundAgeInHours?: Array<number>, url?: Array<string>, uuid?: Array<string>, virtual?: Array<boolean>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: WholeOrganismResults;  }> {
        const localVarPath = this.basePath + '/whole-organisms/@@listing';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'frame' is not null or undefined
        if (frame === null || frame === undefined) {
            throw new Error('Required parameter frame was null or undefined when calling wholeOrganisms.');
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (frame !== undefined) {
            localVarQueryParameters['frame'] = ObjectSerializer.serialize(frame, "'object'");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "Limit");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "Array<string>");
        }

        if (id !== undefined) {
            localVarQueryParameters['@id'] = ObjectSerializer.serialize(id, "Array<string>");
        }

        if (accession !== undefined) {
            localVarQueryParameters['accession'] = ObjectSerializer.serialize(accession, "Array<string>");
        }

        if (age !== undefined) {
            localVarQueryParameters['age'] = ObjectSerializer.serialize(age, "Array<string>");
        }

        if (ageUnits !== undefined) {
            localVarQueryParameters['age_units'] = ObjectSerializer.serialize(ageUnits, "Array<'minute' | 'hour' | 'day' | 'week' | 'month' | 'year'>");
        }

        if (aliases !== undefined) {
            localVarQueryParameters['aliases'] = ObjectSerializer.serialize(aliases, "Array<string>");
        }

        if (alternateAccessions !== undefined) {
            localVarQueryParameters['alternate_accessions'] = ObjectSerializer.serialize(alternateAccessions, "Array<string>");
        }

        if (awardId !== undefined) {
            localVarQueryParameters['award.@id'] = ObjectSerializer.serialize(awardId, "Array<string>");
        }

        if (awardComponent !== undefined) {
            localVarQueryParameters['award.component'] = ObjectSerializer.serialize(awardComponent, "Array<'affiliate' | 'data analysis' | 'data coordination' | 'functional characterization' | 'mapping' | 'networks' | 'predictive modeling'>");
        }

        if (biomarkers !== undefined) {
            localVarQueryParameters['biomarkers'] = ObjectSerializer.serialize(biomarkers, "Array<string>");
        }

        if (cellularSubPool !== undefined) {
            localVarQueryParameters['cellular_sub_pool'] = ObjectSerializer.serialize(cellularSubPool, "Array<string>");
        }

        if (classifications !== undefined) {
            localVarQueryParameters['classifications'] = ObjectSerializer.serialize(classifications, "Array<string>");
        }

        if (collections !== undefined) {
            localVarQueryParameters['collections'] = ObjectSerializer.serialize(collections, "Array<'ClinGen' | 'ENCODE' | 'GREGoR' | 'IGVF_catalog_beta_v0.1' | 'IGVF_catalog_beta_v0.2' | 'IGVF_catalog_beta_v0.3' | 'IGVF_catalog_beta_v0.4' | 'MaveDB' | 'MPRAbase' | 'Vista'>");
        }

        if (constructLibrarySets !== undefined) {
            localVarQueryParameters['construct_library_sets'] = ObjectSerializer.serialize(constructLibrarySets, "Array<string>");
        }

        if (creationTimestamp !== undefined) {
            localVarQueryParameters['creation_timestamp'] = ObjectSerializer.serialize(creationTimestamp, "Array<string>");
        }

        if (dateObtained !== undefined) {
            localVarQueryParameters['date_obtained'] = ObjectSerializer.serialize(dateObtained, "Array<string>");
        }

        if (dbxrefs !== undefined) {
            localVarQueryParameters['dbxrefs'] = ObjectSerializer.serialize(dbxrefs, "Array<string>");
        }

        if (description !== undefined) {
            localVarQueryParameters['description'] = ObjectSerializer.serialize(description, "Array<string>");
        }

        if (diseaseTermsId !== undefined) {
            localVarQueryParameters['disease_terms.@id'] = ObjectSerializer.serialize(diseaseTermsId, "Array<string>");
        }

        if (diseaseTermsTermName !== undefined) {
            localVarQueryParameters['disease_terms.term_name'] = ObjectSerializer.serialize(diseaseTermsTermName, "Array<string>");
        }

        if (documents !== undefined) {
            localVarQueryParameters['documents'] = ObjectSerializer.serialize(documents, "Array<string>");
        }

        if (donors !== undefined) {
            localVarQueryParameters['donors'] = ObjectSerializer.serialize(donors, "Array<string>");
        }

        if (embryonic !== undefined) {
            localVarQueryParameters['embryonic'] = ObjectSerializer.serialize(embryonic, "Array<boolean>");
        }

        if (fileSetsId !== undefined) {
            localVarQueryParameters['file_sets.@id'] = ObjectSerializer.serialize(fileSetsId, "Array<string>");
        }

        if (fileSetsAccession !== undefined) {
            localVarQueryParameters['file_sets.accession'] = ObjectSerializer.serialize(fileSetsAccession, "Array<string>");
        }

        if (fileSetsAliases !== undefined) {
            localVarQueryParameters['file_sets.aliases'] = ObjectSerializer.serialize(fileSetsAliases, "Array<string>");
        }

        if (fileSetsAssayTermTermName !== undefined) {
            localVarQueryParameters['file_sets.assay_term.term_name'] = ObjectSerializer.serialize(fileSetsAssayTermTermName, "Array<string>");
        }

        if (fileSetsLabTitle !== undefined) {
            localVarQueryParameters['file_sets.lab.title'] = ObjectSerializer.serialize(fileSetsLabTitle, "Array<string>");
        }

        if (fileSetsStatus !== undefined) {
            localVarQueryParameters['file_sets.status'] = ObjectSerializer.serialize(fileSetsStatus, "Array<'in progress' | 'released' | 'deleted' | 'replaced' | 'revoked' | 'archived'>");
        }

        if (fileSetsSummary !== undefined) {
            localVarQueryParameters['file_sets.summary'] = ObjectSerializer.serialize(fileSetsSummary, "Array<string>");
        }

        if (institutionalCertificatesId !== undefined) {
            localVarQueryParameters['institutional_certificates.@id'] = ObjectSerializer.serialize(institutionalCertificatesId, "Array<string>");
        }

        if (institutionalCertificatesCertificateIdentifier !== undefined) {
            localVarQueryParameters['institutional_certificates.certificate_identifier'] = ObjectSerializer.serialize(institutionalCertificatesCertificateIdentifier, "Array<string>");
        }

        if (labId !== undefined) {
            localVarQueryParameters['lab.@id'] = ObjectSerializer.serialize(labId, "Array<string>");
        }

        if (labTitle !== undefined) {
            localVarQueryParameters['lab.title'] = ObjectSerializer.serialize(labTitle, "Array<string>");
        }

        if (lotId !== undefined) {
            localVarQueryParameters['lot_id'] = ObjectSerializer.serialize(lotId, "Array<string>");
        }

        if (lowerBoundAge !== undefined) {
            localVarQueryParameters['lower_bound_age'] = ObjectSerializer.serialize(lowerBoundAge, "Array<number>");
        }

        if (lowerBoundAgeInHours !== undefined) {
            localVarQueryParameters['lower_bound_age_in_hours'] = ObjectSerializer.serialize(lowerBoundAgeInHours, "Array<number>");
        }

        if (modificationsId !== undefined) {
            localVarQueryParameters['modifications.@id'] = ObjectSerializer.serialize(modificationsId, "Array<string>");
        }

        if (modificationsStatus !== undefined) {
            localVarQueryParameters['modifications.status'] = ObjectSerializer.serialize(modificationsStatus, "Array<'archived' | 'deleted' | 'in progress' | 'released'>");
        }

        if (modificationsSummary !== undefined) {
            localVarQueryParameters['modifications.summary'] = ObjectSerializer.serialize(modificationsSummary, "Array<string>");
        }

        if (moi !== undefined) {
            localVarQueryParameters['moi'] = ObjectSerializer.serialize(moi, "Array<number>");
        }

        if (multiplexedInId !== undefined) {
            localVarQueryParameters['multiplexed_in.@id'] = ObjectSerializer.serialize(multiplexedInId, "Array<string>");
        }

        if (multiplexedInAccession !== undefined) {
            localVarQueryParameters['multiplexed_in.accession'] = ObjectSerializer.serialize(multiplexedInAccession, "Array<string>");
        }

        if (notes !== undefined) {
            localVarQueryParameters['notes'] = ObjectSerializer.serialize(notes, "Array<string>");
        }

        if (nucleicAcidDelivery !== undefined) {
            localVarQueryParameters['nucleic_acid_delivery'] = ObjectSerializer.serialize(nucleicAcidDelivery, "Array<'transfection' | 'adenoviral transduction' | 'lentiviral transduction'>");
        }

        if (originOf !== undefined) {
            localVarQueryParameters['origin_of'] = ObjectSerializer.serialize(originOf, "Array<string>");
        }

        if (originatedFrom !== undefined) {
            localVarQueryParameters['originated_from'] = ObjectSerializer.serialize(originatedFrom, "Array<string>");
        }

        if (partOf !== undefined) {
            localVarQueryParameters['part_of'] = ObjectSerializer.serialize(partOf, "Array<string>");
        }

        if (parts !== undefined) {
            localVarQueryParameters['parts'] = ObjectSerializer.serialize(parts, "Array<string>");
        }

        if (pooledFrom !== undefined) {
            localVarQueryParameters['pooled_from'] = ObjectSerializer.serialize(pooledFrom, "Array<string>");
        }

        if (pooledIn !== undefined) {
            localVarQueryParameters['pooled_in'] = ObjectSerializer.serialize(pooledIn, "Array<string>");
        }

        if (productId !== undefined) {
            localVarQueryParameters['product_id'] = ObjectSerializer.serialize(productId, "Array<string>");
        }

        if (protocols !== undefined) {
            localVarQueryParameters['protocols'] = ObjectSerializer.serialize(protocols, "Array<string>");
        }

        if (publicationIdentifiers !== undefined) {
            localVarQueryParameters['publication_identifiers'] = ObjectSerializer.serialize(publicationIdentifiers, "Array<string>");
        }

        if (publications !== undefined) {
            localVarQueryParameters['publications'] = ObjectSerializer.serialize(publications, "Array<string>");
        }

        if (releaseTimestamp !== undefined) {
            localVarQueryParameters['release_timestamp'] = ObjectSerializer.serialize(releaseTimestamp, "Array<string>");
        }

        if (revokeDetail !== undefined) {
            localVarQueryParameters['revoke_detail'] = ObjectSerializer.serialize(revokeDetail, "Array<string>");
        }

        if (sampleTermsId !== undefined) {
            localVarQueryParameters['sample_terms.@id'] = ObjectSerializer.serialize(sampleTermsId, "Array<string>");
        }

        if (sampleTermsTermName !== undefined) {
            localVarQueryParameters['sample_terms.term_name'] = ObjectSerializer.serialize(sampleTermsTermName, "Array<string>");
        }

        if (sex !== undefined) {
            localVarQueryParameters['sex'] = ObjectSerializer.serialize(sex, "Array<'female' | 'male' | 'mixed' | 'unspecified'>");
        }

        if (sortedFractions !== undefined) {
            localVarQueryParameters['sorted_fractions'] = ObjectSerializer.serialize(sortedFractions, "Array<string>");
        }

        if (sortedFromId !== undefined) {
            localVarQueryParameters['sorted_from.@id'] = ObjectSerializer.serialize(sortedFromId, "Array<string>");
        }

        if (sortedFromAccession !== undefined) {
            localVarQueryParameters['sorted_from.accession'] = ObjectSerializer.serialize(sortedFromAccession, "Array<string>");
        }

        if (sortedFromDetail !== undefined) {
            localVarQueryParameters['sorted_from_detail'] = ObjectSerializer.serialize(sortedFromDetail, "Array<string>");
        }

        if (sourcesId !== undefined) {
            localVarQueryParameters['sources.@id'] = ObjectSerializer.serialize(sourcesId, "Array<string>");
        }

        if (startingAmount !== undefined) {
            localVarQueryParameters['starting_amount'] = ObjectSerializer.serialize(startingAmount, "Array<number>");
        }

        if (startingAmountUnits !== undefined) {
            localVarQueryParameters['starting_amount_units'] = ObjectSerializer.serialize(startingAmountUnits, "Array<'cells' | 'cells/ml' | 'g' | 'items' | 'mg' | 'whole animals' | 'whole embryos' | 'μg' | 'ng'>");
        }

        if (status !== undefined) {
            localVarQueryParameters['status'] = ObjectSerializer.serialize(status, "Array<'in progress' | 'released' | 'deleted' | 'replaced' | 'revoked' | 'archived'>");
        }

        if (submittedById !== undefined) {
            localVarQueryParameters['submitted_by.@id'] = ObjectSerializer.serialize(submittedById, "Array<string>");
        }

        if (submittedByTitle !== undefined) {
            localVarQueryParameters['submitted_by.title'] = ObjectSerializer.serialize(submittedByTitle, "Array<string>");
        }

        if (submitterComment !== undefined) {
            localVarQueryParameters['submitter_comment'] = ObjectSerializer.serialize(submitterComment, "Array<string>");
        }

        if (summary !== undefined) {
            localVarQueryParameters['summary'] = ObjectSerializer.serialize(summary, "Array<string>");
        }

        if (taxa !== undefined) {
            localVarQueryParameters['taxa'] = ObjectSerializer.serialize(taxa, "Array<'Homo sapiens' | 'Mus musculus'>");
        }

        if (timePostLibraryDelivery !== undefined) {
            localVarQueryParameters['time_post_library_delivery'] = ObjectSerializer.serialize(timePostLibraryDelivery, "Array<number>");
        }

        if (timePostLibraryDeliveryUnits !== undefined) {
            localVarQueryParameters['time_post_library_delivery_units'] = ObjectSerializer.serialize(timePostLibraryDeliveryUnits, "Array<'minute' | 'hour' | 'day' | 'week' | 'month'>");
        }

        if (treatmentsId !== undefined) {
            localVarQueryParameters['treatments.@id'] = ObjectSerializer.serialize(treatmentsId, "Array<string>");
        }

        if (treatmentsPurpose !== undefined) {
            localVarQueryParameters['treatments.purpose'] = ObjectSerializer.serialize(treatmentsPurpose, "Array<'activation' | 'agonist' | 'antagonist' | 'control' | 'differentiation' | 'de-differentiation' | 'perturbation' | 'selection' | 'stimulation'>");
        }

        if (treatmentsStatus !== undefined) {
            localVarQueryParameters['treatments.status'] = ObjectSerializer.serialize(treatmentsStatus, "Array<'archived' | 'deleted' | 'in progress' | 'released'>");
        }

        if (treatmentsSummary !== undefined) {
            localVarQueryParameters['treatments.summary'] = ObjectSerializer.serialize(treatmentsSummary, "Array<string>");
        }

        if (treatmentsTreatmentType !== undefined) {
            localVarQueryParameters['treatments.treatment_type'] = ObjectSerializer.serialize(treatmentsTreatmentType, "Array<'chemical' | 'protein' | 'environmental'>");
        }

        if (upperBoundAge !== undefined) {
            localVarQueryParameters['upper_bound_age'] = ObjectSerializer.serialize(upperBoundAge, "Array<number>");
        }

        if (upperBoundAgeInHours !== undefined) {
            localVarQueryParameters['upper_bound_age_in_hours'] = ObjectSerializer.serialize(upperBoundAgeInHours, "Array<number>");
        }

        if (url !== undefined) {
            localVarQueryParameters['url'] = ObjectSerializer.serialize(url, "Array<string>");
        }

        if (uuid !== undefined) {
            localVarQueryParameters['uuid'] = ObjectSerializer.serialize(uuid, "Array<string>");
        }

        if (virtual !== undefined) {
            localVarQueryParameters['virtual'] = ObjectSerializer.serialize(virtual, "Array<boolean>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: WholeOrganismResults;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "WholeOrganismResults");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Collection endpoint that accepts various query parameters to filter, sort, and paginate Workflow items. Supports filtering on fields within Workflow items.
     * @summary List items in the Workflow collection.
     * @param frame Constant value. Do not set.
     * @param query Query string for searching.
     * @param limit Maximum number of results to return. Default is 25. Use \&#39;all\&#39; for all results.
     * @param sort Fields to sort results by. Prefix with \&#39;-\&#39; for descending order. Can be repeated for multiple sort fields. Does not work with limit&#x3D;all.
     * @param id Filter by @id
     * @param accession Filter by accession
     * @param aliases Filter by aliases
     * @param alternateAccessions Filter by alternate_accessions
     * @param analysisSteps Filter by analysis_steps
     * @param awardId Filter by award.@id
     * @param awardComponent Filter by award.component
     * @param collections Filter by collections
     * @param creationTimestamp Filter by creation_timestamp
     * @param description Filter by description
     * @param documents Filter by documents
     * @param labId Filter by lab.@id
     * @param labTitle Filter by lab.title
     * @param name Filter by name
     * @param notes Filter by notes
     * @param publicationIdentifiers Filter by publication_identifiers
     * @param publications Filter by publications
     * @param releaseTimestamp Filter by release_timestamp
     * @param revokeDetail Filter by revoke_detail
     * @param sourceUrl Filter by source_url
     * @param standardsPageId Filter by standards_page.@id
     * @param standardsPageTitle Filter by standards_page.title
     * @param status Filter by status
     * @param submittedById Filter by submitted_by.@id
     * @param submittedByTitle Filter by submitted_by.title
     * @param submitterComment Filter by submitter_comment
     * @param summary Filter by summary
     * @param uuid Filter by uuid
     * @param workflowRepositories Filter by workflow_repositories
     * @param workflowVersion Filter by workflow_version
     */
    public async workflows (frame: 'object', query?: string, limit?: Limit, sort?: Array<string>, id?: Array<string>, accession?: Array<string>, aliases?: Array<string>, alternateAccessions?: Array<string>, analysisSteps?: Array<string>, awardId?: Array<string>, awardComponent?: Array<'affiliate' | 'data analysis' | 'data coordination' | 'functional characterization' | 'mapping' | 'networks' | 'predictive modeling'>, collections?: Array<'ClinGen' | 'ENCODE' | 'GREGoR' | 'IGVF_catalog_beta_v0.1' | 'IGVF_catalog_beta_v0.2' | 'IGVF_catalog_beta_v0.3' | 'IGVF_catalog_beta_v0.4' | 'MaveDB' | 'MPRAbase' | 'Vista'>, creationTimestamp?: Array<string>, description?: Array<string>, documents?: Array<string>, labId?: Array<string>, labTitle?: Array<string>, name?: Array<string>, notes?: Array<string>, publicationIdentifiers?: Array<string>, publications?: Array<string>, releaseTimestamp?: Array<string>, revokeDetail?: Array<string>, sourceUrl?: Array<string>, standardsPageId?: Array<string>, standardsPageTitle?: Array<string>, status?: Array<'in progress' | 'released' | 'deleted' | 'replaced' | 'revoked' | 'archived'>, submittedById?: Array<string>, submittedByTitle?: Array<string>, submitterComment?: Array<string>, summary?: Array<string>, uuid?: Array<string>, workflowRepositories?: Array<string>, workflowVersion?: Array<number>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: WorkflowResults;  }> {
        const localVarPath = this.basePath + '/workflows/@@listing';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'frame' is not null or undefined
        if (frame === null || frame === undefined) {
            throw new Error('Required parameter frame was null or undefined when calling workflows.');
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (frame !== undefined) {
            localVarQueryParameters['frame'] = ObjectSerializer.serialize(frame, "'object'");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "Limit");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "Array<string>");
        }

        if (id !== undefined) {
            localVarQueryParameters['@id'] = ObjectSerializer.serialize(id, "Array<string>");
        }

        if (accession !== undefined) {
            localVarQueryParameters['accession'] = ObjectSerializer.serialize(accession, "Array<string>");
        }

        if (aliases !== undefined) {
            localVarQueryParameters['aliases'] = ObjectSerializer.serialize(aliases, "Array<string>");
        }

        if (alternateAccessions !== undefined) {
            localVarQueryParameters['alternate_accessions'] = ObjectSerializer.serialize(alternateAccessions, "Array<string>");
        }

        if (analysisSteps !== undefined) {
            localVarQueryParameters['analysis_steps'] = ObjectSerializer.serialize(analysisSteps, "Array<string>");
        }

        if (awardId !== undefined) {
            localVarQueryParameters['award.@id'] = ObjectSerializer.serialize(awardId, "Array<string>");
        }

        if (awardComponent !== undefined) {
            localVarQueryParameters['award.component'] = ObjectSerializer.serialize(awardComponent, "Array<'affiliate' | 'data analysis' | 'data coordination' | 'functional characterization' | 'mapping' | 'networks' | 'predictive modeling'>");
        }

        if (collections !== undefined) {
            localVarQueryParameters['collections'] = ObjectSerializer.serialize(collections, "Array<'ClinGen' | 'ENCODE' | 'GREGoR' | 'IGVF_catalog_beta_v0.1' | 'IGVF_catalog_beta_v0.2' | 'IGVF_catalog_beta_v0.3' | 'IGVF_catalog_beta_v0.4' | 'MaveDB' | 'MPRAbase' | 'Vista'>");
        }

        if (creationTimestamp !== undefined) {
            localVarQueryParameters['creation_timestamp'] = ObjectSerializer.serialize(creationTimestamp, "Array<string>");
        }

        if (description !== undefined) {
            localVarQueryParameters['description'] = ObjectSerializer.serialize(description, "Array<string>");
        }

        if (documents !== undefined) {
            localVarQueryParameters['documents'] = ObjectSerializer.serialize(documents, "Array<string>");
        }

        if (labId !== undefined) {
            localVarQueryParameters['lab.@id'] = ObjectSerializer.serialize(labId, "Array<string>");
        }

        if (labTitle !== undefined) {
            localVarQueryParameters['lab.title'] = ObjectSerializer.serialize(labTitle, "Array<string>");
        }

        if (name !== undefined) {
            localVarQueryParameters['name'] = ObjectSerializer.serialize(name, "Array<string>");
        }

        if (notes !== undefined) {
            localVarQueryParameters['notes'] = ObjectSerializer.serialize(notes, "Array<string>");
        }

        if (publicationIdentifiers !== undefined) {
            localVarQueryParameters['publication_identifiers'] = ObjectSerializer.serialize(publicationIdentifiers, "Array<string>");
        }

        if (publications !== undefined) {
            localVarQueryParameters['publications'] = ObjectSerializer.serialize(publications, "Array<string>");
        }

        if (releaseTimestamp !== undefined) {
            localVarQueryParameters['release_timestamp'] = ObjectSerializer.serialize(releaseTimestamp, "Array<string>");
        }

        if (revokeDetail !== undefined) {
            localVarQueryParameters['revoke_detail'] = ObjectSerializer.serialize(revokeDetail, "Array<string>");
        }

        if (sourceUrl !== undefined) {
            localVarQueryParameters['source_url'] = ObjectSerializer.serialize(sourceUrl, "Array<string>");
        }

        if (standardsPageId !== undefined) {
            localVarQueryParameters['standards_page.@id'] = ObjectSerializer.serialize(standardsPageId, "Array<string>");
        }

        if (standardsPageTitle !== undefined) {
            localVarQueryParameters['standards_page.title'] = ObjectSerializer.serialize(standardsPageTitle, "Array<string>");
        }

        if (status !== undefined) {
            localVarQueryParameters['status'] = ObjectSerializer.serialize(status, "Array<'in progress' | 'released' | 'deleted' | 'replaced' | 'revoked' | 'archived'>");
        }

        if (submittedById !== undefined) {
            localVarQueryParameters['submitted_by.@id'] = ObjectSerializer.serialize(submittedById, "Array<string>");
        }

        if (submittedByTitle !== undefined) {
            localVarQueryParameters['submitted_by.title'] = ObjectSerializer.serialize(submittedByTitle, "Array<string>");
        }

        if (submitterComment !== undefined) {
            localVarQueryParameters['submitter_comment'] = ObjectSerializer.serialize(submitterComment, "Array<string>");
        }

        if (summary !== undefined) {
            localVarQueryParameters['summary'] = ObjectSerializer.serialize(summary, "Array<string>");
        }

        if (uuid !== undefined) {
            localVarQueryParameters['uuid'] = ObjectSerializer.serialize(uuid, "Array<string>");
        }

        if (workflowRepositories !== undefined) {
            localVarQueryParameters['workflow_repositories'] = ObjectSerializer.serialize(workflowRepositories, "Array<string>");
        }

        if (workflowVersion !== undefined) {
            localVarQueryParameters['workflow_version'] = ObjectSerializer.serialize(workflowVersion, "Array<number>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: WorkflowResults;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "WorkflowResults");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
}
