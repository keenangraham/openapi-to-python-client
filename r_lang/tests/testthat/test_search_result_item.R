# Automatically generated by openapi-generator (https://openapi-generator.tech)
# Please update as you see appropriate

context("Test SearchResultItem")

model_instance <- SearchResultItem$new()

test_that("schema_version", {
  # tests for the property `schema_version` (character)
  # The version of the JSON schema that the server uses to validate the object.

  # uncomment below to test the property
  #expect_equal(model.instance$`schema_version`, "EXPECTED_RESULT")
})

test_that("uuid", {
  # tests for the property `uuid` (character)
  # The unique identifier associated with every object.

  # uncomment below to test the property
  #expect_equal(model.instance$`uuid`, "EXPECTED_RESULT")
})

test_that("notes", {
  # tests for the property `notes` (character)
  # DACC internal notes.

  # uncomment below to test the property
  #expect_equal(model.instance$`notes`, "EXPECTED_RESULT")
})

test_that("aliases", {
  # tests for the property `aliases` (set[character])
  # Lab specific identifiers to reference an object.

  # uncomment below to test the property
  #expect_equal(model.instance$`aliases`, "EXPECTED_RESULT")
})

test_that("creation_timestamp", {
  # tests for the property `creation_timestamp` (character)
  # The date the object was created.

  # uncomment below to test the property
  #expect_equal(model.instance$`creation_timestamp`, "EXPECTED_RESULT")
})

test_that("submitted_by", {
  # tests for the property `submitted_by` (character)
  # The user who submitted the object.

  # uncomment below to test the property
  #expect_equal(model.instance$`submitted_by`, "EXPECTED_RESULT")
})

test_that("submitter_comment", {
  # tests for the property `submitter_comment` (character)
  # Additional information specified by the submitter to be displayed as a comment on the portal.

  # uncomment below to test the property
  #expect_equal(model.instance$`submitter_comment`, "EXPECTED_RESULT")
})

test_that("description", {
  # tests for the property `description` (character)
  # A plain text description of the object.

  # uncomment below to test the property
  #expect_equal(model.instance$`description`, "EXPECTED_RESULT")
})

test_that("status", {
  # tests for the property `status` (character)
  # The status of the metadata object.

  # uncomment below to test the property
  #expect_equal(model.instance$`status`, "EXPECTED_RESULT")
})

test_that("user", {
  # tests for the property `user` (character)
  # The user that is assigned to this access key.

  # uncomment below to test the property
  #expect_equal(model.instance$`user`, "EXPECTED_RESULT")
})

test_that("access_key_id", {
  # tests for the property `access_key_id` (character)
  # An access key.

  # uncomment below to test the property
  #expect_equal(model.instance$`access_key_id`, "EXPECTED_RESULT")
})

test_that("secret_access_key_hash", {
  # tests for the property `secret_access_key_hash` (character)
  # A secret access key.

  # uncomment below to test the property
  #expect_equal(model.instance$`secret_access_key_hash`, "EXPECTED_RESULT")
})

test_that("@id", {
  # tests for the property `@id` (character)

  # uncomment below to test the property
  #expect_equal(model.instance$`@id`, "EXPECTED_RESULT")
})

test_that("@type", {
  # tests for the property `@type` (array[character])

  # uncomment below to test the property
  #expect_equal(model.instance$`@type`, "EXPECTED_RESULT")
})

test_that("summary", {
  # tests for the property `summary` (character)
  # A summary of the object.

  # uncomment below to test the property
  #expect_equal(model.instance$`summary`, "EXPECTED_RESULT")
})

test_that("release_timestamp", {
  # tests for the property `release_timestamp` (character)
  # The date the object was released.

  # uncomment below to test the property
  #expect_equal(model.instance$`release_timestamp`, "EXPECTED_RESULT")
})

test_that("lab", {
  # tests for the property `lab` (character)
  # Lab associated with the submission.

  # uncomment below to test the property
  #expect_equal(model.instance$`lab`, "EXPECTED_RESULT")
})

test_that("award", {
  # tests for the property `award` (character)
  # Grant associated with the submission.

  # uncomment below to test the property
  #expect_equal(model.instance$`award`, "EXPECTED_RESULT")
})

test_that("analysis_step_types", {
  # tests for the property `analysis_step_types` (set[character])
  # The classification of the software.

  # uncomment below to test the property
  #expect_equal(model.instance$`analysis_step_types`, "EXPECTED_RESULT")
})

test_that("step_label", {
  # tests for the property `step_label` (character)
  # Unique lowercased label of the analysis step that includes the relevant assays, the software used, and the purpose of the step, e.g. rampage-grit-peak-calling-step

  # uncomment below to test the property
  #expect_equal(model.instance$`step_label`, "EXPECTED_RESULT")
})

test_that("title", {
  # tests for the property `title` (character)
  # The full name of the user.

  # uncomment below to test the property
  #expect_equal(model.instance$`title`, "EXPECTED_RESULT")
})

test_that("workflow", {
  # tests for the property `workflow` (character)
  # The computational workflow in which this analysis step belongs.

  # uncomment below to test the property
  #expect_equal(model.instance$`workflow`, "EXPECTED_RESULT")
})

test_that("parents", {
  # tests for the property `parents` (set[character])
  # The precursor steps.

  # uncomment below to test the property
  #expect_equal(model.instance$`parents`, "EXPECTED_RESULT")
})

test_that("input_content_types", {
  # tests for the property `input_content_types` (set[character])
  # The content types used as input for the analysis step.

  # uncomment below to test the property
  #expect_equal(model.instance$`input_content_types`, "EXPECTED_RESULT")
})

test_that("output_content_types", {
  # tests for the property `output_content_types` (set[character])
  # The content types produced as output by the analysis step.

  # uncomment below to test the property
  #expect_equal(model.instance$`output_content_types`, "EXPECTED_RESULT")
})

test_that("name", {
  # tests for the property `name` (character)
  # The preferred viewable name of the workflow.

  # uncomment below to test the property
  #expect_equal(model.instance$`name`, "EXPECTED_RESULT")
})

test_that("analysis_step", {
  # tests for the property `analysis_step` (character)
  # The analysis step which this version belongs to.

  # uncomment below to test the property
  #expect_equal(model.instance$`analysis_step`, "EXPECTED_RESULT")
})

test_that("software_versions", {
  # tests for the property `software_versions` (set[character])
  # The software versions associated with this publication.

  # uncomment below to test the property
  #expect_equal(model.instance$`software_versions`, "EXPECTED_RESULT")
})

test_that("url", {
  # tests for the property `url` (character)
  # An external resource with additional information.

  # uncomment below to test the property
  #expect_equal(model.instance$`url`, "EXPECTED_RESULT")
})

test_that("start_date", {
  # tests for the property `start_date` (character)
  # The date when the award begins.

  # uncomment below to test the property
  #expect_equal(model.instance$`start_date`, "EXPECTED_RESULT")
})

test_that("end_date", {
  # tests for the property `end_date` (character)
  # The date when the award concludes.

  # uncomment below to test the property
  #expect_equal(model.instance$`end_date`, "EXPECTED_RESULT")
})

test_that("pis", {
  # tests for the property `pis` (set[character])
  # Principal Investigator(s) of the grant.

  # uncomment below to test the property
  #expect_equal(model.instance$`pis`, "EXPECTED_RESULT")
})

test_that("contact_pi", {
  # tests for the property `contact_pi` (character)
  # The contact Principal Investigator of the grant.

  # uncomment below to test the property
  #expect_equal(model.instance$`contact_pi`, "EXPECTED_RESULT")
})

test_that("project", {
  # tests for the property `project` (character)
  # The collection of biological data related to a single initiative, originating from a consortium.

  # uncomment below to test the property
  #expect_equal(model.instance$`project`, "EXPECTED_RESULT")
})

test_that("viewing_group", {
  # tests for the property `viewing_group` (character)
  # The group that determines which set of data the user has permission to view.

  # uncomment below to test the property
  #expect_equal(model.instance$`viewing_group`, "EXPECTED_RESULT")
})

test_that("component", {
  # tests for the property `component` (character)
  # The project component the award is associated with.

  # uncomment below to test the property
  #expect_equal(model.instance$`component`, "EXPECTED_RESULT")
})

test_that("classification", {
  # tests for the property `classification` (character)
  # Sample specific biomarker.

  # uncomment below to test the property
  #expect_equal(model.instance$`classification`, "EXPECTED_RESULT")
})

test_that("quantification", {
  # tests for the property `quantification` (character)
  # The biomarker association to the biosample, disease or other condition.  This can be the absence of the biomarker or the presence of the biomarker in some low, intermediate or high quantity.

  # uncomment below to test the property
  #expect_equal(model.instance$`quantification`, "EXPECTED_RESULT")
})

test_that("synonyms", {
  # tests for the property `synonyms` (set[character])
  # Synonyms for the term that have been recorded in an ontology.

  # uncomment below to test the property
  #expect_equal(model.instance$`synonyms`, "EXPECTED_RESULT")
})

test_that("gene", {
  # tests for the property `gene` (set[character])
  # ENSEMBL GeneID of official nomenclature approved gene. The GeneID does not include the current version number suffix.

  # uncomment below to test the property
  #expect_equal(model.instance$`gene`, "EXPECTED_RESULT")
})

test_that("name_quantification", {
  # tests for the property `name_quantification` (character)
  # A concatenation of the name and quantification of the biomarker.

  # uncomment below to test the property
  #expect_equal(model.instance$`name_quantification`, "EXPECTED_RESULT")
})

test_that("biomarker_for", {
  # tests for the property `biomarker_for` (set[character])
  # The samples which have been confirmed to have this biomarker.

  # uncomment below to test the property
  #expect_equal(model.instance$`biomarker_for`, "EXPECTED_RESULT")
})

test_that("attachment", {
  # tests for the property `attachment` (Attachment)

  # uncomment below to test the property
  #expect_equal(model.instance$`attachment`, "EXPECTED_RESULT")
})

test_that("document_type", {
  # tests for the property `document_type` (character)
  # The category that best describes the document.

  # uncomment below to test the property
  #expect_equal(model.instance$`document_type`, "EXPECTED_RESULT")
})

test_that("characterization_method", {
  # tests for the property `characterization_method` (character)
  # The method used for the characterization.

  # uncomment below to test the property
  #expect_equal(model.instance$`characterization_method`, "EXPECTED_RESULT")
})

test_that("urls", {
  # tests for the property `urls` (set[character])
  # Link to the institutional certification form.

  # uncomment below to test the property
  #expect_equal(model.instance$`urls`, "EXPECTED_RESULT")
})

test_that("taxa", {
  # tests for the property `taxa` (character)
  # The species of the organism.

  # uncomment below to test the property
  #expect_equal(model.instance$`taxa`, "EXPECTED_RESULT")
})

test_that("publications", {
  # tests for the property `publications` (set[character])
  # The publications associated with this object.

  # uncomment below to test the property
  #expect_equal(model.instance$`publications`, "EXPECTED_RESULT")
})

test_that("publication_identifiers", {
  # tests for the property `publication_identifiers` (set[character])
  # The publication identifiers that provide more information about the object.

  # uncomment below to test the property
  #expect_equal(model.instance$`publication_identifiers`, "EXPECTED_RESULT")
})

test_that("documents", {
  # tests for the property `documents` (set[character])
  # Documents that provide additional information (not data file).

  # uncomment below to test the property
  #expect_equal(model.instance$`documents`, "EXPECTED_RESULT")
})

test_that("accession", {
  # tests for the property `accession` (character)
  # A unique identifier to be used to reference the object prefixed with IGVF.

  # uncomment below to test the property
  #expect_equal(model.instance$`accession`, "EXPECTED_RESULT")
})

test_that("alternate_accessions", {
  # tests for the property `alternate_accessions` (set[character])
  # Accessions previously assigned to objects that have been merged with this object.

  # uncomment below to test the property
  #expect_equal(model.instance$`alternate_accessions`, "EXPECTED_RESULT")
})

test_that("collections", {
  # tests for the property `collections` (set[character])
  # Some samples are part of particular data collections.

  # uncomment below to test the property
  #expect_equal(model.instance$`collections`, "EXPECTED_RESULT")
})

test_that("revoke_detail", {
  # tests for the property `revoke_detail` (character)
  # Explanation of why an object was transitioned to the revoked status.

  # uncomment below to test the property
  #expect_equal(model.instance$`revoke_detail`, "EXPECTED_RESULT")
})

test_that("dbxrefs", {
  # tests for the property `dbxrefs` (set[character])
  # Biosample identifiers from external resources, such as Biosample database or Cellosaurus.

  # uncomment below to test the property
  #expect_equal(model.instance$`dbxrefs`, "EXPECTED_RESULT")
})

test_that("sex", {
  # tests for the property `sex` (character)

  # uncomment below to test the property
  #expect_equal(model.instance$`sex`, "EXPECTED_RESULT")
})

test_that("phenotypic_features", {
  # tests for the property `phenotypic_features` (set[character])
  # A list of associated phenotypic features of the donor.

  # uncomment below to test the property
  #expect_equal(model.instance$`phenotypic_features`, "EXPECTED_RESULT")
})

test_that("virtual", {
  # tests for the property `virtual` (character)
  # Virtual samples are not representing actual physical entities from experiments, but rather capturing metadata about hypothetical samples that the reported analysis results are relevant for.

  # uncomment below to test the property
  #expect_equal(model.instance$`virtual`, "EXPECTED_RESULT")
})

test_that("related_donors", {
  # tests for the property `related_donors` (set[RelatedDonor])
  # Familial relations of this donor.

  # uncomment below to test the property
  #expect_equal(model.instance$`related_donors`, "EXPECTED_RESULT")
})

test_that("ethnicities", {
  # tests for the property `ethnicities` (set[character])
  # Ethnicity of the donor.

  # uncomment below to test the property
  #expect_equal(model.instance$`ethnicities`, "EXPECTED_RESULT")
})

test_that("human_donor_identifiers", {
  # tests for the property `human_donor_identifiers` (set[character])
  # Identifiers of this human donor.

  # uncomment below to test the property
  #expect_equal(model.instance$`human_donor_identifiers`, "EXPECTED_RESULT")
})

test_that("sources", {
  # tests for the property `sources` (set[character])
  # The originating lab(s) or vendor(s).

  # uncomment below to test the property
  #expect_equal(model.instance$`sources`, "EXPECTED_RESULT")
})

test_that("lot_id", {
  # tests for the property `lot_id` (character)
  # The lot identifier provided by the originating lab or vendor.

  # uncomment below to test the property
  #expect_equal(model.instance$`lot_id`, "EXPECTED_RESULT")
})

test_that("product_id", {
  # tests for the property `product_id` (character)
  # The product identifier provided by the originating lab or vendor.

  # uncomment below to test the property
  #expect_equal(model.instance$`product_id`, "EXPECTED_RESULT")
})

test_that("strain_background", {
  # tests for the property `strain_background` (character)
  # The specific parent strain designation of a non-human donor.

  # uncomment below to test the property
  #expect_equal(model.instance$`strain_background`, "EXPECTED_RESULT")
})

test_that("strain", {
  # tests for the property `strain` (character)
  # The specific strain designation of a non-human donor.

  # uncomment below to test the property
  #expect_equal(model.instance$`strain`, "EXPECTED_RESULT")
})

test_that("genotype", {
  # tests for the property `genotype` (character)
  # The genotype of the strain according to accepted nomenclature conventions.

  # uncomment below to test the property
  #expect_equal(model.instance$`genotype`, "EXPECTED_RESULT")
})

test_that("individual_rodent", {
  # tests for the property `individual_rodent` (character)
  # This rodent donor represents an individual rodent.

  # uncomment below to test the property
  #expect_equal(model.instance$`individual_rodent`, "EXPECTED_RESULT")
})

test_that("rodent_identifier", {
  # tests for the property `rodent_identifier` (character)
  # The identifier for this individual rodent donor.

  # uncomment below to test the property
  #expect_equal(model.instance$`rodent_identifier`, "EXPECTED_RESULT")
})

test_that("controlled_access", {
  # tests for the property `controlled_access` (character)
  # Indicator of whether the samples are under controlled access.

  # uncomment below to test the property
  #expect_equal(model.instance$`controlled_access`, "EXPECTED_RESULT")
})

test_that("anvil_url", {
  # tests for the property `anvil_url` (character)
  # URL linking to the controlled access file that has been deposited at AnVIL workspace.

  # uncomment below to test the property
  #expect_equal(model.instance$`anvil_url`, "EXPECTED_RESULT")
})

test_that("transcriptome_annotation", {
  # tests for the property `transcriptome_annotation` (character)
  # The annotation and version of the reference resource.

  # uncomment below to test the property
  #expect_equal(model.instance$`transcriptome_annotation`, "EXPECTED_RESULT")
})

test_that("assembly", {
  # tests for the property `assembly` (character)
  # Genome assembly applicable for the tabular data.

  # uncomment below to test the property
  #expect_equal(model.instance$`assembly`, "EXPECTED_RESULT")
})

test_that("reference_files", {
  # tests for the property `reference_files` (set[character])
  # Link to the reference files used to generate this file.

  # uncomment below to test the property
  #expect_equal(model.instance$`reference_files`, "EXPECTED_RESULT")
})

test_that("analysis_step_version", {
  # tests for the property `analysis_step_version` (character)
  # The analysis step version of the file.

  # uncomment below to test the property
  #expect_equal(model.instance$`analysis_step_version`, "EXPECTED_RESULT")
})

test_that("content_md5sum", {
  # tests for the property `content_md5sum` (character)
  # The MD5sum of the uncompressed file.

  # uncomment below to test the property
  #expect_equal(model.instance$`content_md5sum`, "EXPECTED_RESULT")
})

test_that("content_type", {
  # tests for the property `content_type` (character)
  # The type of content in the file.

  # uncomment below to test the property
  #expect_equal(model.instance$`content_type`, "EXPECTED_RESULT")
})

test_that("derived_from", {
  # tests for the property `derived_from` (set[character])
  # The files participating as inputs into software to produce this output file.

  # uncomment below to test the property
  #expect_equal(model.instance$`derived_from`, "EXPECTED_RESULT")
})

test_that("file_format", {
  # tests for the property `file_format` (character)
  # The file format or extension of the file.

  # uncomment below to test the property
  #expect_equal(model.instance$`file_format`, "EXPECTED_RESULT")
})

test_that("file_format_specifications", {
  # tests for the property `file_format_specifications` (set[character])
  # Document that further explains the file format.

  # uncomment below to test the property
  #expect_equal(model.instance$`file_format_specifications`, "EXPECTED_RESULT")
})

test_that("file_set", {
  # tests for the property `file_set` (character)
  # The file set that this file belongs to.

  # uncomment below to test the property
  #expect_equal(model.instance$`file_set`, "EXPECTED_RESULT")
})

test_that("file_size", {
  # tests for the property `file_size` (integer)
  # File size specified in bytes.

  # uncomment below to test the property
  #expect_equal(model.instance$`file_size`, "EXPECTED_RESULT")
})

test_that("md5sum", {
  # tests for the property `md5sum` (character)
  # The md5sum of the file being transferred.

  # uncomment below to test the property
  #expect_equal(model.instance$`md5sum`, "EXPECTED_RESULT")
})

test_that("submitted_file_name", {
  # tests for the property `submitted_file_name` (character)
  # Original name of the file.

  # uncomment below to test the property
  #expect_equal(model.instance$`submitted_file_name`, "EXPECTED_RESULT")
})

test_that("upload_status", {
  # tests for the property `upload_status` (character)
  # The upload/validation status of the file.

  # uncomment below to test the property
  #expect_equal(model.instance$`upload_status`, "EXPECTED_RESULT")
})

test_that("validation_error_detail", {
  # tests for the property `validation_error_detail` (character)
  # Explanation of why the file failed the automated content checks.

  # uncomment below to test the property
  #expect_equal(model.instance$`validation_error_detail`, "EXPECTED_RESULT")
})

test_that("redacted", {
  # tests for the property `redacted` (character)
  # Indicates whether the alignments data have been sanitized (redacted) to prevent leakage of private and potentially identifying genomic information.

  # uncomment below to test the property
  #expect_equal(model.instance$`redacted`, "EXPECTED_RESULT")
})

test_that("filtered", {
  # tests for the property `filtered` (character)
  # Indicates if the signal file is filtered.

  # uncomment below to test the property
  #expect_equal(model.instance$`filtered`, "EXPECTED_RESULT")
})

test_that("integrated_in", {
  # tests for the property `integrated_in` (set[character])
  # Construct library set(s) that this file was used for in insert design.

  # uncomment below to test the property
  #expect_equal(model.instance$`integrated_in`, "EXPECTED_RESULT")
})

test_that("input_file_for", {
  # tests for the property `input_file_for` (set[character])
  # The files which are derived from this file.

  # uncomment below to test the property
  #expect_equal(model.instance$`input_file_for`, "EXPECTED_RESULT")
})

test_that("gene_list_for", {
  # tests for the property `gene_list_for` (set[character])
  # File Set(s) that this file is a gene list for.

  # uncomment below to test the property
  #expect_equal(model.instance$`gene_list_for`, "EXPECTED_RESULT")
})

test_that("loci_list_for", {
  # tests for the property `loci_list_for` (set[character])
  # File Set(s) that this file is a loci list for.

  # uncomment below to test the property
  #expect_equal(model.instance$`loci_list_for`, "EXPECTED_RESULT")
})

test_that("href", {
  # tests for the property `href` (character)
  # The download path to obtain file.

  # uncomment below to test the property
  #expect_equal(model.instance$`href`, "EXPECTED_RESULT")
})

test_that("s3_uri", {
  # tests for the property `s3_uri` (character)
  # The S3 URI of public file object.

  # uncomment below to test the property
  #expect_equal(model.instance$`s3_uri`, "EXPECTED_RESULT")
})

test_that("upload_credentials", {
  # tests for the property `upload_credentials` (object)
  # The upload credentials for S3 to submit the file content.

  # uncomment below to test the property
  #expect_equal(model.instance$`upload_credentials`, "EXPECTED_RESULT")
})

test_that("content_summary", {
  # tests for the property `content_summary` (character)
  # A summary of the data in the signal file.

  # uncomment below to test the property
  #expect_equal(model.instance$`content_summary`, "EXPECTED_RESULT")
})

test_that("seqspec_of", {
  # tests for the property `seqspec_of` (set[character])
  # Sequence files this file is a seqspec of.

  # uncomment below to test the property
  #expect_equal(model.instance$`seqspec_of`, "EXPECTED_RESULT")
})

test_that("file_format_type", {
  # tests for the property `file_format_type` (character)
  # The subtype of bed files.

  # uncomment below to test the property
  #expect_equal(model.instance$`file_format_type`, "EXPECTED_RESULT")
})

test_that("dimension1", {
  # tests for the property `dimension1` (character)
  # First dimension of the matrix.

  # uncomment below to test the property
  #expect_equal(model.instance$`dimension1`, "EXPECTED_RESULT")
})

test_that("dimension2", {
  # tests for the property `dimension2` (character)
  # Second dimension of the matrix.

  # uncomment below to test the property
  #expect_equal(model.instance$`dimension2`, "EXPECTED_RESULT")
})

test_that("source_url", {
  # tests for the property `source_url` (character)
  # An external resource to the code base of the workflow in github.

  # uncomment below to test the property
  #expect_equal(model.instance$`source_url`, "EXPECTED_RESULT")
})

test_that("external", {
  # tests for the property `external` (character)
  # Indicates whether the file was obtained from an external, non-IGVF source.

  # uncomment below to test the property
  #expect_equal(model.instance$`external`, "EXPECTED_RESULT")
})

test_that("external_id", {
  # tests for the property `external_id` (character)
  # A unique identifier for the file at its original source.

  # uncomment below to test the property
  #expect_equal(model.instance$`external_id`, "EXPECTED_RESULT")
})

test_that("flowcell_id", {
  # tests for the property `flowcell_id` (character)
  # The alphanumeric identifier for the flowcell of a sequencing machine.

  # uncomment below to test the property
  #expect_equal(model.instance$`flowcell_id`, "EXPECTED_RESULT")
})

test_that("lane", {
  # tests for the property `lane` (integer)
  # An integer identifying the lane of a sequencing machine.

  # uncomment below to test the property
  #expect_equal(model.instance$`lane`, "EXPECTED_RESULT")
})

test_that("read_count", {
  # tests for the property `read_count` (integer)
  # Number of reads in a fastq file.

  # uncomment below to test the property
  #expect_equal(model.instance$`read_count`, "EXPECTED_RESULT")
})

test_that("minimum_read_length", {
  # tests for the property `minimum_read_length` (integer)
  # For high-throughput sequencing, the minimum number of contiguous nucleotides determined by sequencing.

  # uncomment below to test the property
  #expect_equal(model.instance$`minimum_read_length`, "EXPECTED_RESULT")
})

test_that("maximum_read_length", {
  # tests for the property `maximum_read_length` (integer)
  # For high-throughput sequencing, the maximum number of contiguous nucleotides determined by sequencing.

  # uncomment below to test the property
  #expect_equal(model.instance$`maximum_read_length`, "EXPECTED_RESULT")
})

test_that("mean_read_length", {
  # tests for the property `mean_read_length` (numeric)
  # For high-throughput sequencing, the mean number of contiguous nucleotides determined by sequencing.

  # uncomment below to test the property
  #expect_equal(model.instance$`mean_read_length`, "EXPECTED_RESULT")
})

test_that("sequencing_platform", {
  # tests for the property `sequencing_platform` (character)
  # The measurement device used to produce sequencing data.

  # uncomment below to test the property
  #expect_equal(model.instance$`sequencing_platform`, "EXPECTED_RESULT")
})

test_that("sequencing_kit", {
  # tests for the property `sequencing_kit` (character)
  # A reagent kit used with a library to prepare it for sequencing.

  # uncomment below to test the property
  #expect_equal(model.instance$`sequencing_kit`, "EXPECTED_RESULT")
})

test_that("sequencing_run", {
  # tests for the property `sequencing_run` (integer)
  # An ordinal number indicating which sequencing run of the associated library that the file belongs to.

  # uncomment below to test the property
  #expect_equal(model.instance$`sequencing_run`, "EXPECTED_RESULT")
})

test_that("illumina_read_type", {
  # tests for the property `illumina_read_type` (character)
  # The read type of the file. Relevant only for files produced using an Illumina sequencing platform.

  # uncomment below to test the property
  #expect_equal(model.instance$`illumina_read_type`, "EXPECTED_RESULT")
})

test_that("index", {
  # tests for the property `index` (character)
  # An Illumina index associated with the file.

  # uncomment below to test the property
  #expect_equal(model.instance$`index`, "EXPECTED_RESULT")
})

test_that("seqspecs", {
  # tests for the property `seqspecs` (set[character])
  # Link(s) to the associated seqspec YAML configuration file(s).

  # uncomment below to test the property
  #expect_equal(model.instance$`seqspecs`, "EXPECTED_RESULT")
})

test_that("strand_specificity", {
  # tests for the property `strand_specificity` (character)
  # The strandedness of the signal file: plus, minus, or unstranded.

  # uncomment below to test the property
  #expect_equal(model.instance$`strand_specificity`, "EXPECTED_RESULT")
})

test_that("normalized", {
  # tests for the property `normalized` (character)
  # Indicates if the signal file is normalized.

  # uncomment below to test the property
  #expect_equal(model.instance$`normalized`, "EXPECTED_RESULT")
})

test_that("start_view_position", {
  # tests for the property `start_view_position` (character)
  # The 0-based coordinate for the default starting position when viewing the signal in a genome browser.

  # uncomment below to test the property
  #expect_equal(model.instance$`start_view_position`, "EXPECTED_RESULT")
})

test_that("input_file_sets", {
  # tests for the property `input_file_sets` (set[character])
  # The file set(s) required for this prediction set.

  # uncomment below to test the property
  #expect_equal(model.instance$`input_file_sets`, "EXPECTED_RESULT")
})

test_that("samples", {
  # tests for the property `samples` (set[character])
  # The samples associated with this publication.

  # uncomment below to test the property
  #expect_equal(model.instance$`samples`, "EXPECTED_RESULT")
})

test_that("donors", {
  # tests for the property `donors` (set[character])
  # Donor(s) the sample was derived from.

  # uncomment below to test the property
  #expect_equal(model.instance$`donors`, "EXPECTED_RESULT")
})

test_that("file_set_type", {
  # tests for the property `file_set_type` (character)
  # The category that best describes this prediction set.

  # uncomment below to test the property
  #expect_equal(model.instance$`file_set_type`, "EXPECTED_RESULT")
})

test_that("files", {
  # tests for the property `files` (set[character])
  # The files associated with this file set.

  # uncomment below to test the property
  #expect_equal(model.instance$`files`, "EXPECTED_RESULT")
})

test_that("control_for", {
  # tests for the property `control_for` (set[character])
  # The file sets for which this file set is a control.

  # uncomment below to test the property
  #expect_equal(model.instance$`control_for`, "EXPECTED_RESULT")
})

test_that("submitted_files_timestamp", {
  # tests for the property `submitted_files_timestamp` (character)
  # The timestamp the first file object in the file_set or associated auxiliary sets was created.

  # uncomment below to test the property
  #expect_equal(model.instance$`submitted_files_timestamp`, "EXPECTED_RESULT")
})

test_that("input_file_set_for", {
  # tests for the property `input_file_set_for` (set[character])
  # The file sets that use this file set as an input.

  # uncomment below to test the property
  #expect_equal(model.instance$`input_file_set_for`, "EXPECTED_RESULT")
})

test_that("assay_titles", {
  # tests for the property `assay_titles` (set[character])
  # Title(s) of assays that produced data analyzed in the analysis set.

  # uncomment below to test the property
  #expect_equal(model.instance$`assay_titles`, "EXPECTED_RESULT")
})

test_that("library_construction_platform", {
  # tests for the property `library_construction_platform` (character)
  # The platform used to construct the library sequenced in this measurement set.

  # uncomment below to test the property
  #expect_equal(model.instance$`library_construction_platform`, "EXPECTED_RESULT")
})

test_that("measurement_sets", {
  # tests for the property `measurement_sets` (set[character])
  # The measurement sets that link to this auxiliary set.

  # uncomment below to test the property
  #expect_equal(model.instance$`measurement_sets`, "EXPECTED_RESULT")
})

test_that("small_scale_loci_list", {
  # tests for the property `small_scale_loci_list` (set[object])
  # A small scale (&lt;&#x3D;100) list of specific chromosomal region(s).

  # uncomment below to test the property
  #expect_equal(model.instance$`small_scale_loci_list`, "EXPECTED_RESULT")
})

test_that("large_scale_loci_list", {
  # tests for the property `large_scale_loci_list` (character)
  # A large scale list (&gt;100) of specific chromosomal regions.

  # uncomment below to test the property
  #expect_equal(model.instance$`large_scale_loci_list`, "EXPECTED_RESULT")
})

test_that("small_scale_gene_list", {
  # tests for the property `small_scale_gene_list` (set[character])
  # The specific, small scale list of (&lt;&#x3D;100) gene(s) this prediction set targets.

  # uncomment below to test the property
  #expect_equal(model.instance$`small_scale_gene_list`, "EXPECTED_RESULT")
})

test_that("large_scale_gene_list", {
  # tests for the property `large_scale_gene_list` (character)
  # The large scale list of (&gt;100 genes) this this prediction set targets.

  # uncomment below to test the property
  #expect_equal(model.instance$`large_scale_gene_list`, "EXPECTED_RESULT")
})

test_that("scope", {
  # tests for the property `scope` (character)
  # The scope or scale that this prediction set is designed to target. If the scope is across gene(s) or loci, these will need to be specified in the genes or loci property.

  # uncomment below to test the property
  #expect_equal(model.instance$`scope`, "EXPECTED_RESULT")
})

test_that("selection_criteria", {
  # tests for the property `selection_criteria` (set[character])
  # The criteria used to select the sequence material cloned into the library.

  # uncomment below to test the property
  #expect_equal(model.instance$`selection_criteria`, "EXPECTED_RESULT")
})

test_that("integrated_content_files", {
  # tests for the property `integrated_content_files` (set[character])
  # The files containing sequence material of interest either used for insert design or directly cloned into vectors in this library.

  # uncomment below to test the property
  #expect_equal(model.instance$`integrated_content_files`, "EXPECTED_RESULT")
})

test_that("associated_phenotypes", {
  # tests for the property `associated_phenotypes` (set[character])
  # Ontological terms for diseases or phenotypes associated with the sequence material cloned in this construct library.

  # uncomment below to test the property
  #expect_equal(model.instance$`associated_phenotypes`, "EXPECTED_RESULT")
})

test_that("orf_list", {
  # tests for the property `orf_list` (set[character])
  # List of Open Reading Frame this construct library was designed to target.

  # uncomment below to test the property
  #expect_equal(model.instance$`orf_list`, "EXPECTED_RESULT")
})

test_that("exon", {
  # tests for the property `exon` (character)
  # An identifier in plain text for the specific exon in an expression vector library. The associated gene must be listed in the small_scale_gene_list property.

  # uncomment below to test the property
  #expect_equal(model.instance$`exon`, "EXPECTED_RESULT")
})

test_that("tile", {
  # tests for the property `tile` (Tile)

  # uncomment below to test the property
  #expect_equal(model.instance$`tile`, "EXPECTED_RESULT")
})

test_that("guide_type", {
  # tests for the property `guide_type` (character)
  # The design of guides used in a CRISPR library, paired-guide (pgRNA) or single-guide (sgRNA).

  # uncomment below to test the property
  #expect_equal(model.instance$`guide_type`, "EXPECTED_RESULT")
})

test_that("tiling_modality", {
  # tests for the property `tiling_modality` (character)
  # The tiling modality of guides across elements or loci in a CRISPR library.

  # uncomment below to test the property
  #expect_equal(model.instance$`tiling_modality`, "EXPECTED_RESULT")
})

test_that("average_guide_coverage", {
  # tests for the property `average_guide_coverage` (numeric)
  # The average number of guides targeting each element of interest in the library.

  # uncomment below to test the property
  #expect_equal(model.instance$`average_guide_coverage`, "EXPECTED_RESULT")
})

test_that("lower_bound_guide_coverage", {
  # tests for the property `lower_bound_guide_coverage` (integer)
  # Lower bound of the number of guides targeting each element of interest in the library.

  # uncomment below to test the property
  #expect_equal(model.instance$`lower_bound_guide_coverage`, "EXPECTED_RESULT")
})

test_that("upper_bound_guide_coverage", {
  # tests for the property `upper_bound_guide_coverage` (integer)
  # Upper bound of the number of guides targeting each element of interest in the library.

  # uncomment below to test the property
  #expect_equal(model.instance$`upper_bound_guide_coverage`, "EXPECTED_RESULT")
})

test_that("average_insert_size", {
  # tests for the property `average_insert_size` (numeric)
  # The average size of the inserts cloned into vectors in the library.

  # uncomment below to test the property
  #expect_equal(model.instance$`average_insert_size`, "EXPECTED_RESULT")
})

test_that("lower_bound_insert_size", {
  # tests for the property `lower_bound_insert_size` (integer)
  # Lower bound of the size of the inserts cloned in vectors in the library.

  # uncomment below to test the property
  #expect_equal(model.instance$`lower_bound_insert_size`, "EXPECTED_RESULT")
})

test_that("upper_bound_insert_size", {
  # tests for the property `upper_bound_insert_size` (integer)
  # Upper bound of the size of the inserts cloned in vectors in the library.

  # uncomment below to test the property
  #expect_equal(model.instance$`upper_bound_insert_size`, "EXPECTED_RESULT")
})

test_that("targeton", {
  # tests for the property `targeton` (character)
  # An identifier in plain text for the specific targeton in an editing template library. The associated gene must be listed in the small_scale_gene_list property.

  # uncomment below to test the property
  #expect_equal(model.instance$`targeton`, "EXPECTED_RESULT")
})

test_that("applied_to_samples", {
  # tests for the property `applied_to_samples` (set[character])
  # The samples that link to this construct library set.

  # uncomment below to test the property
  #expect_equal(model.instance$`applied_to_samples`, "EXPECTED_RESULT")
})

test_that("assemblies", {
  # tests for the property `assemblies` (set[character])
  # The genome assemblies to which the referencing files in the file set are utilizing (e.g., GRCh38).

  # uncomment below to test the property
  #expect_equal(model.instance$`assemblies`, "EXPECTED_RESULT")
})

test_that("transcriptome_annotations", {
  # tests for the property `transcriptome_annotations` (set[character])
  # The annotation versions of the reference resource.

  # uncomment below to test the property
  #expect_equal(model.instance$`transcriptome_annotations`, "EXPECTED_RESULT")
})

test_that("assay_term", {
  # tests for the property `assay_term` (character)
  # The assay used to produce data in this measurement set.

  # uncomment below to test the property
  #expect_equal(model.instance$`assay_term`, "EXPECTED_RESULT")
})

test_that("protocols", {
  # tests for the property `protocols` (set[character])
  # Links to the protocol(s) for preparing the samples on Protocols.io.

  # uncomment below to test the property
  #expect_equal(model.instance$`protocols`, "EXPECTED_RESULT")
})

test_that("preferred_assay_title", {
  # tests for the property `preferred_assay_title` (character)
  # The custom lab preferred label for the experiment performed in this measurement set.

  # uncomment below to test the property
  #expect_equal(model.instance$`preferred_assay_title`, "EXPECTED_RESULT")
})

test_that("multiome_size", {
  # tests for the property `multiome_size` (integer)
  # The number of datasets included in the multiome experiment this measurement set is a part of.

  # uncomment below to test the property
  #expect_equal(model.instance$`multiome_size`, "EXPECTED_RESULT")
})

test_that("control_file_sets", {
  # tests for the property `control_file_sets` (set[character])
  # File sets that can serve as scientific controls for this measurement_set.

  # uncomment below to test the property
  #expect_equal(model.instance$`control_file_sets`, "EXPECTED_RESULT")
})

test_that("sequencing_library_types", {
  # tests for the property `sequencing_library_types` (set[character])
  # Description of the libraries sequenced in this measurement set.

  # uncomment below to test the property
  #expect_equal(model.instance$`sequencing_library_types`, "EXPECTED_RESULT")
})

test_that("auxiliary_sets", {
  # tests for the property `auxiliary_sets` (set[character])
  # The auxiliary sets of files produced alongside raw data from this measurement set.

  # uncomment below to test the property
  #expect_equal(model.instance$`auxiliary_sets`, "EXPECTED_RESULT")
})

test_that("external_image_url", {
  # tests for the property `external_image_url` (character)
  # Links to the external site where images produced by this measurement are stored.

  # uncomment below to test the property
  #expect_equal(model.instance$`external_image_url`, "EXPECTED_RESULT")
})

test_that("targeted_genes", {
  # tests for the property `targeted_genes` (set[character])
  # A list of genes targeted in this assay. For example, TF ChIP-seq attempts to identify binding sites of a protein encoded by a specific gene. In CRISPR FlowFISH, the modified samples are sorted based on expression of a specific gene. This property differs from small_scale_gene_list in Construct Library Set, which describes genes targeted by the content integrated in the constructs (such as guide RNAs.)

  # uncomment below to test the property
  #expect_equal(model.instance$`targeted_genes`, "EXPECTED_RESULT")
})

test_that("related_multiome_datasets", {
  # tests for the property `related_multiome_datasets` (set[character])
  # Related datasets included in the multiome experiment this measurement set is a part of.

  # uncomment below to test the property
  #expect_equal(model.instance$`related_multiome_datasets`, "EXPECTED_RESULT")
})

test_that("model_name", {
  # tests for the property `model_name` (character)
  # The custom lab name given to this predictive model set.

  # uncomment below to test the property
  #expect_equal(model.instance$`model_name`, "EXPECTED_RESULT")
})

test_that("model_version", {
  # tests for the property `model_version` (character)
  # The semantic version number for this predictive model set.

  # uncomment below to test the property
  #expect_equal(model.instance$`model_version`, "EXPECTED_RESULT")
})

test_that("prediction_objects", {
  # tests for the property `prediction_objects` (set[character])
  # The objects this predictive model set is targeting.

  # uncomment below to test the property
  #expect_equal(model.instance$`prediction_objects`, "EXPECTED_RESULT")
})

test_that("model_zoo_location", {
  # tests for the property `model_zoo_location` (character)
  # The link to the model on the Kipoi repository.

  # uncomment below to test the property
  #expect_equal(model.instance$`model_zoo_location`, "EXPECTED_RESULT")
})

test_that("software_version", {
  # tests for the property `software_version` (character)
  # Version of software used for the derivation of this model set.

  # uncomment below to test the property
  #expect_equal(model.instance$`software_version`, "EXPECTED_RESULT")
})

test_that("assessed_genes", {
  # tests for the property `assessed_genes` (set[character])
  # A list of genes assessed in this model set.

  # uncomment below to test the property
  #expect_equal(model.instance$`assessed_genes`, "EXPECTED_RESULT")
})

test_that("geneid", {
  # tests for the property `geneid` (character)
  # ENSEMBL GeneID of official nomenclature approved gene. The GeneID does not include the current version number suffix.

  # uncomment below to test the property
  #expect_equal(model.instance$`geneid`, "EXPECTED_RESULT")
})

test_that("symbol", {
  # tests for the property `symbol` (character)
  # Gene symbol approved by the official nomenclature.

  # uncomment below to test the property
  #expect_equal(model.instance$`symbol`, "EXPECTED_RESULT")
})

test_that("locations", {
  # tests for the property `locations` (set[GeneLocation1])
  # Gene locations specified using 1-based, closed coordinates for different versions of reference genome assemblies.

  # uncomment below to test the property
  #expect_equal(model.instance$`locations`, "EXPECTED_RESULT")
})

test_that("version_number", {
  # tests for the property `version_number` (character)
  # Current ENSEMBL GeneID version number of the gene.

  # uncomment below to test the property
  #expect_equal(model.instance$`version_number`, "EXPECTED_RESULT")
})

test_that("geneid_with_version", {
  # tests for the property `geneid_with_version` (character)
  # The ENSEMBL GeneID concatenated with its version number.

  # uncomment below to test the property
  #expect_equal(model.instance$`geneid_with_version`, "EXPECTED_RESULT")
})

test_that("caption", {
  # tests for the property `caption` (character)
  # The caption of the image.

  # uncomment below to test the property
  #expect_equal(model.instance$`caption`, "EXPECTED_RESULT")
})

test_that("thumb_nail", {
  # tests for the property `thumb_nail` (character)
  # Image url

  # uncomment below to test the property
  #expect_equal(model.instance$`thumb_nail`, "EXPECTED_RESULT")
})

test_that("download_url", {
  # tests for the property `download_url` (character)
  # Download Url

  # uncomment below to test the property
  #expect_equal(model.instance$`download_url`, "EXPECTED_RESULT")
})

test_that("certificate_identifier", {
  # tests for the property `certificate_identifier` (character)
  # A unique identifier for the certificate.

  # uncomment below to test the property
  #expect_equal(model.instance$`certificate_identifier`, "EXPECTED_RESULT")
})

test_that("data_use_limitation", {
  # tests for the property `data_use_limitation` (character)
  # Code indicating the limitations on data use for data generated from the applicable samples. GRU (General research use): Use of the data is limited only by the terms of the Data Use Certification: these data will be added to the dbGaP Collection. HMB (Health/medical/biomedical): Use of the data is limited to health/medical/biomedical purposes, does not include the study of population origins or ancestry. DS (Disease specific): Use of the data must be related to the specified disease. Other: any other customized limitation.

  # uncomment below to test the property
  #expect_equal(model.instance$`data_use_limitation`, "EXPECTED_RESULT")
})

test_that("data_use_limitation_modifiers", {
  # tests for the property `data_use_limitation_modifiers` (set[character])
  # Code indicating a modifier on the limitations on data use for data generated from the applicable samples. COL: Requestor must provide a letter of collaboration with the primary study investigator(s). GSO: Use of the data is limited to genetic studies only. IRB: Approval Required IRB Requestor must provide documentation of local IRB approval. MDS: Use of the data includes methods development research (e.g., development and testing of software or algorithms). NPU: Use of the data is limited to not-for-profit organizations. PUB: Requestor agrees to make results of studies using the data available to the larger scientific community.

  # uncomment below to test the property
  #expect_equal(model.instance$`data_use_limitation_modifiers`, "EXPECTED_RESULT")
})

test_that("pi", {
  # tests for the property `pi` (character)
  # Principle Investigator of the lab.

  # uncomment below to test the property
  #expect_equal(model.instance$`pi`, "EXPECTED_RESULT")
})

test_that("awards", {
  # tests for the property `awards` (set[character])
  # Grants associated with the lab.

  # uncomment below to test the property
  #expect_equal(model.instance$`awards`, "EXPECTED_RESULT")
})

test_that("institute_label", {
  # tests for the property `institute_label` (character)
  # An abbreviation for the institute the lab is associated with.

  # uncomment below to test the property
  #expect_equal(model.instance$`institute_label`, "EXPECTED_RESULT")
})

test_that("activated", {
  # tests for the property `activated` (character)
  # A boolean indicating whether the modification has been activated by a chemical agent.

  # uncomment below to test the property
  #expect_equal(model.instance$`activated`, "EXPECTED_RESULT")
})

test_that("activating_agent_term_id", {
  # tests for the property `activating_agent_term_id` (character)
  # The CHEBI identifier for the activating agent of the modification.

  # uncomment below to test the property
  #expect_equal(model.instance$`activating_agent_term_id`, "EXPECTED_RESULT")
})

test_that("activating_agent_term_name", {
  # tests for the property `activating_agent_term_name` (character)
  # The CHEBI name for the activating agent of the modification.

  # uncomment below to test the property
  #expect_equal(model.instance$`activating_agent_term_name`, "EXPECTED_RESULT")
})

test_that("modality", {
  # tests for the property `modality` (character)
  # The purpose or intended effect of a modification.

  # uncomment below to test the property
  #expect_equal(model.instance$`modality`, "EXPECTED_RESULT")
})

test_that("cas", {
  # tests for the property `cas` (character)
  # The name of the CRISPR associated protein used in the modification.

  # uncomment below to test the property
  #expect_equal(model.instance$`cas`, "EXPECTED_RESULT")
})

test_that("fused_domain", {
  # tests for the property `fused_domain` (character)
  # The name of the molecule fused to a Cas protein.

  # uncomment below to test the property
  #expect_equal(model.instance$`fused_domain`, "EXPECTED_RESULT")
})

test_that("tagged_protein", {
  # tests for the property `tagged_protein` (character)
  # The tagged protein in modifications in which the Cas nuclease is fused to an antibody.

  # uncomment below to test the property
  #expect_equal(model.instance$`tagged_protein`, "EXPECTED_RESULT")
})

test_that("cas_species", {
  # tests for the property `cas_species` (character)
  # The originating species of the Cas nuclease.

  # uncomment below to test the property
  #expect_equal(model.instance$`cas_species`, "EXPECTED_RESULT")
})

test_that("biosamples_modified", {
  # tests for the property `biosamples_modified` (set[character])
  # The biosamples which have been modified with this modification.

  # uncomment below to test the property
  #expect_equal(model.instance$`biosamples_modified`, "EXPECTED_RESULT")
})

test_that("degron_system", {
  # tests for the property `degron_system` (character)
  # The type of degron system implemented.

  # uncomment below to test the property
  #expect_equal(model.instance$`degron_system`, "EXPECTED_RESULT")
})

test_that("tagged_proteins", {
  # tests for the property `tagged_proteins` (set[character])
  # The tagged proteins which are targeted for degradation.

  # uncomment below to test the property
  #expect_equal(model.instance$`tagged_proteins`, "EXPECTED_RESULT")
})

test_that("term_id", {
  # tests for the property `term_id` (character)
  # An ontology identifier describing a biological sample

  # uncomment below to test the property
  #expect_equal(model.instance$`term_id`, "EXPECTED_RESULT")
})

test_that("term_name", {
  # tests for the property `term_name` (character)
  # Ontology term describing a biological sample, assay, trait, or disease.

  # uncomment below to test the property
  #expect_equal(model.instance$`term_name`, "EXPECTED_RESULT")
})

test_that("deprecated_ntr_terms", {
  # tests for the property `deprecated_ntr_terms` (set[character])
  # A list of deprecated NTR terms previously associated with this ontology term.

  # uncomment below to test the property
  #expect_equal(model.instance$`deprecated_ntr_terms`, "EXPECTED_RESULT")
})

test_that("is_a", {
  # tests for the property `is_a` (set[character])
  # A list of ontology terms which are the nearest ancestor to this ontology term.

  # uncomment below to test the property
  #expect_equal(model.instance$`is_a`, "EXPECTED_RESULT")
})

test_that("preferred_assay_titles", {
  # tests for the property `preferred_assay_titles` (set[character])
  # The custom lab preferred labels that this assay term may be associated with.

  # uncomment below to test the property
  #expect_equal(model.instance$`preferred_assay_titles`, "EXPECTED_RESULT")
})

test_that("ancestors", {
  # tests for the property `ancestors` (set[character])
  # List of term names of ontological terms that precede the given term in the ontological tree. These ancestor terms are typically more general ontological terms under which the term is classified.

  # uncomment below to test the property
  #expect_equal(model.instance$`ancestors`, "EXPECTED_RESULT")
})

test_that("ontology", {
  # tests for the property `ontology` (character)
  # The ontology in which the term is recorded.

  # uncomment below to test the property
  #expect_equal(model.instance$`ontology`, "EXPECTED_RESULT")
})

test_that("assay_slims", {
  # tests for the property `assay_slims` (set[character])
  # A broad categorization of the assay term.

  # uncomment below to test the property
  #expect_equal(model.instance$`assay_slims`, "EXPECTED_RESULT")
})

test_that("category_slims", {
  # tests for the property `category_slims` (set[character])
  # The type of feature or interaction measured by the assay.

  # uncomment below to test the property
  #expect_equal(model.instance$`category_slims`, "EXPECTED_RESULT")
})

test_that("objective_slims", {
  # tests for the property `objective_slims` (set[character])
  # The purpose of the assay.

  # uncomment below to test the property
  #expect_equal(model.instance$`objective_slims`, "EXPECTED_RESULT")
})

test_that("company", {
  # tests for the property `company` (character)
  # The company that developed and sells the instrument.

  # uncomment below to test the property
  #expect_equal(model.instance$`company`, "EXPECTED_RESULT")
})

test_that("sequencing_kits", {
  # tests for the property `sequencing_kits` (set[character])
  # The available sequencing kits for this platform.

  # uncomment below to test the property
  #expect_equal(model.instance$`sequencing_kits`, "EXPECTED_RESULT")
})

test_that("organ_slims", {
  # tests for the property `organ_slims` (set[character])
  # Organs associated with the sample term.

  # uncomment below to test the property
  #expect_equal(model.instance$`organ_slims`, "EXPECTED_RESULT")
})

test_that("cell_slims", {
  # tests for the property `cell_slims` (set[character])
  # Cells associated with the sample term.

  # uncomment below to test the property
  #expect_equal(model.instance$`cell_slims`, "EXPECTED_RESULT")
})

test_that("developmental_slims", {
  # tests for the property `developmental_slims` (set[character])
  # Developmental stages associated with the sample term.

  # uncomment below to test the property
  #expect_equal(model.instance$`developmental_slims`, "EXPECTED_RESULT")
})

test_that("system_slims", {
  # tests for the property `system_slims` (set[character])
  # Organ systems associated with the sample term.

  # uncomment below to test the property
  #expect_equal(model.instance$`system_slims`, "EXPECTED_RESULT")
})

test_that("orf_id", {
  # tests for the property `orf_id` (character)
  # Open reading frame ID.

  # uncomment below to test the property
  #expect_equal(model.instance$`orf_id`, "EXPECTED_RESULT")
})

test_that("protein_id", {
  # tests for the property `protein_id` (character)
  # ENSEMBL ProteinID of official nomenclature approved protein. The ProteinID does not include the current version number suffix.

  # uncomment below to test the property
  #expect_equal(model.instance$`protein_id`, "EXPECTED_RESULT")
})

test_that("pct_identical_protein", {
  # tests for the property `pct_identical_protein` (numeric)
  # The percentage of identical matches to Ensembl protein.

  # uncomment below to test the property
  #expect_equal(model.instance$`pct_identical_protein`, "EXPECTED_RESULT")
})

test_that("pct_coverage_protein", {
  # tests for the property `pct_coverage_protein` (numeric)
  # The percentage of ORF covered by Ensembl protein.

  # uncomment below to test the property
  #expect_equal(model.instance$`pct_coverage_protein`, "EXPECTED_RESULT")
})

test_that("pct_coverage_orf", {
  # tests for the property `pct_coverage_orf` (numeric)
  # The percentage of Ensembl protein covered by ORF.

  # uncomment below to test the property
  #expect_equal(model.instance$`pct_coverage_orf`, "EXPECTED_RESULT")
})

test_that("parent", {
  # tests for the property `parent` (character)
  # The parent page associated with this page.

  # uncomment below to test the property
  #expect_equal(model.instance$`parent`, "EXPECTED_RESULT")
})

test_that("layout", {
  # tests for the property `layout` (PageLayout)

  # uncomment below to test the property
  #expect_equal(model.instance$`layout`, "EXPECTED_RESULT")
})

test_that("canonical_uri", {
  # tests for the property `canonical_uri` (character)
  # The path of the page.

  # uncomment below to test the property
  #expect_equal(model.instance$`canonical_uri`, "EXPECTED_RESULT")
})

test_that("feature", {
  # tests for the property `feature` (character)
  # The phenotypic feature observed for the donor.

  # uncomment below to test the property
  #expect_equal(model.instance$`feature`, "EXPECTED_RESULT")
})

test_that("quantity", {
  # tests for the property `quantity` (numeric)
  # A quantity associated with the phenotypic feature, if applicable.

  # uncomment below to test the property
  #expect_equal(model.instance$`quantity`, "EXPECTED_RESULT")
})

test_that("quantity_units", {
  # tests for the property `quantity_units` (character)
  # The unit of measurement for a quantity associated with the phenotypic feature.

  # uncomment below to test the property
  #expect_equal(model.instance$`quantity_units`, "EXPECTED_RESULT")
})

test_that("observation_date", {
  # tests for the property `observation_date` (character)
  # The date the feature was observed or measured.

  # uncomment below to test the property
  #expect_equal(model.instance$`observation_date`, "EXPECTED_RESULT")
})

test_that("abstract", {
  # tests for the property `abstract` (character)
  # Abstract of the publication or communication.

  # uncomment below to test the property
  #expect_equal(model.instance$`abstract`, "EXPECTED_RESULT")
})

test_that("authors", {
  # tests for the property `authors` (character)
  # The authors of the publication.

  # uncomment below to test the property
  #expect_equal(model.instance$`authors`, "EXPECTED_RESULT")
})

test_that("date_published", {
  # tests for the property `date_published` (character)
  # The date the publication or communication was published; must be in YYYY-MM-DD format.

  # uncomment below to test the property
  #expect_equal(model.instance$`date_published`, "EXPECTED_RESULT")
})

test_that("date_revised", {
  # tests for the property `date_revised` (character)
  # The date the publication was revised.

  # uncomment below to test the property
  #expect_equal(model.instance$`date_revised`, "EXPECTED_RESULT")
})

test_that("issue", {
  # tests for the property `issue` (character)
  # The issue of the publication.

  # uncomment below to test the property
  #expect_equal(model.instance$`issue`, "EXPECTED_RESULT")
})

test_that("page", {
  # tests for the property `page` (character)
  # Pagination of the reference

  # uncomment below to test the property
  #expect_equal(model.instance$`page`, "EXPECTED_RESULT")
})

test_that("volume", {
  # tests for the property `volume` (character)
  # The volume of the publication.

  # uncomment below to test the property
  #expect_equal(model.instance$`volume`, "EXPECTED_RESULT")
})

test_that("journal", {
  # tests for the property `journal` (character)
  # The journal of the publication.

  # uncomment below to test the property
  #expect_equal(model.instance$`journal`, "EXPECTED_RESULT")
})

test_that("published_by", {
  # tests for the property `published_by` (set[character])
  # The affiliation of the lab with a larger organization, such as IGVF.

  # uncomment below to test the property
  #expect_equal(model.instance$`published_by`, "EXPECTED_RESULT")
})

test_that("publication_year", {
  # tests for the property `publication_year` (integer)
  # The year the publication was published.

  # uncomment below to test the property
  #expect_equal(model.instance$`publication_year`, "EXPECTED_RESULT")
})

test_that("file_sets", {
  # tests for the property `file_sets` (set[character])
  # The file sets linked to this sample.

  # uncomment below to test the property
  #expect_equal(model.instance$`file_sets`, "EXPECTED_RESULT")
})

test_that("workflows", {
  # tests for the property `workflows` (set[character])
  # The workflows associated with this publication.

  # uncomment below to test the property
  #expect_equal(model.instance$`workflows`, "EXPECTED_RESULT")
})

test_that("software", {
  # tests for the property `software` (character)
  # Unique name of the software package.

  # uncomment below to test the property
  #expect_equal(model.instance$`software`, "EXPECTED_RESULT")
})

test_that("lower_bound_age", {
  # tests for the property `lower_bound_age` (numeric)
  # Lower bound of age of the organism at the time of collection of the sample.

  # uncomment below to test the property
  #expect_equal(model.instance$`lower_bound_age`, "EXPECTED_RESULT")
})

test_that("upper_bound_age", {
  # tests for the property `upper_bound_age` (numeric)
  # Upper bound of age of the organism at the time of collection of the sample.

  # uncomment below to test the property
  #expect_equal(model.instance$`upper_bound_age`, "EXPECTED_RESULT")
})

test_that("age_units", {
  # tests for the property `age_units` (character)
  # The units of time associated with age of the biosample.

  # uncomment below to test the property
  #expect_equal(model.instance$`age_units`, "EXPECTED_RESULT")
})

test_that("sample_terms", {
  # tests for the property `sample_terms` (set[character])
  # Ontology terms identifying a biosample.

  # uncomment below to test the property
  #expect_equal(model.instance$`sample_terms`, "EXPECTED_RESULT")
})

test_that("disease_terms", {
  # tests for the property `disease_terms` (set[character])
  # Ontology term of the disease associated with the biosample.

  # uncomment below to test the property
  #expect_equal(model.instance$`disease_terms`, "EXPECTED_RESULT")
})

test_that("pooled_from", {
  # tests for the property `pooled_from` (set[character])
  # The biosamples this biosample is pooled from.

  # uncomment below to test the property
  #expect_equal(model.instance$`pooled_from`, "EXPECTED_RESULT")
})

test_that("part_of", {
  # tests for the property `part_of` (character)
  # Links to a biosample which represents a larger sample from which this sample was taken regardless of whether it is a tissue taken from an organism or smaller slices of a piece of tissue or aliquots of a cell growth.

  # uncomment below to test the property
  #expect_equal(model.instance$`part_of`, "EXPECTED_RESULT")
})

test_that("originated_from", {
  # tests for the property `originated_from` (character)
  # Links to a biosample that was originated from due to differentiation, dedifferentiation, reprogramming, or the introduction of a genetic modification.

  # uncomment below to test the property
  #expect_equal(model.instance$`originated_from`, "EXPECTED_RESULT")
})

test_that("treatments", {
  # tests for the property `treatments` (set[character])
  # A list of treatments applied to the biosample with the purpose of perturbation.

  # uncomment below to test the property
  #expect_equal(model.instance$`treatments`, "EXPECTED_RESULT")
})

test_that("biomarkers", {
  # tests for the property `biomarkers` (set[character])
  # Biological markers that are associated with this sample.

  # uncomment below to test the property
  #expect_equal(model.instance$`biomarkers`, "EXPECTED_RESULT")
})

test_that("embryonic", {
  # tests for the property `embryonic` (character)
  # Biosample is embryonic.

  # uncomment below to test the property
  #expect_equal(model.instance$`embryonic`, "EXPECTED_RESULT")
})

test_that("modifications", {
  # tests for the property `modifications` (set[character])
  # Links to modifications applied to this biosample.

  # uncomment below to test the property
  #expect_equal(model.instance$`modifications`, "EXPECTED_RESULT")
})

test_that("cellular_sub_pool", {
  # tests for the property `cellular_sub_pool` (character)
  # Cellular sub-pool fraction of the sample. Also known as PKR and sub-library.

  # uncomment below to test the property
  #expect_equal(model.instance$`cellular_sub_pool`, "EXPECTED_RESULT")
})

test_that("starting_amount", {
  # tests for the property `starting_amount` (numeric)
  # The initial quantity of samples obtained.

  # uncomment below to test the property
  #expect_equal(model.instance$`starting_amount`, "EXPECTED_RESULT")
})

test_that("starting_amount_units", {
  # tests for the property `starting_amount_units` (character)
  # The units used to quantify the amount of samples obtained.

  # uncomment below to test the property
  #expect_equal(model.instance$`starting_amount_units`, "EXPECTED_RESULT")
})

test_that("date_obtained", {
  # tests for the property `date_obtained` (character)
  # The date the sample was harvested, dissected or created, depending on the type of the sample.

  # uncomment below to test the property
  #expect_equal(model.instance$`date_obtained`, "EXPECTED_RESULT")
})

test_that("sorted_from", {
  # tests for the property `sorted_from` (character)
  # Links to a larger sample from which this sample was obtained through sorting.

  # uncomment below to test the property
  #expect_equal(model.instance$`sorted_from`, "EXPECTED_RESULT")
})

test_that("sorted_from_detail", {
  # tests for the property `sorted_from_detail` (character)
  # Detail for sample sorted into fractions capturing information about sorting.

  # uncomment below to test the property
  #expect_equal(model.instance$`sorted_from_detail`, "EXPECTED_RESULT")
})

test_that("construct_library_sets", {
  # tests for the property `construct_library_sets` (set[character])
  # The construct library sets of vectors introduced to this sample prior to performing an assay.

  # uncomment below to test the property
  #expect_equal(model.instance$`construct_library_sets`, "EXPECTED_RESULT")
})

test_that("moi", {
  # tests for the property `moi` (numeric)
  # The actual multiplicity of infection (MOI) for vectors introduced to this sample. At least one construct library set must be specified in order to specify MOI. This property should capture the actual MOI, and not the targeted MOI.

  # uncomment below to test the property
  #expect_equal(model.instance$`moi`, "EXPECTED_RESULT")
})

test_that("nucleic_acid_delivery", {
  # tests for the property `nucleic_acid_delivery` (character)
  # Method of introduction of nucleic acid into the cell.

  # uncomment below to test the property
  #expect_equal(model.instance$`nucleic_acid_delivery`, "EXPECTED_RESULT")
})

test_that("time_post_library_delivery", {
  # tests for the property `time_post_library_delivery` (numeric)
  # The time that elapsed past the time-point when the construct library sets were introduced.

  # uncomment below to test the property
  #expect_equal(model.instance$`time_post_library_delivery`, "EXPECTED_RESULT")
})

test_that("time_post_library_delivery_units", {
  # tests for the property `time_post_library_delivery_units` (character)
  # The units of time that elapsed past the point when the construct library sets were introduced.

  # uncomment below to test the property
  #expect_equal(model.instance$`time_post_library_delivery_units`, "EXPECTED_RESULT")
})

test_that("classifications", {
  # tests for the property `classifications` (set[character])
  # The general category of this type of sample.

  # uncomment below to test the property
  #expect_equal(model.instance$`classifications`, "EXPECTED_RESULT")
})

test_that("time_post_change", {
  # tests for the property `time_post_change` (numeric)
  # The time that elapsed past the time-point when the cell fate change treatments were introduced.

  # uncomment below to test the property
  #expect_equal(model.instance$`time_post_change`, "EXPECTED_RESULT")
})

test_that("time_post_change_units", {
  # tests for the property `time_post_change_units` (character)
  # The units of time that elapsed past the point when the cell fate change treatments were introduced.

  # uncomment below to test the property
  #expect_equal(model.instance$`time_post_change_units`, "EXPECTED_RESULT")
})

test_that("cell_fate_change_treatments", {
  # tests for the property `cell_fate_change_treatments` (set[character])
  # A list of treatments applied to the biosample with the purpose of differentiation, dedifferentiation, or reprogramming.

  # uncomment below to test the property
  #expect_equal(model.instance$`cell_fate_change_treatments`, "EXPECTED_RESULT")
})

test_that("cell_fate_change_protocol", {
  # tests for the property `cell_fate_change_protocol` (character)
  # A protocol applied to the biosample with the purpose of differentiation, dedifferentiation, or reprogramming.

  # uncomment below to test the property
  #expect_equal(model.instance$`cell_fate_change_protocol`, "EXPECTED_RESULT")
})

test_that("demultiplexed_from", {
  # tests for the property `demultiplexed_from` (character)
  # The biosample this in vitro system sample was demultiplexed from using computational methods.

  # uncomment below to test the property
  #expect_equal(model.instance$`demultiplexed_from`, "EXPECTED_RESULT")
})

test_that("passage_number", {
  # tests for the property `passage_number` (integer)
  # Number of passages including the passages from the source.

  # uncomment below to test the property
  #expect_equal(model.instance$`passage_number`, "EXPECTED_RESULT")
})

test_that("targeted_sample_term", {
  # tests for the property `targeted_sample_term` (character)
  # Ontology term identifying the targeted endpoint biosample resulting from differentation or reprogramming.

  # uncomment below to test the property
  #expect_equal(model.instance$`targeted_sample_term`, "EXPECTED_RESULT")
})

test_that("growth_medium", {
  # tests for the property `growth_medium` (character)
  # A growth medium of the in vitro system.

  # uncomment below to test the property
  #expect_equal(model.instance$`growth_medium`, "EXPECTED_RESULT")
})

test_that("multiplexed_in", {
  # tests for the property `multiplexed_in` (set[character])
  # The multiplexed samples in which this sample is included.

  # uncomment below to test the property
  #expect_equal(model.instance$`multiplexed_in`, "EXPECTED_RESULT")
})

test_that("sorted_fractions", {
  # tests for the property `sorted_fractions` (set[character])
  # The fractions into which this sample has been sorted.

  # uncomment below to test the property
  #expect_equal(model.instance$`sorted_fractions`, "EXPECTED_RESULT")
})

test_that("origin_of", {
  # tests for the property `origin_of` (set[character])
  # The samples which originate from this sample, such as through a process of cell differentiation.

  # uncomment below to test the property
  #expect_equal(model.instance$`origin_of`, "EXPECTED_RESULT")
})

test_that("institutional_certificates", {
  # tests for the property `institutional_certificates` (set[character])
  # The institutional certificates under which use of this sample is approved.

  # uncomment below to test the property
  #expect_equal(model.instance$`institutional_certificates`, "EXPECTED_RESULT")
})

test_that("age", {
  # tests for the property `age` (character)
  # Age of organism at the time of collection of the sample.

  # uncomment below to test the property
  #expect_equal(model.instance$`age`, "EXPECTED_RESULT")
})

test_that("upper_bound_age_in_hours", {
  # tests for the property `upper_bound_age_in_hours` (numeric)
  # Upper bound of age of organism in hours at the time of collection of the sample.

  # uncomment below to test the property
  #expect_equal(model.instance$`upper_bound_age_in_hours`, "EXPECTED_RESULT")
})

test_that("lower_bound_age_in_hours", {
  # tests for the property `lower_bound_age_in_hours` (numeric)
  # Lower bound of age of organism in hours at the time of collection of the sample .

  # uncomment below to test the property
  #expect_equal(model.instance$`lower_bound_age_in_hours`, "EXPECTED_RESULT")
})

test_that("parts", {
  # tests for the property `parts` (set[character])
  # The parts into which this sample has been divided.

  # uncomment below to test the property
  #expect_equal(model.instance$`parts`, "EXPECTED_RESULT")
})

test_that("pooled_in", {
  # tests for the property `pooled_in` (set[character])
  # The pooled samples in which this sample is included.

  # uncomment below to test the property
  #expect_equal(model.instance$`pooled_in`, "EXPECTED_RESULT")
})

test_that("demultiplexed_to", {
  # tests for the property `demultiplexed_to` (set[character])
  # The parts into which this sample has been demultiplexed.

  # uncomment below to test the property
  #expect_equal(model.instance$`demultiplexed_to`, "EXPECTED_RESULT")
})

test_that("multiplexed_samples", {
  # tests for the property `multiplexed_samples` (set[character])
  # The samples multiplexed together to produce this sample.

  # uncomment below to test the property
  #expect_equal(model.instance$`multiplexed_samples`, "EXPECTED_RESULT")
})

test_that("barcode_sample_map", {
  # tests for the property `barcode_sample_map` (character)
  # The link to the barcode to sample mapping tabular file.

  # uncomment below to test the property
  #expect_equal(model.instance$`barcode_sample_map`, "EXPECTED_RESULT")
})

test_that("sample_material", {
  # tests for the property `sample_material` (character)

  # uncomment below to test the property
  #expect_equal(model.instance$`sample_material`, "EXPECTED_RESULT")
})

test_that("pmi", {
  # tests for the property `pmi` (integer)
  # The amount of time elapsed since death.

  # uncomment below to test the property
  #expect_equal(model.instance$`pmi`, "EXPECTED_RESULT")
})

test_that("pmi_units", {
  # tests for the property `pmi_units` (character)
  # The unit in which the PMI time was reported.

  # uncomment below to test the property
  #expect_equal(model.instance$`pmi_units`, "EXPECTED_RESULT")
})

test_that("ccf_id", {
  # tests for the property `ccf_id` (character)
  # HubMap Common Coordinate Framework unique identifier corresponding to the organ, biological structure, and spatial location of the tissue specimen.

  # uncomment below to test the property
  #expect_equal(model.instance$`ccf_id`, "EXPECTED_RESULT")
})

test_that("preservation_method", {
  # tests for the property `preservation_method` (character)
  # The method by which the tissue was preserved: cryopreservation (slow-freeze) or flash-freezing.

  # uncomment below to test the property
  #expect_equal(model.instance$`preservation_method`, "EXPECTED_RESULT")
})

test_that("used_by", {
  # tests for the property `used_by` (set[character])
  # The component(s) of the IGVF consortium that utilize this software.

  # uncomment below to test the property
  #expect_equal(model.instance$`used_by`, "EXPECTED_RESULT")
})

test_that("versions", {
  # tests for the property `versions` (set[character])
  # A list of versions that have been released for this software.

  # uncomment below to test the property
  #expect_equal(model.instance$`versions`, "EXPECTED_RESULT")
})

test_that("version", {
  # tests for the property `version` (character)
  # The version of a particular software.

  # uncomment below to test the property
  #expect_equal(model.instance$`version`, "EXPECTED_RESULT")
})

test_that("download_id", {
  # tests for the property `download_id` (character)
  # The MD5 checksum, SHA-1 commit ID, image hash, or similar permanent identifier of the particular version of software used.

  # uncomment below to test the property
  #expect_equal(model.instance$`download_id`, "EXPECTED_RESULT")
})

test_that("downloaded_url", {
  # tests for the property `downloaded_url` (character)
  # An external resource to track the version of the software downloaded.

  # uncomment below to test the property
  #expect_equal(model.instance$`downloaded_url`, "EXPECTED_RESULT")
})

test_that("amount", {
  # tests for the property `amount` (numeric)
  # Specific quantity of the applied treatment (used in conjunction with amount_units).

  # uncomment below to test the property
  #expect_equal(model.instance$`amount`, "EXPECTED_RESULT")
})

test_that("amount_units", {
  # tests for the property `amount_units` (character)
  # A unit for an amount other than those for time or temperature.

  # uncomment below to test the property
  #expect_equal(model.instance$`amount_units`, "EXPECTED_RESULT")
})

test_that("duration", {
  # tests for the property `duration` (numeric)
  # Duration indicates the time elapsed between the start and end of the treatment.

  # uncomment below to test the property
  #expect_equal(model.instance$`duration`, "EXPECTED_RESULT")
})

test_that("duration_units", {
  # tests for the property `duration_units` (character)
  # A unit of time.

  # uncomment below to test the property
  #expect_equal(model.instance$`duration_units`, "EXPECTED_RESULT")
})

test_that("pH", {
  # tests for the property `pH` (numeric)
  # Final pH of the solution containing a chemical compound (if applicable)

  # uncomment below to test the property
  #expect_equal(model.instance$`pH`, "EXPECTED_RESULT")
})

test_that("purpose", {
  # tests for the property `purpose` (character)
  # The intended purpose for treating the samples; Activation: treatment is known to activate a pathway in the biosample; Agonist: a substance which is known to initiate a physiological response when combined with a receptor; Antagonist: a substance that is known to interfere with or inhibits the physiological action of another; Control: treatment applied to a sample for control purposes; Differentiation: treatment that is applied to convert a less specialized cell to a more specialized cell; De-differentiation: treatment used to reprogram differentiated cells back to less determined cell states; Perturbation: treatment applied to the sample in order to study the effect of its application; Selection: treatment used to affect biosample in a way that can be used to distinguish cells and select for in the downstream steps; Stimulation: treatment applied to stimulate a cellular pathway.

  # uncomment below to test the property
  #expect_equal(model.instance$`purpose`, "EXPECTED_RESULT")
})

test_that("post_treatment_time", {
  # tests for the property `post_treatment_time` (numeric)
  # Post treatment time in conjunction with post treatment time units is used to specify the time that has passed between the point when biosamples were removed from the treatment solution before being sampled or treated with the next treatment.

  # uncomment below to test the property
  #expect_equal(model.instance$`post_treatment_time`, "EXPECTED_RESULT")
})

test_that("post_treatment_time_units", {
  # tests for the property `post_treatment_time_units` (character)
  # A unit of time.

  # uncomment below to test the property
  #expect_equal(model.instance$`post_treatment_time_units`, "EXPECTED_RESULT")
})

test_that("temperature", {
  # tests for the property `temperature` (numeric)
  # The temperature in Celsius to which the sample was exposed

  # uncomment below to test the property
  #expect_equal(model.instance$`temperature`, "EXPECTED_RESULT")
})

test_that("temperature_units", {
  # tests for the property `temperature_units` (character)
  # A unit of temperature.

  # uncomment below to test the property
  #expect_equal(model.instance$`temperature_units`, "EXPECTED_RESULT")
})

test_that("treatment_type", {
  # tests for the property `treatment_type` (character)
  # The classification of treatment agent that specifies its exact molecular nature. Chemical type refers to (natural or synthetic) organic/inorganic compounds and also includes drugs, while protein type is restricted to active protein biomolecules that are naturally or artifically synthesized via cellular translation mechanism of converting DNA into a protein. Environmental type referes to other external conditions that directly influence biological processes or reactions within a given environment. Example of chemical type: lactate, ethanol,hydrocortisone, LPS etc. Example of protein type: Interferons, interlukin, antibodies, etc. Example of chemical type: stiffness.

  # uncomment below to test the property
  #expect_equal(model.instance$`treatment_type`, "EXPECTED_RESULT")
})

test_that("treatment_term_id", {
  # tests for the property `treatment_term_id` (character)
  # Ontology identifier describing a component in the treatment.

  # uncomment below to test the property
  #expect_equal(model.instance$`treatment_term_id`, "EXPECTED_RESULT")
})

test_that("treatment_term_name", {
  # tests for the property `treatment_term_name` (character)
  # Ontology term describing a component in the treatment that is the principal component affecting the biosample being treated. Examples: interferon gamma, interleukin-4, Fibroblast growth factor 2, 20-hydroxyecdysone, 5-bromouridine etc.

  # uncomment below to test the property
  #expect_equal(model.instance$`treatment_term_name`, "EXPECTED_RESULT")
})

test_that("depletion", {
  # tests for the property `depletion` (character)
  # Treatment is depleted.

  # uncomment below to test the property
  #expect_equal(model.instance$`depletion`, "EXPECTED_RESULT")
})

test_that("biosamples_treated", {
  # tests for the property `biosamples_treated` (set[character])
  # The samples which have been treated using this treatment.

  # uncomment below to test the property
  #expect_equal(model.instance$`biosamples_treated`, "EXPECTED_RESULT")
})

test_that("email", {
  # tests for the property `email` (character)
  # The email associated with the user&#39;s account.

  # uncomment below to test the property
  #expect_equal(model.instance$`email`, "EXPECTED_RESULT")
})

test_that("first_name", {
  # tests for the property `first_name` (character)
  # The user&#39;s first (given) name.

  # uncomment below to test the property
  #expect_equal(model.instance$`first_name`, "EXPECTED_RESULT")
})

test_that("last_name", {
  # tests for the property `last_name` (character)
  # The user&#39;s last (family) name.

  # uncomment below to test the property
  #expect_equal(model.instance$`last_name`, "EXPECTED_RESULT")
})

test_that("submits_for", {
  # tests for the property `submits_for` (set[character])
  # Labs user is authorized to submit data for.

  # uncomment below to test the property
  #expect_equal(model.instance$`submits_for`, "EXPECTED_RESULT")
})

test_that("groups", {
  # tests for the property `groups` (set[character])
  # Additional access control groups

  # uncomment below to test the property
  #expect_equal(model.instance$`groups`, "EXPECTED_RESULT")
})

test_that("viewing_groups", {
  # tests for the property `viewing_groups` (set[character])
  # The group that determines which set of data the user has permission to view.

  # uncomment below to test the property
  #expect_equal(model.instance$`viewing_groups`, "EXPECTED_RESULT")
})

test_that("job_title", {
  # tests for the property `job_title` (character)
  # The role of the user in their lab or organization.

  # uncomment below to test the property
  #expect_equal(model.instance$`job_title`, "EXPECTED_RESULT")
})

test_that("workflow_repositories", {
  # tests for the property `workflow_repositories` (set[character])
  # Resources hosting the workflow.

  # uncomment below to test the property
  #expect_equal(model.instance$`workflow_repositories`, "EXPECTED_RESULT")
})

test_that("standards_page", {
  # tests for the property `standards_page` (character)
  # A link to a page describing the standards for this workflow.

  # uncomment below to test the property
  #expect_equal(model.instance$`standards_page`, "EXPECTED_RESULT")
})

test_that("workflow_version", {
  # tests for the property `workflow_version` (integer)
  # The version of this workflow.

  # uncomment below to test the property
  #expect_equal(model.instance$`workflow_version`, "EXPECTED_RESULT")
})

test_that("analysis_steps", {
  # tests for the property `analysis_steps` (set[character])
  # The analysis steps which are part of this workflow.

  # uncomment below to test the property
  #expect_equal(model.instance$`analysis_steps`, "EXPECTED_RESULT")
})
